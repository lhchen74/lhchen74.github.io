



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="露の世" href="https://lhchen74.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="露の世" href="https://lhchen74.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="露の世" href="https://lhchen74.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CFira%20Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="csharp" />


<link rel="canonical" href="https://lhchen74.github.io/2019/10/29/csharp-attribute/">



  <title>
C# 中的 Attribute 特性 |
D E W = 露の世</title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">C# 中的 Attribute 特性
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2019-10-29 00:00:00">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2019-10-29T00:00:00+08:00">2019-10-29</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">D E W</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="/images/三月的狮子-2.jpg"></li>
          <li class="item" data-background-image="/images/中二病也要谈恋爱.jpg"></li>
          <li class="item" data-background-image="/images/黑之契约者.jpg"></li>
          <li class="item" data-background-image="/images/天元突破红莲螺岩.jpg"></li>
          <li class="item" data-background-image="/images/犬夜叉-2.jpg"></li>
          <li class="item" data-background-image="/images/冰菓.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="https://lhchen74.github.io/2019/10/29/csharp-attribute/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="江边鸟">
    <meta itemprop="description" content=", ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="露の世">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <blockquote>
<p>转载: <a target="_blank" rel="noopener" href="https://kb.cnblogs.com/page/87531/">关于 C# 中的 Attribute 特性<em>知识库</em>博客园</a></p>
</blockquote>
<p><strong>摘要：</strong> 纠结地说，这应该算是一篇关于 Attribute 的笔记，其中的一些思路和代码借鉴了他人的文笔（见本文底部链接）。但是，由于此文对 Attribute 的讲解实在是叫好（自夸一下 <sup>_</sup>），所以公之于众，希望能对大家有所帮助。</p>
<p><strong>Attribute 与 Property 的翻译区别</strong></p>
<p>Attribute 一般译作 “特性”，Property 仍然译为 “属性”。</p>
<p><strong>Attribute 是什么</strong></p>
<p>Attribute 是一种可由用户自由定义的修饰符（Modifier），可以用来修饰各种需要被修饰的目标。 <code>简单的说，Attribute 就是一种“附着物” —— 就像牡蛎吸附在船底或礁石上一样。</code>  这些附着物的作用是为它们的附着体追加上一些额外的信息（这些信息就保存在附着物的体内）—— 比如 “这个类是我写的” 或者 “这个函数以前出过问题” 等等。</p>
<p><strong>Attribute 的作用</strong></p>
<p>特性 Attribute 的作用是添加元数据。<br>
元数据可以被工具支持，比如：编译器用元数据来辅助编译，调试器用元数据来调试程序。</p>
<p><strong>Attribute 与注释的区别</strong></p>
<ul>
<li>注释是对程序源代码的一种说明，主要目的是给人看的，在程序被编译的时候会被编译器所丢弃，因此，它丝毫不会影响到程序的执行。</li>
<li>而 Attribute 是程序代码的一部分，不但不会被编译器丢弃，而且还会被编译器编译进程序集（Assembly）的元数据（Metadata）里，在程序运行的时候，你随时可以从元数据里提取出这些附加信息来决策程序的运行。</li>
</ul>
<p>举例：</p>
<p>在项目中，有一个类由两个程序员（小张和小李）共同维护。这个类起一个 “工具包”（Utilities）的作用（<span class="exturl" data-url="aHR0cDovL3huLS1vMXE1MHouTkVU">就像.NET</span> Framework 中的 Math 类一样），里面含了几十个静态方法。而这些静态方法，一半是小张写的、一半是小李写的；在项目的测试中，有一些静态方法曾经出过 bug，后来又被修正。这样，我们就可以把这些方面划分成这样几类：</p>
<img data-src="/2019/10/29/csharp-attribute/201101061335115808.jpg" class="" title="Box">
<p>我们分类的目的主要是在测试的时候可以按不同的类别进行测试、获取不同的效果。比如：统计两个人的工作量或者对曾经出过 bug 的方法进行回归测试。如果不使用 Attribute，为了区分这四类静态方法，我们只能通过注释来说明，但这种方式会有很多弊端；如果使用 Attribute，区分这四类静态方法将会变得简单多了。示例代码如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Buged</span></span><br><span class="line"><span class="comment">//C# 的宏定义必须出现在所有代码之前。当前只让 Buged 宏有效。</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics; <span class="comment">// 注意：这是为了使用包含在此名称空间中的ConditionalAttribute特性</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Con_Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">// 虽然方法都被调用了，但只有符合条件的才会被执行！</span></span><br><span class="line">            ToolKit.FunA();</span><br><span class="line">            ToolKit.FunB();</span><br><span class="line">            ToolKit.FunC();</span><br><span class="line">            ToolKit.FunD();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">ToolKit</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">ConditionalAttribute(<span class="meta-string">&quot;Li&quot;</span>)</span>] <span class="comment">// Attribute名称的长记法</span></span><br><span class="line">        [<span class="meta">ConditionalAttribute(<span class="meta-string">&quot;Buged&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FunA</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Created By Li, Buged.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="meta">Conditional(<span class="meta-string">&quot;Li&quot;</span>)</span>] <span class="comment">// Attribute名称的短记法</span></span><br><span class="line">        [<span class="meta">Conditional(<span class="meta-string">&quot;NoBug&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FunB</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Created By Li, NoBug.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="meta">ConditionalAttribute(<span class="meta-string">&quot;Zhang&quot;</span>)</span>]<span class="comment">// Attribute名称的长记法</span></span><br><span class="line">        [<span class="meta">ConditionalAttribute(<span class="meta-string">&quot;Buged&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FunC</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Created By Zhang, Buged.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="meta">Conditional(<span class="meta-string">&quot;Zhang&quot;</span>)</span>] <span class="comment">// Attribute名称的短记法</span></span><br><span class="line">        [<span class="meta">Conditional(<span class="meta-string">&quot;NoBug&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">FunD</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Created By Zhang, NoBug.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<img data-src="/2019/10/29/csharp-attribute/201101061335121631.png" class="" title="2010-12-21_113636">
<p>注意：运行结果是由代码中 “#define Buged” 这个宏定义所决定。</p>
<p>分析：</p>
<ol>
<li>
<p>在本例中，我们使用了 ConditionalAttribute 这个 Attribute，它被包含在 System.Diagnostics 名称空间中。显然，它多半时间是用来做程序调试与诊断的。</p>
</li>
<li>
<p>与 ConditionalAttribute 相关的是一组 C# 宏，它们看起来与 C 语言的宏别无二致，位置必须出现在所有 C# 代码之前。顾名思义，ConditionalAttribute 是用来判断条件的，凡被 ConditionalAttribute （或 Conditional）“附着” 了的方法，只有满足了条件才会执行。</p>
</li>
<li>
<p>Attribute 就像船底上可以附着很多牡蛎一样，一个方法上也可以附着多个 ConditionalAttribute 的实例。把 Attribute 附着在目标上的书写格式很简单，使用方括号把 Attribute 括起来，然后紧接着写 Attribute 的附着体就行了。当多个 Attribute 附着在同一个目标上时，就把这些 Attribute 的方括号一个挨一个地书写（或者在一对方括号中书写多个 Attribute），而且不必在乎它们的顺序。</p>
</li>
<li>
<p>在使用 Attribute 的时候，有 “长记法” 和 “短记法” 两种，请君自便。</p>
</li>
</ol>
<p>由上面的第 3 条和第 4 条我们可以推出，以下四种 Attribute 的使用方式是完全等价：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 长记法</span></span><br><span class="line">[<span class="meta">ConditionalAttribute(<span class="meta-string">&quot;LI&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">ConditionalAttribute(<span class="meta-string">&quot;NoBug&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Fun</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123; Console.WriteLine(<span class="string">&quot;Created By Li, NoBug.&quot;</span>); &#125;</span><br><span class="line"><span class="comment">// 短记法</span></span><br><span class="line">[<span class="meta">Conditional(<span class="meta-string">&quot;LI&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">Conditional(<span class="meta-string">&quot;NoBug&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Fun</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123; Console.WriteLine(<span class="string">&quot;Created By Li, NoBug.&quot;</span>); &#125;</span><br><span class="line"><span class="comment">// 换序</span></span><br><span class="line">[<span class="meta">Conditional(<span class="meta-string">&quot;NoBug&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">Conditional(<span class="meta-string">&quot;LI&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Fun</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123; Console.WriteLine(<span class="string">&quot;Created By Li, NoBug.&quot;</span>); &#125;</span><br><span class="line"><span class="comment">// 单括号叠加</span></span><br><span class="line">[<span class="meta">Conditional(<span class="meta-string">&quot;NoBug&quot;</span>), Conditional(<span class="meta-string">&quot;LI&quot;</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Fun</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123; Console.WriteLine(<span class="string">&quot;Created By Li, NoBug.&quot;</span>); &#125;</span><br></pre></td></tr></table></figure>
<p><strong>Attribute 的本质</strong></p>
<p>从上面的代码中，我们可以看到 Attribute 似乎总跟 public、static 这些关键字（Keyword）出现在一起。</p>
<p>莫非使用了 Attribute 就相当于定义了新的修饰符（Modifier）吗？让我们来一窥究竟！</p>
<p>示例代码如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XG //C# 的宏定义必须出现在所有代码之前</span></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics; <span class="comment">// 注意：这是为了使用包含在此名称空间中的ConditionalAttribute 特性</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Con_Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program2</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">Conditional(<span class="meta-string">&quot;XG&quot;</span>)</span>]</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Fun</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.ForegroundColor = ConsoleColor.Yellow;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;http://xugang.cnblogs.com&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Fun();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用微软的中间语言反编译器查看 MSIL 中间语言中 TargetMethod:void () 方法的代码，截图如下：</p>
<img data-src="/2019/10/29/csharp-attribute/201101061335147529.png" class="" title="2010-12-21_122656">
<p>可以看出：Attribute 本质上就是一个类，它在所附着的目标对象上最终实例化。</p>
<p>仔细观察中间语言（MSIL）的代码之后，那些被 C# 语言所掩盖的事实，在中间语言（MSIL）中就变得赤身裸体了。而 Attribute 也变得毫无秘密！</p>
<p>图中红色所指的是 Fun 方法及其修饰符，但 Attribute 并没有出现在这里。</p>
<p>图中蓝色所指的是在调用 mscorlib.dll 程序集中 System.Diagnostics 名称空间中 ConditionalAttribute 类的构造函数。</p>
<p>可见，Attribute 并不是修饰符，而是一个有着独特实例化形式的类！</p>
<p><strong>Attribute 实例化有什么独特之处呢？</strong></p>
<ol>
<li>
<p>它的实例是使用.custom 声明的。查看中间语言语法，你会发现.custom 是专门用来声明自定义特性的。</p>
</li>
<li>
<p>声明 Attribute 的位置是在函数体内的真正代码（IL_0000 至 IL_0014 ）之前。</p>
</li>
</ol>
<p>这就从 “底层” 证明了 Attribute 不是什么 “修饰符”，而是一种实例化方式比较特殊的类。</p>
<p><strong>元数据的作用</strong></p>
<p>MSIL 中间语言中，程序集的元数据（Metadata）记录了这个程序集里有多少个 namespace、多少个类、类里有什么成员、成员的访问级别是什么。而且，元数据是以文本（也就是 Unicode 字符）形式存在的，<span class="exturl" data-url="aHR0cDovL3huLS0ycnF6MTNnLk5FVA==">使用.NET</span> 的反射（Reflection）技术就能把它们读取出来，并形成 MSIL 中的树状图、VS 里的 Object Browser 视图，以及自动代码提示功能，这些都是元数据与反射技术结合的产物。一个程序集（.EXE 或.DLL）能够使用包含在自己体内的元数据来完整地说明自己，而不必像 C/C++ 那样带着一大捆头文件，这就叫作 “自包含性” 或 “自描述性”。</p>
<p><strong>Attribute 的实例化</strong></p>
<p>就像牡蛎天生就要吸附在礁石或船底上一样，Attribute 的实例一构造出来就必需 “粘” 在一个什么目标上。</p>
<p>Attribute 实例化的语法是相当怪异的，主要体现在以下三点：</p>
<ol>
<li>
<p>不使用 new 操作符来产生实例，而是使用在方括号里调用构造函数来产生实例。</p>
</li>
<li>
<p>方括号必需紧挨着放置在被附着目标的前面。</p>
</li>
<li>
<p>因为方括号里空间有限，不能像使用 new 那样先构造对象，然后再给对象的属性（Property）赋值。</p>
</li>
</ol>
<p>因此，对 Attribute 实例的属性赋值也在构造函数的圆括号里。</p>
<p>并且，Attribute 实例化时尤其要注意的是：</p>
<ol>
<li>
<p>构造函数的参数是一定要写。有几个就得写几个，因为你不写的话实例就无法构造出来。</p>
</li>
<li>
<p>构造函数参数的顺序不能错。调用任何函数都不能改变参数的顺序，除非它有相应的重载（Overload）。因为这个顺序是固定的，有些书里称其为 “定位参数”（意即 “个数和位置固定的参数”）。</p>
</li>
<li>
<p>对 Attribute 实例的属性的赋值可有可无。反正它会有一个默认值，并且属性赋值的顺序不受限制。有些书里称属性赋值的参数为 “具名参数”。</p>
</li>
</ol>
<p><strong>自定义 Attribute 实例</strong></p>
<p>在此，<span class="exturl" data-url="aHR0cDovL3huLS1paHF6dTBuazcyZGkwdi5ORVQ=">我们不使用.NET</span> Framework 中的各种 Attribute 系统特性，而是从头自定义一个全新的 Attribute 类。</p>
<p>示例代码如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Con_Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program3</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">//使用反射读取Attribute</span></span><br><span class="line">            System.Reflection.MemberInfo info = <span class="keyword">typeof</span>(Student); <span class="comment">//通过反射得到Student类的信息</span></span><br><span class="line">            Hobby hobbyAttr = (Hobby)Attribute.GetCustomAttribute(info, <span class="keyword">typeof</span>(Hobby));</span><br><span class="line">            <span class="keyword">if</span> (hobbyAttr != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;类名：&#123;0&#125;&quot;</span>, info.Name);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;兴趣类型：&#123;0&#125;&quot;</span>, hobbyAttr.Type);</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;兴趣指数：&#123;0&#125;&quot;</span>, hobbyAttr.Level);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意：&quot;Sports&quot; 是给构造函数的赋值， Level = 5 是给属性的赋值。</span></span><br><span class="line">    [<span class="meta">Hobby(<span class="meta-string">&quot;Sports&quot;</span>, Level = 5)</span>]</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="meta">Hobby(<span class="meta-string">&quot;Football&quot;</span>)</span>]</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> profession;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Profession</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> profession; &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123; profession = <span class="keyword">value</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//建议取名：HobbyAttribute</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Hobby</span> : <span class="title">Attribute</span> <span class="comment">// 必须以System.Attribute 类为基类</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 参数值为null的string 危险，所以必需在构造函数中赋值</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Hobby</span>(<span class="params"><span class="built_in">string</span> _type</span>) <span class="comment">// 定位参数</span></span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">this</span>.type = _type;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//兴趣类型</span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> type;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Type</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> type; &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123; type = <span class="keyword">value</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//兴趣指数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> level;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Level</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> level; &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123; level = <span class="keyword">value</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了不让代码太长，上面的示例中 Hobby 类的构造函数只有一个参数，所以对 “定位参数” 体现的还不够淋漓尽致。大家可以为 Hobby 类再添加几个属性，并在构造函数里多设置几个参数，体验一下 Attribute 实例化时对参数个数及参数位置的敏感性。</p>
<p><strong>能被 Attribute 所附着的目标</strong></p>
<p>Attribute 可以将自己的实例附着在什么目标上呢？这个问题的答案隐藏在 AttributeTargets 这个枚举类型里。</p>
<p>这个类型的可取值集合为：</p>
<p>All Assembly Class Constructor</p>
<p>Delegate Enum Event Field</p>
<p>GenericParameter Interface Method Module</p>
<p>Parameter Property ReturnValue Struct</p>
<p>一共是 16 个可取值。上面这张表是按字母顺序排列的，并不代表它们真实值的排列顺序。</p>
<p>使用下面这个小程序可以查看每个枚举值对应的整数值，示例代码如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Con_Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program4</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Assembly\t\t\t&#123;0&#125;&quot;</span>, Convert.ToInt32(AttributeTargets.Assembly));</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Module\t\t\t\t&#123;0&#125;&quot;</span>, Convert.ToInt32(AttributeTargets.Module));</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Class\t\t\t\t&#123;0&#125;&quot;</span>, Convert.ToInt32(AttributeTargets.Class));</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Struct\t\t\t\t&#123;0&#125;&quot;</span>, Convert.ToInt32(AttributeTargets.Struct));</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Enum\t\t\t\t&#123;0&#125;&quot;</span>, Convert.ToInt32(AttributeTargets.Enum));</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Constructor\t\t\t&#123;0&#125;&quot;</span>, Convert.ToInt32(AttributeTargets.Constructor));</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Method\t\t\t\t&#123;0&#125;&quot;</span>, Convert.ToInt32(AttributeTargets.Method));</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Property\t\t\t&#123;0&#125;&quot;</span>, Convert.ToInt32(AttributeTargets.Property));</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Field\t\t\t\t&#123;0&#125;&quot;</span>, Convert.ToInt32(AttributeTargets.Field));</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Event\t\t\t\t&#123;0&#125;&quot;</span>, Convert.ToInt32(AttributeTargets.Event));</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Interface\t\t\t&#123;0&#125;&quot;</span>, Convert.ToInt32(AttributeTargets.Interface));</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Parameter\t\t\t&#123;0&#125;&quot;</span>, Convert.ToInt32(AttributeTargets.Parameter));</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Delegate\t\t\t&#123;0&#125;&quot;</span>, Convert.ToInt32(AttributeTargets.Delegate));</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;ReturnValue\t\t\t&#123;0&#125;&quot;</span>, Convert.ToInt32(AttributeTargets.ReturnValue));</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;GenericParameter\t\t&#123;0&#125;&quot;</span>, Convert.ToInt32(AttributeTargets.GenericParameter));</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;All\t\t\t\t&#123;0&#125;&quot;</span>, Convert.ToInt32(AttributeTargets.All));</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果显示如下：</p>
<img data-src="/2019/10/29/csharp-attribute/20110106133514528.png" class="" title="2010-12-21_232331">
<p>AttributeTargets 使用了枚举值的另一种用法 —— 标识位。<br>
　　除了 All 的值之外，每个值的二进制形式中只有一位是 “1”，其余位全是 “0”。<br>
　　如果我们的 Attribute 要求既能附着在类上，又能附着在类的方法上。就可以使用 C# 中的操作符 “|”（也就是按位求 “或”）。有了它，我们只需要将代码书写如下：</p>
<p>AttributeTargets.Class | AttributeTargets.Method</p>
<p>因为这两个枚举值的标识位（也就是那个唯一的 “1”）是错开的，所以只需要按位求或就解决问题了。</p>
<p>这样，你就能理解：为什么 AttributeTargets.All 的值是 32767 了。</p>
<p>默认情况下，当我们声明并定义一个新的 Attribute 类时，它的可附着目标是 AttributeTargets.All。</p>
<p>大多数情况下，AttributeTargets.All 就已经满足需求了。不过，如果你非要对它有所限制，那就要费点儿周折了。</p>
<p>例如，你想把前面的 Hobby 类的附着目标限制为只有 “类” 和 “字段” 使用，则示例代码如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class, AttributeTargets.Field)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">Hobby</span> : <span class="title">Attribute</span> <span class="comment">// 必须以System.Attribute 类为基类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Hobby 类的具体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是使用 Attribute 的实例（AttributeUsage）附着在 Attribute 类（Hobby）上。Attribute 的本质就是类，而 AttributeUsage 又说明 Hobby 类可以附着在哪些类型上。</p>
<p>附加问题：</p>
<ol>
<li>
<p>如果一个 Attribute 类附着在了某个类上，那么这个 Attribute 类会不会随着继承关系也附着在派生类上呢？</p>
</li>
<li>
<p>可不可以像多个牡蛎附着在同一艘船上那样，让一个 Attribute 类的多个实例附着在同一个目标上呢？</p>
</li>
</ol>
<p>答案：可以。代码如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Class | AttributeTargets.Field, Inherited = false, AllowMultiple = true)</span>]</span><br><span class="line"><span class="keyword">class</span> <span class="title">Hobby</span> : <span class="title">System.Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Hobby 类的具体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AttributeUsage 这个专门用来修饰 Attribute 的 Attribute ，除了可以控制修饰目标外，还能决定被它修饰的 Attribute 是否可以随宿主 “遗传”，以及是否可以使用多个实例来修饰同一个目标！</p>
<p>那修饰 ConditionalAttribute 的 AttributeUsage 又会是什么样子呢？（答案在 MSDN 中）</p>
<p>参考来源：</p>
<p><span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbml3YWxrZXIvYXJjaGl2ZS8yMDAzLzA3LmFzcHg=">Attribute 在.NET 编程的应用</span></p>
<p>[深入浅出 Attribute<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFudGFzaWFYL2FyY2hpdmUvMjAwNy8wNS8yOC8xNjI3Njk0LmFzcHg="> 上] —— Attribute 初体验</span></p>
<p>[深入浅出 Attribute<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRmFudGFzaWFYL2FyY2hpdmUvMjAwNy8wNi8wNC8xNjM2OTEzLmFzcHg="> 中] —— Attribute 本质论</span></p>

      <div class="tags">
          <a href="/tags/csharp/" rel="tag"><i class="ic i-tag"></i> csharp</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2021-10-18 13:27:06" itemprop="dateModified" datetime="2021-10-18T13:27:06+08:00">2021-10-18</time>
  </span>
</div>

      

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2019/10/29/python-asyncio/" itemprop="url" rel="prev" data-background-image="&#x2F;images&#x2F;犬夜叉.jpg" title="Python Asyncio">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>Python Asyncio</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2019/10/29/python-wraps/" itemprop="url" rel="next" data-background-image="&#x2F;images&#x2F;秦时明月-3.jpg" title="Python Wraps">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>Python Wraps</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
      </div>
      <div class="related panel pjax" data-title="Related">
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="江边鸟"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">江边鸟</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">318</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">2</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">43</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xoY2hlbjc0" title="https:&#x2F;&#x2F;github.com&#x2F;lhchen74"><i class="ic i-github"></i></span>
      <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLw==" title="https:&#x2F;&#x2F;music.163.com&#x2F;"><i class="ic i-cloud-music"></i></span>
      <span class="exturl item codepen" data-url="aHR0cHM6Ly9jb2RlcGVuLmlvL2xoY2hlbjc0" title="https:&#x2F;&#x2F;codepen.io&#x2F;lhchen74"><i class="ic i-address-card"></i></span>
      <span class="exturl item anki" data-url="aHR0cHM6Ly9hbmtpd2ViLm5ldC9kZWNrcy8=" title="https:&#x2F;&#x2F;ankiweb.net&#x2F;decks&#x2F;"><i class="ic i-address-card"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>About</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>Friends</a>
  </li>

    
  <li class="item">
    <a href="/anime/" rel="section"><i class="ic i-magic"></i>Anime</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2019/10/29/python-asyncio/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2019/10/29/python-wraps/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2022</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">江边鸟 @ D E W</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2019/10/29/csharp-attribute/',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
