



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="露の世" href="https://lhchen74.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="露の世" href="https://lhchen74.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="露の世" href="https://lhchen74.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CFira%20Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="csharp" />


<link rel="canonical" href="https://lhchen74.github.io/2019/10/25/csharp7/">



  <title>
30分钟掌握 C#7 |
D E W = 露の世</title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">30分钟掌握 C#7
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2019-10-25 00:00:00">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2019-10-25T00:00:00+08:00">2019-10-25</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">D E W</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="/anime/index/龙与虎.jpg"></li>
          <li class="item" data-background-image="/anime/index/红猪-3.jpg"></li>
          <li class="item" data-background-image="/anime/index/薄樱鬼.jpg"></li>
          <li class="item" data-background-image="/anime/index/SSSS.电光机王.jpg"></li>
          <li class="item" data-background-image="/anime/index/秦时明月-2.jpg"></li>
          <li class="item" data-background-image="/anime/index/日常-1.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="https://lhchen74.github.io/2019/10/25/csharp7/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="江边鸟">
    <meta itemprop="description" content=", ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="露の世">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <blockquote>
<p>转载: <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vVlZTdHVkeS9wLzY1NTEzMDAuaHRtbA==">30 分钟掌握 C#7 - Virgil-Zhou - 博客园</span></p>
</blockquote>
<h2 id="out-变量out-variables"><a class="markdownIt-Anchor" href="#out-变量out-variables">#</a> out 变量（out variables）</h2>
<p>以前我们使用 out 变量必须在使用前进行声明，C# 7.0 给我们提供了一种更简洁的语法 “使用时进行内联声明” 。如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = ReadLine();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">int</span>.TryParse(input, <span class="keyword">out</span> <span class="keyword">var</span> result))</span><br><span class="line">&#123;</span><br><span class="line">    WriteLine(<span class="string">&quot;您输入的数字是：&#123;0&#125;&quot;</span>,result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    WriteLine(<span class="string">&quot;无法解析输入...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码编译后：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> num;</span><br><span class="line"><span class="built_in">string</span> s = Console.ReadLine();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">int</span>.TryParse(s, <span class="keyword">out</span> num))</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;您输入的数字是：&#123;0&#125;&quot;</span>, num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;无法解析输入...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理解析：所谓的 “内联声明” 编译后就是以前的原始写法，只是现在由编译器来完成。</p>
<p>备注：在进行内联声明时，即可直接写明变量的类型也可以写隐式类型，因为 out 关键字修饰的一定是局部变量。</p>
<h2 id="元组tuples"><a class="markdownIt-Anchor" href="#元组tuples">#</a> 元组（Tuples）</h2>
<p><strong>元组（Tuple）在 .Net 4.0 的时候就有了，但元组也有些缺点，如：</strong></p>
<p>1）Tuple 会影响代码的可读性，因为它的属性名都是：Item1，Item2… 。</p>
<p>2）Tuple 还不够轻量级，因为它是引用类型（Class）。</p>
<p>备注：上述所指 Tuple 还不够轻量级，是从某种意义上来说的或者是一种假设，即假设分配操作非常的多。</p>
<p><strong>C# 7 中的元组（ValueTuple）解决了上述两个缺点：</strong></p>
<p>1）ValueTuple 支持语义上的字段命名。</p>
<p>2）ValueTuple 是值类型（Struct）。</p>
<p><strong>1. 如何创建一个元组？</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tuple = (<span class="number">1</span>, <span class="number">2</span>);                           <span class="comment">// 使用语法糖创建元组</span></span><br><span class="line"><span class="keyword">var</span> tuple2 = ValueTuple.Create(<span class="number">1</span>, <span class="number">2</span>);         <span class="comment">// 使用静态方法【Create】创建元组</span></span><br><span class="line"><span class="keyword">var</span> tuple3 = <span class="keyword">new</span> ValueTuple&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt;(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// 使用 new 运算符创建元组</span></span><br><span class="line"></span><br><span class="line">WriteLine(<span class="string">$&quot;first：<span class="subst">&#123;tuple.Item1&#125;</span>, second：<span class="subst">&#123;tuple.Item2&#125;</span>, 上面三种方式都是等价的。&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>原理解析：上面三种方式最终都是使用 new 运算符来创建实例。</p>
<p><strong>2. 如何创建给字段命名的元组？</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左边指定字段名称</span></span><br><span class="line">(<span class="built_in">int</span> one, <span class="built_in">int</span> two) tuple = (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">WriteLine(<span class="string">$&quot;first：<span class="subst">&#123;tuple.one&#125;</span>, second：<span class="subst">&#123;tuple.two&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 右边指定字段名称</span></span><br><span class="line"><span class="keyword">var</span> tuple2 = (one: <span class="number">1</span>, two: <span class="number">2</span>);</span><br><span class="line">WriteLine(<span class="string">$&quot;first：<span class="subst">&#123;tuple2.one&#125;</span>, second：<span class="subst">&#123;tuple2.two&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 左右两边同时指定字段名称</span></span><br><span class="line">(<span class="built_in">int</span> one, <span class="built_in">int</span> two) tuple3 = (first: <span class="number">1</span>, second: <span class="number">2</span>);    <span class="comment">/* 此处会有警告：由于目标类型（xx）已指定了其它名称，因为忽略元组名称xxx */</span></span><br><span class="line">WriteLine(<span class="string">$&quot;first：<span class="subst">&#123;tuple3.one&#125;</span>, second：<span class="subst">&#123;tuple3.two&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>注：左右两边同时指定字段名称，会使用左边的字段名称覆盖右边的字段名称（一一对应）。</p>
<p>原理解析：上述给字段命名的元组在编译后其字段名称还是：Item1, Item2…，即：“命名” 只是语义上的命名。</p>
<p><strong>3. 什么是解构？</strong></p>
<p>解构顾名思义就是将整体分解成部分。</p>
<p><strong>4. 解构元组，如下所示：</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (one, two) = GetTuple();</span><br><span class="line"></span><br><span class="line">WriteLine(<span class="string">$&quot;first：<span class="subst">&#123;one&#125;</span>, second：<span class="subst">&#123;two&#125;</span>&quot;</span>);</span><br><span class="line"><span class="keyword">static</span> (<span class="built_in">int</span>, <span class="built_in">int</span>) GetTuple()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理解析：解构元组就是将元组中的字段值赋值给声明的局部变量（编译后可查看）。</p>
<p>备注：在解构时 “=” 左边能提取变量的数据类型（如上所示），元组中字段类型相同时即可提取具体类型也可以是隐式类型，但元组中字段类型</p>
<p>不相同时只能提取隐式类型。</p>
<p><strong>5. 解构可以应用于 .Net 的任意类型，但需要编写 Deconstruct 方法成员（实例或扩展）。如下所示：</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Name = name;</span><br><span class="line">        Age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Deconstruct</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">string</span> name, <span class="keyword">out</span> <span class="built_in">int</span> age</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        name = Name;</span><br><span class="line">        age = Age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方式如下：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (Name, Age) = <span class="keyword">new</span> Student(<span class="string">&quot;Mike&quot;</span>, <span class="number">30</span>);</span><br><span class="line">WriteLine(<span class="string">$&quot;name：<span class="subst">&#123;Name&#125;</span>, age：<span class="subst">&#123;Age&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>原理解析：编译后就是由其实例调用 Deconstruct 方法，然后给局部变量赋值。</p>
<p>Deconstruct 方法签名：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例签名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Deconstruct</span>(<span class="params"><span class="keyword">out</span> type variable1, <span class="keyword">out</span> type variable2...</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 扩展签名</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Deconstruct</span>(<span class="params"><span class="keyword">this</span> type instance, <span class="keyword">out</span> type variable1, <span class="keyword">out</span> type variable2...</span>)</span></span><br></pre></td></tr></table></figure>
<p>总结：1. 元组的原理是利用了成员类型的嵌套或者是说成员类型的递归。2. 编译器很牛 B 才能提供如此优美的语法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 ValueTuple 则需要导入: Install - Package System.ValueTuple</span><br></pre></td></tr></table></figure>
<h2 id="模式匹配pattern-matching"><a class="markdownIt-Anchor" href="#模式匹配pattern-matching">#</a> 模式匹配（Pattern matching）</h2>
<p><strong>1. is 表达式（is expressions），如：</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">GetSum</span>(<span class="params">IEnumerable&lt;<span class="built_in">object</span>&gt; values</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (values == <span class="literal">null</span>) <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> values)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">is</span> <span class="built_in">short</span>)     <span class="comment">// C# 7 之前的 is expressions</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum += (<span class="built_in">short</span>)item;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (item <span class="keyword">is</span> <span class="built_in">int</span> val)  <span class="comment">// C# 7 的 is expressions</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum += val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (item <span class="keyword">is</span> <span class="built_in">string</span> str &amp;&amp; <span class="built_in">int</span>.TryParse(str, <span class="keyword">out</span> <span class="keyword">var</span> result))  <span class="comment">// is expressions 和 out variables 结合使用</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum += result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (item <span class="keyword">is</span> IEnumerable&lt;<span class="built_in">object</span>&gt; subList)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += GetSum(subList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">条件控制语句（obj <span class="keyword">is</span> type variable）</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// Processing...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理解析：此 is 非彼 is ，这个扩展的 is 其实是 as 和 if 的组合。即它先进行 as 转换再进行 if 判断，判断其结果是否为 null，不等于 null 则执行</p>
<p>语句块逻辑，反之不行。由上可知其实 C# 7 之前我们也可实现类似的功能，只是写法上比较繁琐。</p>
<p><strong>2. switch 语句更新（switch statement updates），如：</strong></p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">GetSum</span>(<span class="params">IEnumerable&lt;<span class="built_in">object</span>&gt; values</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (values == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> values)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (item)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:                <span class="comment">// 常量模式匹配</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">short</span> sval:       <span class="comment">// 类型模式匹配</span></span><br><span class="line">                sum += sval;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">int</span> ival:</span><br><span class="line">                sum += ival;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">string</span> str <span class="keyword">when</span> <span class="built_in">int</span>.TryParse(str, <span class="keyword">out</span> <span class="keyword">var</span> result):   <span class="comment">// 类型模式匹配 + 条件表达式</span></span><br><span class="line">                sum += result;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> IEnumerable&lt;<span class="built_in">object</span>&gt; subList <span class="keyword">when</span> subList.Any():</span><br><span class="line">                sum += GetSum(subList);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">&quot;未知的类型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> type variable1:</span><br><span class="line">        <span class="comment">// processing...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> type variable2 <span class="keyword">when</span> predicate:</span><br><span class="line">        <span class="comment">// processing...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="literal">default</span>:</span><br><span class="line">        <span class="comment">// processing...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理解析：此 switch 非彼 switch，编译后你会发现扩展的 switch 就是 as 、if 、goto 语句的组合体。同 is expressions 一样，以前我们也能实</p>
<p>现只是写法比较繁琐并且可读性不强。</p>
<p>总结：模式匹配语法是想让我们在简单的情况下实现类似与多态一样的动态调用，即在运行时确定成员类型和调用具体的实现。</p>
<h2 id="局部引用和引用返回-ref-locals-and-returns"><a class="markdownIt-Anchor" href="#局部引用和引用返回-ref-locals-and-returns">#</a> 局部引用和引用返回 (Ref locals and returns)</h2>
<p>我们知道 C# 的 ref 和 out 关键字是对值传递的一个补充，是为了防止值类型大对象在 Copy 过程中损失更多的性能。现在在 C# 7 中 ref 关键字得</p>
<p>到了加强，它不仅可以获取值类型的引用而且还可以获取某个变量（引用类型）的局部引用。如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ref</span> <span class="built_in">int</span> <span class="title">GetLocalRef</span>(<span class="params"><span class="built_in">int</span>[,] arr, Func&lt;<span class="built_in">int</span>, <span class="built_in">bool</span>&gt; func</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arr.GetLength(<span class="number">0</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; arr.GetLength(<span class="number">1</span>); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (func(arr[i, j]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">ref</span> arr[i, j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException(<span class="string">&quot;Not found&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Call：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[,] arr = &#123; &#123; <span class="number">10</span>, <span class="number">15</span> &#125;, &#123; <span class="number">20</span>, <span class="number">25</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">ref</span> <span class="keyword">var</span> num = <span class="function"><span class="keyword">ref</span> <span class="title">GetLocalRef</span>(<span class="params">arr, c =&gt; c == <span class="number">20</span></span>)</span>;</span><br><span class="line">num = <span class="number">600</span>;</span><br><span class="line">Console.WriteLine(arr[<span class="number">1</span>, <span class="number">0</span>]);</span><br></pre></td></tr></table></figure>
<p>Print results：600</p>
<p><strong>使用方法：</strong></p>
<ol>
<li>
<p>方法的返回值必须是引用返回：</p>
<p>a) 声明方法签名时必须在返回类型前加上 ref 修饰。</p>
<p>b) 在每个 return 关键字后也要加上 ref 修饰，以表明是返回引用。</p>
</li>
<li>
<p>分配引用（即赋值），必须在声明局部变量前加上 ref 修饰，以及在方法返回引用前加上 ref 修饰。</p>
<p>注：C# 开发的是托管代码，所以一般不希望程序员去操作指针。并由上述可知在使用过程中需要大量的使用 ref 来标明这是引用变量（编译后其实没那么多），当然这也是为了提高代码的可读性。</p>
</li>
</ol>
<p>** 总结：**** 虽然 C# 7 中提供了局部引用和引用返回，但为了防止滥用所以也有诸多约束，如：**</p>
<ol>
<li>你不能将一个值分配给 ref 变量，如：</li>
</ol>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ref</span> <span class="built_in">int</span> num = <span class="number">10</span>;   <span class="comment">// error：无法使用值初始化按引用变量\2. 你不能返回一个生存期不超过方法作用域的变量引用，如：</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">ref</span> <span class="built_in">int</span> <span class="title">GetLocalRef</span>(<span class="params"><span class="built_in">int</span> num</span>)</span> =&gt; <span class="keyword">ref</span> num;   <span class="comment">// error: 无法按引用返回参数，因为它不是 ref 或 out 参数</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>ref 不能修饰 “属性” 和 “索引器”。</li>
</ol>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"><span class="keyword">ref</span> <span class="keyword">var</span> n = <span class="keyword">ref</span> list.Count;  <span class="comment">// error: 属性或索引器不能作为 out 或 ref 参数传递</span></span><br></pre></td></tr></table></figure>
<p>原理解析：非常简单就是指针传递，并且个人觉得此语法的使用场景非常有限，都是用来处理大对象的，目的是减少 GC 提高性能。</p>
<h2 id="局部函数local-functions"><a class="markdownIt-Anchor" href="#局部函数local-functions">#</a> 局部函数（Local functions）</h2>
<p>C# 7 中的一个功能 “局部函数”，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> IEnumerable&lt;<span class="built_in">char</span>&gt; <span class="title">GetCharList</span>(<span class="params"><span class="built_in">string</span> str</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsNullOrWhiteSpace(str))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(str));</span><br><span class="line">    <span class="keyword">return</span> GetList();</span><br><span class="line">    <span class="function">IEnumerable&lt;<span class="built_in">char</span>&gt; <span class="title">GetList</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; str.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">数据类型,void</span>] 方法名（[参数]）</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// Method body；[] 里面都是可选项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理解析：局部函数虽然是在其他函数内部声明，但它编译后就是一个被 internal 修饰的静态函数，它是属于类，至于它为什么能够使用上级函</p>
<p>数中的局部变量和参数呢？那是因为编译器会根据其使用的成员生成一个新类型（Class/Struct）然后将其传入函数中。由上可知则局部函数的声</p>
<p>明跟位置无关，并可无限嵌套。</p>
<p>总结：个人觉得局部函数是对 C# 异常机制在语义上的一次补充（如上例），以及为代码提供清晰的结构而设置的语法。但局部函数也有其缺点，</p>
<p>就是局部函数中的代码无法复用（反射除外）。</p>
<h2 id="更多的表达式体成员more-expression-bodied-members"><a class="markdownIt-Anchor" href="#更多的表达式体成员more-expression-bodied-members">#</a> 更多的表达式体成员（More expression-bodied members）</h2>
<p>C# 6 的时候就支持表达式体成员，但当时只支持 “函数成员” 和 “只读属性”，这一特性在 C# 7 中得到了扩展，它能支持更多的成员：构造函数</p>
<p>、析构函数、带 get，set 访问器的属性、以及索引器。如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="comment">// Expression-bodied constructor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">string</span> name</span>)</span> =&gt; _name = name;</span><br><span class="line">    <span class="comment">// Expression-bodied finalizer</span></span><br><span class="line">    ~Student() =&gt; Console.WriteLine(<span class="string">&quot;Finalized!&quot;</span>);</span><br><span class="line">    <span class="comment">// Expression-bodied get / set accessors.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; _name;</span><br><span class="line">        <span class="keyword">set</span> =&gt; _name = <span class="keyword">value</span> ?? <span class="string">&quot;Mike&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Expression-bodied indexers</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">string</span> name] =&gt; Convert.ToBase64String(Encoding.UTF8.GetBytes(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>备注：索引器其实在 C# 6 中就得到了支持，但其它三种在 C# 6 中未得到支持。</p>
<h2 id="throw-表达式throw-expressions"><a class="markdownIt-Anchor" href="#throw-表达式throw-expressions">#</a> Throw 表达式（Throw expressions）</h2>
<p>异常机制是 C# 的重要组成部分，但在以前并不是所有语句都可以抛出异常的，如：条件表达式（？ ：）、null 合并运算符（??）、一些 Lambda</p>
<p>表达式。而使用 C# 7 您可在任意地方抛出异常。如：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> _name = GetName() ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(GetName));</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _age;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> =&gt; _age;</span><br><span class="line">        <span class="keyword">set</span> =&gt; _age = <span class="keyword">value</span> &lt;= <span class="number">0</span> || <span class="keyword">value</span> &gt;= <span class="number">130</span> ? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;参数不合法&quot;</span>) : <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">GetName</span>(<span class="params"></span>)</span> =&gt; <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="扩展异步返回类型generalized-async-return-types"><a class="markdownIt-Anchor" href="#扩展异步返回类型generalized-async-return-types">#</a> 扩展异步返回类型（Generalized async return types）</h2>
<p>以前异步的返回类型必须是：Task、Task<T>、void，现在 C# 7 中新增了一种类型：ValueTask<T>，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> ValueTask&lt;<span class="built_in">int</span>&gt; <span class="title">Func</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">await</span> Task.Delay(<span class="number">3000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结：ValueTask<T> 与 ValueTuple 非常相似，所以就不列举： ValueTask<T> 与 Task 之间的异同了，但它们都是为了优化特定场景性能而</p>
<p>新增的类型。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 ValueTask&lt;T&gt; 则需要导入： Install - Package System.Threading.Tasks.Extensions</span><br></pre></td></tr></table></figure>
<h2 id="数字文本语法的改进numeric-literal-syntax-improvements"><a class="markdownIt-Anchor" href="#数字文本语法的改进numeric-literal-syntax-improvements">#</a> 数字文本语法的改进（Numeric literal syntax improvements）</h2>
<p>C# 7 还包含两个新特性：二进制文字、数字分隔符，如下所示：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> one = <span class="number">0b0001</span>;</span><br><span class="line"><span class="keyword">var</span> sixteen = <span class="number">0b0001</span>_0000;</span><br><span class="line"><span class="built_in">long</span> salary = <span class="number">1000</span>_000_000;</span><br><span class="line"><span class="built_in">decimal</span> pi = <span class="number">3.141</span>_592_653_589m;</span><br></pre></td></tr></table></figure>
<p>注：二进制文本是以 0b（零 b）开头，字母不区分大小写；数字分隔符只有三个地方不能写：开头，结尾，小数点前后。</p>
<p>总结：二进制文本，数字分隔符 可使常量值更具可读性。</p>

      <div class="tags">
          <a href="/tags/csharp/" rel="tag"><i class="ic i-tag"></i> csharp</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2022-01-07 15:16:32" itemprop="dateModified" datetime="2022-01-07T15:16:32+08:00">2022-01-07</time>
  </span>
</div>

      

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2019/10/25/javascript-promise/" itemprop="url" rel="prev" data-background-image="&#x2F;anime&#x2F;index&#x2F;未闻花名-2.jpg" title="Promise 对象">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>Promise 对象</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2019/10/25/csharp-dotnetcore-iis/" itemprop="url" rel="next" data-background-image="&#x2F;anime&#x2F;index&#x2F;凹凸世界.jpg" title="在 IIS 上部署你的 ASP.NET Core 项目">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>在 IIS 上部署你的 ASP.NET Core 项目</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#out-%E5%8F%98%E9%87%8Fout-variables"><span class="toc-number">1.</span> <span class="toc-text"> out 变量（out variables）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E7%BB%84tuples"><span class="toc-number">2.</span> <span class="toc-text"> 元组（Tuples）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8Dpattern-matching"><span class="toc-number">3.</span> <span class="toc-text"> 模式匹配（Pattern matching）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%BC%95%E7%94%A8%E5%92%8C%E5%BC%95%E7%94%A8%E8%BF%94%E5%9B%9E-ref-locals-and-returns"><span class="toc-number">4.</span> <span class="toc-text"> 局部引用和引用返回 (Ref locals and returns)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%87%BD%E6%95%B0local-functions"><span class="toc-number">5.</span> <span class="toc-text"> 局部函数（Local functions）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%BD%93%E6%88%90%E5%91%98more-expression-bodied-members"><span class="toc-number">6.</span> <span class="toc-text"> 更多的表达式体成员（More expression-bodied members）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#throw-%E8%A1%A8%E8%BE%BE%E5%BC%8Fthrow-expressions"><span class="toc-number">7.</span> <span class="toc-text"> Throw 表达式（Throw expressions）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%BC%82%E6%AD%A5%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8Bgeneralized-async-return-types"><span class="toc-number">8.</span> <span class="toc-text"> 扩展异步返回类型（Generalized async return types）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E6%96%87%E6%9C%AC%E8%AF%AD%E6%B3%95%E7%9A%84%E6%94%B9%E8%BF%9Bnumeric-literal-syntax-improvements"><span class="toc-number">9.</span> <span class="toc-text"> 数字文本语法的改进（Numeric literal syntax improvements）</span></a></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="江边鸟"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">江边鸟</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">335</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">2</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">46</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xoY2hlbjc0" title="https:&#x2F;&#x2F;github.com&#x2F;lhchen74"><i class="ic i-github"></i></span>
      <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLw==" title="https:&#x2F;&#x2F;music.163.com&#x2F;"><i class="ic i-cloud-music"></i></span>
      <span class="exturl item codepen" data-url="aHR0cHM6Ly9jb2RlcGVuLmlvL2xoY2hlbjc0" title="https:&#x2F;&#x2F;codepen.io&#x2F;lhchen74"><i class="ic i-address-card"></i></span>
      <span class="exturl item anki" data-url="aHR0cHM6Ly9hbmtpd2ViLm5ldC9kZWNrcy8=" title="https:&#x2F;&#x2F;ankiweb.net&#x2F;decks&#x2F;"><i class="ic i-address-card"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>About</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>Friends</a>
  </li>

    
  <li class="item">
    <a href="/anime/" rel="section"><i class="ic i-magic"></i>Anime</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2019/10/25/javascript-promise/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2019/10/25/csharp-dotnetcore-iis/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">江边鸟 @ D E W</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2019/10/25/csharp7/',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
