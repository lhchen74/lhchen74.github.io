



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="露の世" href="https://lhchen74.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="露の世" href="https://lhchen74.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="露の世" href="https://lhchen74.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="csharp" />


<link rel="canonical" href="https://lhchen74.github.io/2019/10/28/csharp-async/">



  <title>
C#中 Thread，Task，Async/Await，IAsyncResult 的那些事儿！ |
Dew's World = 露の世</title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">C#中 Thread，Task，Async/Await，IAsyncResult 的那些事儿！
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2019-10-28 00:00:00">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2019-10-28T00:00:00+08:00">2019-10-28</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Dew's World</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicli3sbvtj20zk0m8x6p.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipeubcbajj20zk0m8h1h.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicis081o9j20zk0m8dmr.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giciuja1j1j20zk0m8kjl.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicit31ffoj20zk0m8naf.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclwrdwyaj20zk0m8are.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="https://lhchen74.github.io/2019/10/28/csharp-async/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="江边鸟">
    <meta itemprop="description" content=", ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="露の世">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <blockquote>
<p>转载: <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZG9mb3JmdXR1cmUvcC82MjkzOTI2Lmh0bWw=">C# 中 Thread，Task，Async/Await，IAsyncResult 的那些事儿！ - Mr 靖 - 博客园</span></p>
</blockquote>
<p>说起异步，Thread，Task，async/await，IAsyncResult 这些东西肯定是绕不开的，今天就来依次聊聊他们</p>
<h3 id="1线程thread"><a class="markdownIt-Anchor" href="#1线程thread">#</a> 1. 线程（Thread）</h3>
<p>多线程的意义在于一个应用程序中，有多个执行部分可以同时执行；对于比较耗时的操作 (例如 io，数据库操作)，或者等待响应 (如 WCF 通信) 的操作，可以单独开启后台线程来执行，这样主线程就不会阻塞，可以继续往下执行；等到后台线程执行完毕，再通知主线程，然后做出对应操作！</p>
<p>在 C# 中开启新线程比较简单</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">    <span class="comment">//IsBackground=true，将其设置为后台线程</span></span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(Run) &#123; IsBackground = <span class="literal">true</span> &#125;;</span><br><span class="line">    t.Start();　　 Console.WriteLine(<span class="string">&quot;主线程在做其他的事！&quot;</span>);</span><br><span class="line">    <span class="comment">//主线程结束，后台线程会自动结束，不管有没有执行完成</span></span><br><span class="line">    <span class="comment">//Thread.Sleep(300);</span></span><br><span class="line">    Thread.Sleep(<span class="number">1500</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;主线程结束&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Thread.Sleep(<span class="number">700</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;这是后台线程调用&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下图，</p>
<img data-src="/2019/10/28/csharp-async/961949-20170117195306349-1589524780.png" class="">
<p>可以看到在启动后台线程之后，主线程继续往下执行了，并没有等到后台线程执行完之后。</p>
<h4 id="11-线程池"><a class="markdownIt-Anchor" href="#11-线程池">#</a> 1.1 线程池</h4>
<p>试想一下，如果有大量的任务需要处理，例如网站后台对于 HTTP 请求的处理，那是不是要对每一个请求创建一个后台线程呢？显然不合适，这会占用大量内存，而且频繁地创建的过程也会严重影响速度，那怎么办呢？线程池就是为了解决这一问题，把创建的线程存起来，形成一个线程池 (里面有多个线程)，当要处理任务时，若线程池中有空闲线程 (前一个任务执行完成后，线程不会被回收，会被设置为空闲状态)，则直接调用线程池中的线程执行 (例 <span class="exturl" data-url="aHR0cDovL2FzcC5uZXQ=">asp.net</span> 处理机制中的 Application 对象)，</p>
<p>使用事例：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    ThreadPool.QueueUserWorkItem(m =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(Thread.CurrentThread.ManagedThreadId.ToString());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">Console.Read();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<img data-src="/2019/10/28/csharp-async/961949-20170117201545927-996676824.png" class="">
<p>可以看到，虽然执行了 10 次，但并没有创建 10 个线程。</p>
<h4 id="12-信号量semaphore"><a class="markdownIt-Anchor" href="#12-信号量semaphore">#</a> 1.2 信号量 (Semaphore)</h4>
<p>Semaphore 负责协调线程，可以限制对某一资源访问的线程数量</p>
<p>这里对 SemaphoreSlim 类的用法做一个简单的事例：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> SemaphoreSlim semLim = <span class="keyword">new</span> SemaphoreSlim(<span class="number">3</span>); <span class="comment">//3表示最多只能有三个线程同时访问</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(SemaphoreTest).Start();</span><br><span class="line">    &#125;</span><br><span class="line">    Console.Read();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SemaphoreTest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    semLim.Wait();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;线程&quot;</span> + Thread.CurrentThread.ManagedThreadId.ToString() + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">    Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;线程&quot;</span> + Thread.CurrentThread.ManagedThreadId.ToString() + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">    semLim.Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<p><img data-src="csharp-async/961949-20170117203646958-1977296136.png" alt=""><img data-src="csharp-async/961949-20170117203659896-1181181789.png" alt=""></p>
<p>可以看到，刚开始只有三个线程在执行，当一个线程执行完毕并释放之后，才会有新的线程来执行方法！</p>
<p>除了 SemaphoreSlim 类，还可以使用 Semaphore 类，感觉更加灵活，感兴趣的话可以搜一下，这里就不做演示了！</p>
<h3 id="2task"><a class="markdownIt-Anchor" href="#2task">#</a> 2.Task</h3>
<p>Task 是.NET4.0 加入的，跟线程池 ThreadPool 的功能类似，用 Task 开启新任务时，会从线程池中调用线程，而 Thread 每次实例化都会创建一个新的线程。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;主线程启动&quot;</span>);</span><br><span class="line"><span class="comment">//Task.Run启动一个线程</span></span><br><span class="line"><span class="comment">//Task启动的是后台线程，要在主线程中等待后台线程执行完毕，可以调用Wait方法</span></span><br><span class="line"><span class="comment">//Task task = Task.Factory.StartNew(() =&gt; &#123; Thread.Sleep(1500); Console.WriteLine(&quot;task启动&quot;); &#125;);</span></span><br><span class="line">Task task = Task.Run(() =&gt; &#123;</span><br><span class="line">    Thread.Sleep(<span class="number">1500</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;task启动&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">Thread.Sleep(<span class="number">300</span>);</span><br><span class="line">task.Wait();</span><br><span class="line">Console.WriteLine(<span class="string">&quot;主线程结束&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<img data-src="/2019/10/28/csharp-async/961949-20170118085009734-1482384411.png" class="">
<p>开启新任务的方法：Task.Run () 或者 Task.Factory.StartNew ()，开启的是后台线程</p>
<p>要在主线程中等待后台线程执行完毕，可以使用 Wait 方法 (会以同步的方式来执行)。不用 Wait 则会以异步的方式来执行。</p>
<p>比较一下 Task 和 Thread：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(Run1).Start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Task.Run(() =&gt; &#123; Run2(); &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Thread Id =&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Run2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Task调用的Thread Id =&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<img data-src="/2019/10/28/csharp-async/961949-20170118090705000-522306854.png" class="">
<p>可以看出来，直接用 Thread 会开启 5 个线程，用 Task (用了线程池) 开启了 3 个！</p>
<h4 id="21-tasktresult"><a class="markdownIt-Anchor" href="#21-tasktresult">#</a> 2.1 Task&lt;TResult&gt;</h4>
<p>Task<TResult>就是有返回值的 Task，TResult 就是返回值类型。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line"><span class="comment">//返回值类型为string</span></span><br><span class="line">Task&lt;<span class="built_in">string</span>&gt; task = Task&lt;<span class="built_in">string</span>&gt;.Run(() =&gt; &#123;</span><br><span class="line">    Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.CurrentThread.ManagedThreadId.ToString();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//会等到task执行完毕才会输出;</span></span><br><span class="line">Console.WriteLine(task.Result);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;主线程结束&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<img data-src="/2019/10/28/csharp-async/961949-20170118091731015-299922614.png" class="">
<p>通过 task.Result 可以取到返回值，若取值的时候，后台线程还没执行完，则会等待其执行完毕！</p>
<p>简单提一下：</p>
<p>Task 任务可以通过 CancellationTokenSource 类来取消，感觉用得不多，用法比较简单，感兴趣的话可以搜一下！</p>
<h3 id="3-asyncawait"><a class="markdownIt-Anchor" href="#3-asyncawait">#</a> 3. async/await</h3>
<p>async/await 是 C#5.0 中推出的，先上用法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;-------主线程启动-------&quot;</span>);</span><br><span class="line">    Task&lt;<span class="built_in">int</span>&gt; task = GetStrLengthAsync();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;主线程继续执行&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Task返回的值&quot;</span> + task.Result);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;-------主线程结束-------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">async</span> Task&lt;<span class="built_in">int</span>&gt; <span class="title">GetStrLengthAsync</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;GetStrLengthAsync方法开始执行&quot;</span>);</span><br><span class="line">    <span class="comment">//此处返回的&lt;string&gt;中的字符串类型，而不是Task&lt;string&gt;</span></span><br><span class="line">    <span class="built_in">string</span> str = <span class="keyword">await</span> GetString();</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;GetStrLengthAsync方法执行结束&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> str.Length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Task&lt;<span class="built_in">string</span>&gt; <span class="title">GetString</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;　　 <span class="comment">//Console.WriteLine(&quot;GetString方法开始执行&quot;)</span></span><br><span class="line">    <span class="keyword">return</span> Task&lt;<span class="built_in">string</span>&gt;.Run(() =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GetString的返回值&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>async 用来修饰方法，表明这个方法是异步的，声明的方法的返回类型必须为：void，Task 或 Task<TResult>。</p>
<p>await 必须用来修饰 Task 或 Task<TResult>，而且只能出现在已经用 async 关键字修饰的异步方法中。通常情况下，async/await 成对出现才有意义，</p>
<p>看看运行结果：</p>
<img data-src="/2019/10/28/csharp-async/961949-20170118105225406-295296622.png" class="">
<p>可以看出来，main 函数调用 GetStrLengthAsync 方法后，在 await 之前，都是同步执行的，直到遇到 await 关键字，main 函数才返回继续执行。</p>
<p>那么是否是在遇到 await 关键字的时候程序自动开启了一个后台线程去执行 GetString 方法呢？</p>
<p>现在把 GetString 方法中的那行注释加上，运行的结果是：</p>
<img data-src="/2019/10/28/csharp-async/961949-20170118154317578-1834160773.png" class="">
<p>大家可以看到，在遇到 await 关键字后，没有继续执行 GetStrLengthAsync 方法后面的操作，也没有马上反回到 main 函数中，而是执行了 GetString 的第一行，以此可以判断 await 这里并没有开启新的线程去执行 GetString 方法，而是以同步的方式让 GetString 方法执行，等到执行到 GetString 方法中的 Task<string>.Run () 的时候才由 Task 开启了后台线程！</p>
<p>那么 await 的作用是什么呢？</p>
<p>可以从字面上理解，上面提到 task.wait 可以让主线程等待后台线程执行完毕，await 和 wait 类似，同样是等待，等待 Task<string>.Run () 开始的后台线程执行完毕，不同的是 await 不会阻塞主线程，只会让 GetStrLengthAsync 方法暂停执行。</p>
<p>那么 await 是怎么做到的呢？有没有开启新线程去等待？</p>
<img data-src="/2019/10/28/csharp-async/961949-20170118110648281-1989485250.png" class="">
<p>只有两个线程 (主线程和 Task 开启的线程)！至于怎么做到的 (我也不知道…&gt;_&lt;)，大家有兴趣的话研究下吧！</p>
<h3 id="4iasyncresult"><a class="markdownIt-Anchor" href="#4iasyncresult">#</a> 4.IAsyncResult</h3>
<p>IAsyncResult 自.NET1.1 起就有了，包含可异步操作的方法的类需要实现它，Task 类就实现了该接口</p>
<img data-src="/2019/10/28/csharp-async/961949-20170118112245406-1795624419.png" class="">
<p>在不借助于 Task 的情况下怎么实现异步呢？</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;主程序开始--------------------&quot;</span>);</span><br><span class="line">        <span class="built_in">int</span> threadId;</span><br><span class="line">        AsyncDemo ad = <span class="keyword">new</span> AsyncDemo();</span><br><span class="line">        AsyncMethodCaller caller = <span class="keyword">new</span> AsyncMethodCaller(ad.TestMethod);</span><br><span class="line"></span><br><span class="line">        IAsyncResult result = caller.BeginInvoke(<span class="number">3000</span>,<span class="keyword">out</span> threadId, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">        Thread.Sleep(<span class="number">0</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;主线程线程 &#123;0&#125; 正在运行.&quot;</span>,Thread.CurrentThread.ManagedThreadId)</span><br><span class="line">        <span class="comment">//会阻塞线程，直到后台线程执行完毕之后，才会往下执行</span></span><br><span class="line">        result.AsyncWaitHandle.WaitOne();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;主程序在做一些事情！！！&quot;</span>);</span><br><span class="line">        <span class="comment">//获取异步执行的结果</span></span><br><span class="line">        <span class="built_in">string</span> returnValue = caller.EndInvoke(<span class="keyword">out</span> threadId, result);</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        result.AsyncWaitHandle.Close();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;主程序结束--------------------&quot;</span>);</span><br><span class="line">        Console.Read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AsyncDemo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//供后台线程执行的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">TestMethod</span>(<span class="params"><span class="built_in">int</span> callDuration, <span class="keyword">out</span> <span class="built_in">int</span> threadId</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;测试方法开始执行.&quot;</span>);</span><br><span class="line">        Thread.Sleep(callDuration);</span><br><span class="line">        threadId = Thread.CurrentThread.ManagedThreadId;</span><br><span class="line">        <span class="keyword">return</span> String.Format(<span class="string">&quot;测试方法执行的时间 &#123;0&#125;.&quot;</span>, callDuration.ToString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">string</span> <span class="title">AsyncMethodCaller</span>(<span class="params"><span class="built_in">int</span> callDuration, <span class="keyword">out</span> <span class="built_in">int</span> threadId</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>关键步骤就是红色字体的部分，运行结果：</p>
<img data-src="/2019/10/28/csharp-async/961949-20170118113612765-2137493432.png" class="">
<p>和 Task 的用法差异不是很大！result.AsyncWaitHandle.WaitOne () 就类似 Task 的 Wait。</p>
<h3 id="5parallel"><a class="markdownIt-Anchor" href="#5parallel">#</a> 5.Parallel</h3>
<p>最后说一下在循环中开启多线程的简单方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Stopwatch watch1 = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">watch1.Start();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    Console.Write(i + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">    Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">watch1.Stop();</span><br><span class="line">Console.WriteLine(watch1.Elapsed);</span><br><span class="line"></span><br><span class="line">Stopwatch watch2 = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">watch2.Start();</span><br><span class="line"></span><br><span class="line"><span class="comment">//会调用线程池中的线程</span></span><br><span class="line">Parallel.For(<span class="number">1</span>, <span class="number">11</span>, i =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(i + <span class="string">&quot;,线程ID:&quot;</span> + Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">watch2.Stop();</span><br><span class="line">Console.WriteLine(watch2.Elapsed);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<img data-src="/2019/10/28/csharp-async/961949-20170118120638546-1060840155.png" class="">
<p>循环 List<T>：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;() &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;Parallel.ForEach&lt;<span class="built_in">int</span>&gt;(list, n =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(n);</span><br><span class="line">    Thread.Sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>执行 Action [] 数组里面的方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Action[] actions = <span class="keyword">new</span> Action[] &#123;</span><br><span class="line">   <span class="keyword">new</span> Action(()=&gt;&#123;</span><br><span class="line">       Console.WriteLine(<span class="string">&quot;方法1&quot;</span>);</span><br><span class="line">   &#125;),</span><br><span class="line">    <span class="keyword">new</span> Action(()=&gt;&#123;</span><br><span class="line">       Console.WriteLine(<span class="string">&quot;方法2&quot;</span>);</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;;</span><br><span class="line">Parallel.Invoke(actions);</span><br></pre></td></tr></table></figure>
<h3 id="6异步的回调"><a class="markdownIt-Anchor" href="#6异步的回调">#</a> 6. 异步的回调</h3>
<p>文中所有 Task<TResult>的返回值都是直接用 task.result 获取，这样如果后台任务没有执行完毕的话，主线程会等待其执行完毕，这样的话就和同步一样了（看上去一样，但其实 await 的时候并不会造成线程的阻塞，web 程序感觉不到，但是 wpf，winform 这样的桌面程序若不使用异步，会造成 UI 线程的阻塞）。简单演示一下 Task 回调函数的使用：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">Task&lt;<span class="built_in">string</span>&gt; task = Task&lt;<span class="built_in">string</span>&gt;.Run(() =&gt; &#123;</span><br><span class="line">    Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.CurrentThread.ManagedThreadId.ToString();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//会等到任务执行完之后执行</span></span><br><span class="line">task.GetAwaiter().OnCompleted(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(task.Result);</span><br><span class="line">&#125;);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;主线程结束&quot;</span>);</span><br><span class="line">Console.Read();</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<img data-src="/2019/10/28/csharp-async/961949-20170118161613750-1153439412.png" class="">
<p>OnCompleted 中的代码会在任务执行完成之后执行！</p>
<p>另外 task.ContinueWith () 也是一个重要的方法：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;主线程开始&quot;</span>);</span><br><span class="line">Task&lt;<span class="built_in">string</span>&gt; task = Task&lt;<span class="built_in">string</span>&gt;.Run(() =&gt; &#123;</span><br><span class="line">    Thread.Sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.CurrentThread.ManagedThreadId.ToString();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">task.GetAwaiter().OnCompleted(() =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(task.Result);</span><br><span class="line">&#125;);</span><br><span class="line">task.ContinueWith(m=&gt;&#123;Console.WriteLine(<span class="string">&quot;第一个任务结束啦！我是第二个任务&quot;</span>);&#125;);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;主线程结束&quot;</span>);</span><br><span class="line">Console.Read();</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<img data-src="/2019/10/28/csharp-async/961949-20170118162851046-569728154.png" class="">
<p>ContinueWith () 方法可以让该后台线程继续执行新的任务。</p>
<p>Task 的使用还是比较灵活的，大家可以研究下，好了，以上就是全部内容了，篇幅和能力都有限，希望对大家有用！</p>

      <div class="tags">
          <a href="/tags/csharp/" rel="tag"><i class="ic i-tag"></i> csharp</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2021-06-05 16:25:17" itemprop="dateModified" datetime="2021-06-05T16:25:17+08:00">2021-06-05</time>
  </span>
</div>

      

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2019/10/28/go-json/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipewkhf1zj20zk0m81kx.jpg" title="GO小知识之如何做JSON美化">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>GO小知识之如何做JSON美化</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2019/10/28/concept-x509-certificate/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclflwv2aj20zk0m84qp.jpg" title="X.509数字证书的结构与解析">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>X.509数字证书的结构与解析</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E7%BA%BF%E7%A8%8Bthread"><span class="toc-number">1.</span> <span class="toc-text"> 1. 线程（Thread）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.1.</span> <span class="toc-text"> 1.1 线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore"><span class="toc-number">1.2.</span> <span class="toc-text"> 1.2 信号量 (Semaphore)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2task"><span class="toc-number">2.</span> <span class="toc-text"> 2.Task</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21-tasktresult"><span class="toc-number">2.1.</span> <span class="toc-text"> 2.1 Task&lt;TResult&gt;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-asyncawait"><span class="toc-number">3.</span> <span class="toc-text"> 3. async&#x2F;await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4iasyncresult"><span class="toc-number">4.</span> <span class="toc-text"> 4.IAsyncResult</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5parallel"><span class="toc-number">5.</span> <span class="toc-text"> 5.Parallel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E5%BC%82%E6%AD%A5%E7%9A%84%E5%9B%9E%E8%B0%83"><span class="toc-number">6.</span> <span class="toc-text"> 6. 异步的回调</span></a></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="江边鸟"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">江边鸟</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">242</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">1</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">40</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xoY2hlbjc0" title="https:&#x2F;&#x2F;github.com&#x2F;lhchen74"><i class="ic i-github"></i></span>
      <span class="exturl item twitter" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;twitter.com&#x2F;yourname"><i class="ic i-twitter"></i></span>
      <span class="exturl item zhihu" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;yourname"><i class="ic i-zhihu"></i></span>
      <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPXlvdXJpZA==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;yourid"><i class="ic i-cloud-music"></i></span>
      <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span>
      <span class="exturl item about" data-url="aHR0cHM6Ly9hYm91dC5tZS95b3VybmFtZQ==" title="https:&#x2F;&#x2F;about.me&#x2F;yourname"><i class="ic i-address-card"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>About</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a>
  </li>

    
  <li class="item">
    <a href="/links/" rel="section"><i class="ic i-magic"></i>links</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2019/10/28/go-json/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2019/10/28/concept-x509-certificate/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2021</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">江边鸟 @ Dew's World</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2019/10/28/csharp-async/',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
