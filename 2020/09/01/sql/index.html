



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="我知这世界本如露水般短暂 然而 然而" href="https://lhchen74.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="我知这世界本如露水般短暂 然而 然而" href="https://lhchen74.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="我知这世界本如露水般短暂 然而 然而" href="https://lhchen74.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="db" />


<link rel="canonical" href="https://lhchen74.github.io/2020/09/01/sql/">



  <title>
sql - manual |
露の世 = 我知这世界本如露水般短暂 然而 然而</title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">sql
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2020-09-01 00:00:00">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2020-09-01T00:00:00+08:00">2020-09-01</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">露の世</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclhnx9glj20zk0m8npd.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclfw2t96j20zk0m8x6p.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1giclhfehz7j20zk0m8u0x.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipevuctzzj20zk0m84qp.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipewkhf1zj20zk0m81kx.jpg"></li>
          <li class="item" data-background-image="https://tva1.sinaimg.cn/large/6833939bly1gipewf5l51j20zk0m8b29.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/manual/" itemprop="item" rel="index" title="In manual"><span itemprop="name">manual</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="https://lhchen74.github.io/2020/09/01/sql/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="江边鸟">
    <meta itemprop="description" content=", ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="我知这世界本如露水般短暂 然而 然而">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <blockquote>
<p>SQL 进阶教程 /（日） MICK 著；吴炎昌译. – 北京：人民邮电出版社， 2017.11（图灵程序设计丛书）ISBN 978-7-115-47052-2</p>
</blockquote>
<h2 id="case-表达式"><a class="markdownIt-Anchor" href="#case-表达式">#</a> CASE 表达式</h2>
<h3 id="case-表达式写法"><a class="markdownIt-Anchor" href="#case-表达式写法">#</a> CASE 表达式写法</h3>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 简单 CASE 表达式</span></span><br><span class="line"><span class="keyword">CASE</span> sex</span><br><span class="line">	<span class="keyword">WHEN</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;男&#x27;</span></span><br><span class="line">	<span class="keyword">WHEN</span> <span class="string">&#x27;2&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;女&#x27;</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">&#x27;其他&#x27;</span> <span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 搜索 CASE 表达式</span></span><br><span class="line"><span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;男&#x27;</span></span><br><span class="line">	  <span class="keyword">WHEN</span> sex <span class="operator">=</span> <span class="string">&#x27;2&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;女&#x27;</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">&#x27;其他&#x27;</span> <span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<h3 id="case-表达式注意事项"><a class="markdownIt-Anchor" href="#case-表达式注意事项">#</a> CASE 表达式注意事项</h3>
<p><strong>注意事项 1：统一各分支返回的数据类型</strong></p>
<p>虽然这一点无需多言，但这里还是要强调一下：一定要注意 CASE 表达式里各个分支返回的数据类型是否一致。某个分支返回字符型，而其他分支返回数值型的写法是不正确的。</p>
<p><strong>注意事项 2：不要忘了写 END</strong></p>
<p>使用 CASE 表达式的时候，最容易出现的语法错误是忘记写 END。虽然忘记写时程序会返回比较容易理解的错误消息，不算多么致命的错误。但是，感觉自己写得没问题，而执行时却出错的情况大多是由这个原因引起的，所以请一定注意一下。</p>
<p><strong>注意事项 3：养成写 ELSE 子句的习惯</strong></p>
<p>与 END 不同， ELSE 子句是可选的，不写也不会出错。不写 ELSE 子句时，CASE 表达式的执行结果是 NULL。但是不写可能会造成 “语法没有错误，结果却不对” 这种不易追查原因的麻烦，所以最好明确地写上 ELSE 子句（即便是在结果可以为 NULL 的情况下）。养成这样的习惯后，我们从代码上就可以清楚地看到这种条件下会生成 NULL，而且将来代码有修改时也能减少失误。</p>
<h3 id="将已有编号方式转换为新的方式并统计"><a class="markdownIt-Anchor" href="#将已有编号方式转换为新的方式并统计">#</a> 将已有编号方式转换为新的方式并统计</h3>
<img data-src="/2020/09/01/sql/case01.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 把县编号转换成地区编号 (1)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span> pref_name</span><br><span class="line">			<span class="keyword">WHEN</span> <span class="string">&#x27;德岛&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;四国&#x27;</span></span><br><span class="line">			<span class="keyword">WHEN</span> <span class="string">&#x27;香川&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;四国&#x27;</span></span><br><span class="line">			<span class="keyword">WHEN</span> <span class="string">&#x27;爱媛&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;四国&#x27;</span></span><br><span class="line">			<span class="keyword">WHEN</span> <span class="string">&#x27;高知&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;四国&#x27;</span></span><br><span class="line">			<span class="keyword">WHEN</span> <span class="string">&#x27;福冈&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;九州&#x27;</span></span><br><span class="line">			<span class="keyword">WHEN</span> <span class="string">&#x27;佐贺&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;九州&#x27;</span></span><br><span class="line">			<span class="keyword">WHEN</span> <span class="string">&#x27;长崎&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;九州&#x27;</span></span><br><span class="line">			<span class="keyword">ELSE</span> <span class="string">&#x27;其他&#x27;</span> <span class="keyword">END</span> <span class="keyword">AS</span> district,</span><br><span class="line">			<span class="built_in">SUM</span>(population)</span><br><span class="line"><span class="keyword">FROM</span> PopTbl</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">CASE</span> pref_name</span><br><span class="line">			<span class="keyword">WHEN</span> <span class="string">&#x27;德岛&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;四国&#x27;</span></span><br><span class="line">			<span class="keyword">WHEN</span> <span class="string">&#x27;香川&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;四国&#x27;</span></span><br><span class="line">			<span class="keyword">WHEN</span> <span class="string">&#x27;爱媛&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;四国&#x27;</span></span><br><span class="line">			<span class="keyword">WHEN</span> <span class="string">&#x27;高知&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;四国&#x27;</span></span><br><span class="line">			<span class="keyword">WHEN</span> <span class="string">&#x27;福冈&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;九州&#x27;</span></span><br><span class="line">			<span class="keyword">WHEN</span> <span class="string">&#x27;佐贺&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;九州&#x27;</span></span><br><span class="line">			<span class="keyword">WHEN</span> <span class="string">&#x27;长崎&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;九州&#x27;</span></span><br><span class="line">			<span class="keyword">ELSE</span> <span class="string">&#x27;其他&#x27;</span> <span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按人口数量等级划分都道府县</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> population <span class="operator">&lt;</span> <span class="number">100</span> <span class="keyword">THEN</span> <span class="string">&#x27;01&#x27;</span></span><br><span class="line">			<span class="keyword">WHEN</span> population <span class="operator">&gt;=</span> <span class="number">100</span> <span class="keyword">AND</span> population <span class="operator">&lt;</span> <span class="number">200</span> <span class="keyword">THEN</span> <span class="string">&#x27;02&#x27;</span></span><br><span class="line">			<span class="keyword">WHEN</span> population <span class="operator">&gt;=</span> <span class="number">200</span> <span class="keyword">AND</span> population <span class="operator">&lt;</span> <span class="number">300</span> <span class="keyword">THEN</span> <span class="string">&#x27;03&#x27;</span></span><br><span class="line">			<span class="keyword">WHEN</span> population <span class="operator">&gt;=</span> <span class="number">300</span> <span class="keyword">THEN</span> <span class="string">&#x27;04&#x27;</span></span><br><span class="line">			<span class="keyword">ELSE</span> <span class="keyword">NULL</span> <span class="keyword">END</span> <span class="keyword">AS</span> pop_class,</span><br><span class="line">			<span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> cnt</span><br><span class="line"><span class="keyword">FROM</span> PopTbl</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> population <span class="operator">&lt;</span> <span class="number">100</span> <span class="keyword">THEN</span> <span class="string">&#x27;01&#x27;</span></span><br><span class="line">			  <span class="keyword">WHEN</span> population <span class="operator">&gt;=</span> <span class="number">100</span> <span class="keyword">AND</span> population <span class="operator">&lt;</span> <span class="number">200</span> <span class="keyword">THEN</span> <span class="string">&#x27;02&#x27;</span></span><br><span class="line">			  <span class="keyword">WHEN</span> population <span class="operator">&gt;=</span> <span class="number">200</span> <span class="keyword">AND</span> population <span class="operator">&lt;</span> <span class="number">300</span> <span class="keyword">THEN</span> <span class="string">&#x27;03&#x27;</span></span><br><span class="line">			  <span class="keyword">WHEN</span> population <span class="operator">&gt;=</span> <span class="number">300</span> <span class="keyword">THEN</span> <span class="string">&#x27;04&#x27;</span></span><br><span class="line">			  <span class="keyword">ELSE</span> <span class="keyword">NULL</span> <span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line">pop_class cnt</span><br><span class="line"><span class="comment">--------- ----</span></span><br><span class="line"><span class="number">01</span> 		   <span class="number">1</span></span><br><span class="line"><span class="number">02</span> 		   <span class="number">3</span></span><br><span class="line"><span class="number">03</span>        <span class="number">3</span></span><br><span class="line"><span class="number">04</span>        <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="用一条-sql-语句进行不同条件的统计"><a class="markdownIt-Anchor" href="#用一条-sql-语句进行不同条件的统计">#</a> 用一条 SQL 语句进行不同条件的统计</h3>
<img data-src="/2020/09/01/sql/case02.png" class="">
<p>新手用 WHERE 子句进行条件分支，高手用 SELECT 子句进行条件分支。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这种方式可以实现列转行</span></span><br><span class="line"><span class="keyword">SELECT</span> pref_name,</span><br><span class="line">	   <span class="comment">-- 男性人口</span></span><br><span class="line">	   <span class="built_in">SUM</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">THEN</span> population <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> cnt_m,</span><br><span class="line">	   <span class="comment">-- 女性人口</span></span><br><span class="line">	   <span class="built_in">SUM</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex <span class="operator">=</span> <span class="string">&#x27;2&#x27;</span> <span class="keyword">THEN</span> population <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) <span class="keyword">AS</span> cnt_f</span><br><span class="line"><span class="keyword">FROM</span> PopTbl2</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> pref_name;</span><br></pre></td></tr></table></figure>
<h3 id="用-check-约束定义多个列的条件关系"><a class="markdownIt-Anchor" href="#用-check-约束定义多个列的条件关系">#</a> 用 CHECK 约束定义多个列的条件关系</h3>
<p>假设某公司规定 “女性员工的工资必须在 20 万日元以下”，而在这个公司的人事表中，这条无理的规定是使用 CHECK 约束来描述的，代码如下所示。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONSTRAINT</span> check_salary <span class="keyword">CHECK</span></span><br><span class="line">	( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex <span class="operator">=</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line">		   <span class="keyword">THEN</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> salary <span class="operator">&lt;=</span> <span class="number">200000</span></span><br><span class="line">		             <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span></span><br><span class="line">		   <span class="keyword">ELSE</span> <span class="number">1</span> <span class="keyword">END</span> <span class="operator">=</span> <span class="number">1</span> )</span><br></pre></td></tr></table></figure>
<h3 id="在-update-语句里进行条件分支"><a class="markdownIt-Anchor" href="#在-update-语句里进行条件分支">#</a> 在 UPDATE 语句里进行条件分支</h3>
<ol>
<li>对当前工资为 30 万日元以上的员工，降薪 10%。</li>
<li>对当前工资为 25 万日元以上且不满 28 万日元的员工，加薪 20%。</li>
</ol>
<img data-src="/2020/09/01/sql/case03.png" class="">
<img data-src="/2020/09/01/sql/case04.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用 CASE 表达式写正确的更新操作</span></span><br><span class="line">UPDATE Salaries</span><br><span class="line">   <span class="keyword">SET</span> salary <span class="operator">=</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> salary <span class="operator">&gt;=</span> <span class="number">300000</span></span><br><span class="line">					 <span class="keyword">THEN</span> salary <span class="operator">*</span> <span class="number">0.9</span></span><br><span class="line">					 <span class="keyword">WHEN</span> salary <span class="operator">&gt;=</span> <span class="number">250000</span> <span class="keyword">AND</span> salary <span class="operator">&lt;</span> <span class="number">280000</span></span><br><span class="line">					 <span class="keyword">THEN</span> salary <span class="operator">*</span> <span class="number">1.2</span></span><br><span class="line">					 <span class="keyword">ELSE</span> salary <span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p>用 CASE 表达式调换主键 a, b 的值</p>
<img data-src="/2020/09/01/sql/case05.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用 CASE 表达式调换主键值</span></span><br><span class="line">UPDATE SomeTable</span><br><span class="line">   <span class="keyword">SET</span> p_key <span class="operator">=</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> p_key <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">					<span class="keyword">THEN</span> <span class="string">&#x27;b&#x27;</span></span><br><span class="line">					<span class="keyword">WHEN</span> p_key <span class="operator">=</span> <span class="string">&#x27;b&#x27;</span></span><br><span class="line">					<span class="keyword">THEN</span> <span class="string">&#x27;a&#x27;</span></span><br><span class="line">					<span class="keyword">ELSE</span> p_key <span class="keyword">END</span></span><br><span class="line">					<span class="keyword">WHERE</span> p_key <span class="keyword">IN</span> (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="表之间的数据匹配"><a class="markdownIt-Anchor" href="#表之间的数据匹配">#</a> 表之间的数据匹配</h3>
<p>与 DECODE 函数等相比，CASE 表达式的一大优势在于能够判断表达式。也就是说，在 CASE 表达式里，我们可以使用 BETWEEN、 LIKE 和 &lt;、&gt; 等便利的谓词组合，以及能嵌套子查询的 IN 和 EXISTS 谓词。因此， CASE 表达式具有非常强大的表达能力。</p>
<img data-src="/2020/09/01/sql/case06.png" class="">
<img data-src="/2020/09/01/sql/case07.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表的匹配：使用IN谓词</span></span><br><span class="line"><span class="keyword">SELECT</span> CM.course_name,</span><br><span class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> CM.course_id <span class="keyword">IN</span></span><br><span class="line">                    (<span class="keyword">SELECT</span> course_id <span class="keyword">FROM</span> OpenCourses</span><br><span class="line">                      <span class="keyword">WHERE</span> <span class="keyword">month</span> <span class="operator">=</span> <span class="number">200706</span>) <span class="keyword">THEN</span> <span class="string">&#x27;○&#x27;</span></span><br><span class="line">            <span class="keyword">ELSE</span> <span class="string">&#x27;×&#x27;</span> <span class="keyword">END</span> <span class="keyword">AS</span> &quot;6月&quot;,</span><br><span class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> CM.course_id <span class="keyword">IN</span></span><br><span class="line">                    (<span class="keyword">SELECT</span> course_id <span class="keyword">FROM</span> OpenCourses</span><br><span class="line">                      <span class="keyword">WHERE</span> <span class="keyword">month</span> <span class="operator">=</span> <span class="number">200707</span>) <span class="keyword">THEN</span> <span class="string">&#x27;○&#x27;</span></span><br><span class="line">            <span class="keyword">ELSE</span> <span class="string">&#x27;×&#x27;</span> <span class="keyword">END</span> <span class="keyword">AS</span> &quot;7月&quot;,</span><br><span class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> CM.course_id <span class="keyword">IN</span></span><br><span class="line">                    (<span class="keyword">SELECT</span> course_id <span class="keyword">FROM</span> OpenCourses</span><br><span class="line">                      <span class="keyword">WHERE</span> <span class="keyword">month</span> <span class="operator">=</span> <span class="number">200708</span>) <span class="keyword">THEN</span> <span class="string">&#x27;○&#x27;</span></span><br><span class="line">            <span class="keyword">ELSE</span> <span class="string">&#x27;×&#x27;</span> <span class="keyword">END</span>  <span class="keyword">AS</span> &quot;8月&quot;</span><br><span class="line">  <span class="keyword">FROM</span> CourseMaster CM;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表的匹配：使用EXISTS谓词</span></span><br><span class="line"><span class="keyword">SELECT</span> CM.course_name,</span><br><span class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">EXISTS</span></span><br><span class="line">                    (<span class="keyword">SELECT</span> course_id <span class="keyword">FROM</span> OpenCourses OC</span><br><span class="line">                      <span class="keyword">WHERE</span> <span class="keyword">month</span> <span class="operator">=</span> <span class="number">200706</span></span><br><span class="line">                        <span class="keyword">AND</span> CM.course_id <span class="operator">=</span> OC.course_id) <span class="keyword">THEN</span> <span class="string">&#x27;○&#x27;</span></span><br><span class="line">            <span class="keyword">ELSE</span> <span class="string">&#x27;×&#x27;</span> <span class="keyword">END</span> <span class="keyword">AS</span> &quot;6月&quot;,</span><br><span class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">EXISTS</span></span><br><span class="line">                    (<span class="keyword">SELECT</span> course_id <span class="keyword">FROM</span> OpenCourses OC</span><br><span class="line">                      <span class="keyword">WHERE</span> <span class="keyword">month</span> <span class="operator">=</span> <span class="number">200707</span></span><br><span class="line">                        <span class="keyword">AND</span> CM.course_id <span class="operator">=</span> OC.course_id) <span class="keyword">THEN</span> <span class="string">&#x27;○&#x27;</span></span><br><span class="line">            <span class="keyword">ELSE</span> <span class="string">&#x27;×&#x27;</span> <span class="keyword">END</span> <span class="keyword">AS</span> &quot;7月&quot;,</span><br><span class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">EXISTS</span></span><br><span class="line">                    (<span class="keyword">SELECT</span> course_id <span class="keyword">FROM</span> OpenCourses OC</span><br><span class="line">                      <span class="keyword">WHERE</span> <span class="keyword">month</span> <span class="operator">=</span> <span class="number">200708</span></span><br><span class="line">                        <span class="keyword">AND</span> CM.course_id <span class="operator">=</span> OC.course_id) <span class="keyword">THEN</span> <span class="string">&#x27;○&#x27;</span></span><br><span class="line">            <span class="keyword">ELSE</span> <span class="string">&#x27;×&#x27;</span> <span class="keyword">END</span>  <span class="keyword">AS</span> &quot;8月&quot;</span><br><span class="line">  <span class="keyword">FROM</span> CourseMaster CM;</span><br></pre></td></tr></table></figure>
<h3 id="在-case-表达式中使用聚合函数"><a class="markdownIt-Anchor" href="#在-case-表达式中使用聚合函数">#</a> 在 CASE 表达式中使用聚合函数</h3>
<img data-src="/2020/09/01/sql/case08.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在CASE表达式中使用聚合函数</span></span><br><span class="line"><span class="keyword">SELECT</span> std_id,</span><br><span class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">=</span> <span class="number">1</span> <span class="comment">-- 只加入了一个社团的学生</span></span><br><span class="line">            <span class="keyword">THEN</span> <span class="built_in">MAX</span>(club_id)</span><br><span class="line">            <span class="keyword">ELSE</span> <span class="built_in">MAX</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> main_club_flg <span class="operator">=</span> <span class="string">&#x27;Y&#x27;</span></span><br><span class="line">                          <span class="keyword">THEN</span> club_id</span><br><span class="line">                          <span class="keyword">ELSE</span> <span class="keyword">NULL</span> <span class="keyword">END</span>)</span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">AS</span> main_club</span><br><span class="line">  <span class="keyword">FROM</span> StudentClub</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> std_id;</span><br><span class="line"></span><br><span class="line"> std_id main_club</span><br><span class="line"><span class="comment">------ ----------</span></span><br><span class="line">    <span class="number">100</span>  <span class="number">1</span></span><br><span class="line">    <span class="number">200</span>  <span class="number">3</span></span><br><span class="line">    <span class="number">300</span>  <span class="number">4</span></span><br><span class="line">    <span class="number">400</span>  <span class="number">5</span></span><br><span class="line">    <span class="number">500</span>  <span class="number">6</span></span><br></pre></td></tr></table></figure>
<h2 id="自连接的用法"><a class="markdownIt-Anchor" href="#自连接的用法">#</a> 自连接的用法</h2>
<h3 id="可重排列-排列-组合"><a class="markdownIt-Anchor" href="#可重排列-排列-组合">#</a> 可重排列、排列、组合</h3>
<p>假设这里有一张存放了商品名称及价格的表，表里有 “苹果、橘子、香蕉” 这 3 条记录。在生成用于查询销售额的报表等的时候，我们有时会<br>
需要获取这些商品的组合。</p>
<img data-src="/2020/09/01/sql/selfjoin01.png" class="">
<p>这里所说的组合其实分为两种类型。一种是有顺序的有序对（orderedpair），另一种是无顺序的无序对（unordered pair）。有序对用尖括号括起来，如 &lt;1, 2&gt;；无序对用花括号括起来，如 {1, 2}。在有序对里，如果元素顺序相反，那就是不同的对，因此 &lt;1, 2&gt; ≠ &lt;2, 1&gt; ；而无序对与顺序无关，因此 {1, 2}＝{2, 1}。用学校里学到的术语来说，这两类分别对应着 “排列” 和 “组合”。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用于获取可重排列的 SQL 语句 3^2</span></span><br><span class="line"><span class="keyword">SELECT</span> P1.name <span class="keyword">AS</span> name_1, P2.name <span class="keyword">AS</span> name_2</span><br><span class="line">  <span class="keyword">FROM</span> Products P1, Products P2;</span><br><span class="line"></span><br><span class="line">name_1 name_2</span><br><span class="line"><span class="comment">------ ------</span></span><br><span class="line">苹果    苹果</span><br><span class="line">苹果    橘子</span><br><span class="line">苹果    香蕉</span><br><span class="line">橘子    苹果</span><br><span class="line">橘子    橘子</span><br><span class="line">橘子    香蕉</span><br><span class="line">香蕉    苹果</span><br><span class="line">香蕉    橘子</span><br><span class="line">香蕉    香蕉</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用于获取排列的 SQL 语句 P&lt;sub&gt;3&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt;</span></span><br><span class="line"><span class="keyword">SELECT</span> P1.name <span class="keyword">AS</span> name_1, P2.name <span class="keyword">AS</span> name_2</span><br><span class="line">  <span class="keyword">FROM</span> Products P1, Products P2</span><br><span class="line"> <span class="keyword">WHERE</span> P1.name <span class="operator">&lt;&gt;</span> P2.name;</span><br><span class="line"></span><br><span class="line">name_1 name_2</span><br><span class="line"><span class="comment">------ ------</span></span><br><span class="line">苹果   橘子</span><br><span class="line">苹果   香蕉</span><br><span class="line">橘子   苹果</span><br><span class="line">橘子   香蕉</span><br><span class="line">香蕉   苹果</span><br><span class="line">香蕉   橘子</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用于获取组合的 SQL 语句 C&lt;sub&gt;3&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt;</span></span><br><span class="line"><span class="keyword">SELECT</span> P1.name <span class="keyword">AS</span> name_1, P2.name <span class="keyword">AS</span> name_2</span><br><span class="line">  <span class="keyword">FROM</span> Products P1, Products P2</span><br><span class="line"> <span class="keyword">WHERE</span> P1.name <span class="operator">&gt;</span> P2.name;</span><br><span class="line"></span><br><span class="line">name_1 name_2</span><br><span class="line"><span class="comment">------ ------</span></span><br><span class="line">苹果   橘子</span><br><span class="line">香蕉   橘子</span><br><span class="line">香蕉   苹果</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用于获取组合的 SQL 语句 ：扩展成 3 列</span></span><br><span class="line"><span class="keyword">SELECT</span> P1.name <span class="keyword">AS</span> name_1, P2.name <span class="keyword">AS</span> name_2, P3.name <span class="keyword">AS</span> name_3</span><br><span class="line">  <span class="keyword">FROM</span> Products P1, Products P2, Products P3</span><br><span class="line"> <span class="keyword">WHERE</span> P1.name <span class="operator">&gt;</span> P2.name</span><br><span class="line">   <span class="keyword">AND</span> P2.name <span class="operator">&gt;</span> P3.name;</span><br><span class="line"></span><br><span class="line">name_1  name_2   name_3</span><br><span class="line"><span class="comment">------- -------- --------</span></span><br><span class="line">香蕉     苹果     橘子</span><br></pre></td></tr></table></figure>
<h3 id="删除重复行"><a class="markdownIt-Anchor" href="#删除重复行">#</a> 删除重复行</h3>
<img data-src="/2020/09/01/sql/selfjoin02.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用于删除重复行的SQL语句（1）：使用极值函数</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Products P1</span><br><span class="line"> <span class="keyword">WHERE</span> rowid <span class="operator">&lt;</span> ( <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(P2.rowid)</span><br><span class="line">                   <span class="keyword">FROM</span> Products P2</span><br><span class="line">                  <span class="keyword">WHERE</span> P1.name <span class="operator">=</span> P2. name</span><br><span class="line">                    <span class="keyword">AND</span> P1.price <span class="operator">=</span> P2.price ) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用于删除重复行的SQL语句（2）：使用非等值连接</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Products P1</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> ( <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">                  <span class="keyword">FROM</span> Products P2</span><br><span class="line">                 <span class="keyword">WHERE</span> P1.name <span class="operator">=</span> P2.name</span><br><span class="line">                   <span class="keyword">AND</span> P1.price <span class="operator">=</span> P2.price</span><br><span class="line">                   <span class="keyword">AND</span> P1.rowid <span class="operator">&lt;</span> P2.rowid );</span><br></pre></td></tr></table></figure>
<h3 id="查找局部不一致的列"><a class="markdownIt-Anchor" href="#查找局部不一致的列">#</a> 查找局部不一致的列</h3>
<p>如果家庭 ID 一样，住址也必须一样。那么我们该如何找出像前田夫妇这样的 “是同一家人但住址却不同的记录” 呢？</p>
<img data-src="/2020/09/01/sql/selfjoin03.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用于查找是同一家人但住址却不同的记录的SQL语句</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> A1.name, A1.address</span><br><span class="line">  <span class="keyword">FROM</span> Addresses A1, Addresses A2</span><br><span class="line"> <span class="keyword">WHERE</span> A1.family_id <span class="operator">=</span> A2.family_id</span><br><span class="line">   <span class="keyword">AND</span> A1.address <span class="operator">&lt;&gt;</span> A2.address ;</span><br></pre></td></tr></table></figure>
<h3 id="排序"><a class="markdownIt-Anchor" href="#排序">#</a> 排序</h3>
<img data-src="/2020/09/01/sql/selfjoin04.png" class="">
<img data-src="/2020/09/01/sql/selfjoin05.png" class="">
<p><strong>使用窗口函数</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 排序：使用窗口函数</span></span><br><span class="line"><span class="keyword">SELECT</span> name, price,</span><br><span class="line">       <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) <span class="keyword">AS</span> rank_1,</span><br><span class="line">       <span class="built_in">DENSE_RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">DESC</span>) <span class="keyword">AS</span> rank_2</span><br><span class="line">  <span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure>
<p><strong>使用子查询</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 排序：使用子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> P1.name,</span><br><span class="line">       P1.price,</span><br><span class="line">       (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(P2.price) <span class="keyword">FROM</span> Products P2 <span class="keyword">WHERE</span> P2.price <span class="operator">&gt;</span> P1.price) <span class="operator">+</span> <span class="number">1</span> <span class="keyword">AS</span> rank_1,</span><br><span class="line">       (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> P2.price) <span class="keyword">FROM</span> Products P2 <span class="keyword">WHERE</span> P2.price <span class="operator">&gt;</span> P1.price) <span class="operator">+</span> <span class="number">1</span> <span class="keyword">AS</span> rank_2</span><br><span class="line">  <span class="keyword">FROM</span> Products P1</span><br><span class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> rank_1, rank_2;</span><br></pre></td></tr></table></figure>
<p>子查询所做的，是计算出价格比自己高的记录的条数并将其作为自己的位次。为了便于理解，我们先考虑从 0 开始，对去重之后的 4 个价格 “{100, 80, 50, 30}” 进行排序的情况。首先是价格最高的 100，因为不存在比它高的价格，所以 COUNT 函数返回 0。接下来是价格第二高的 80，比它高的价格有一个 100，所以 COUNT 函数返回 1。同样地，价格为 50 的时候返回 2，为 30 的时候返回 3。这样，就生成了一个与每个价格对应的集合，如下表所示。</p>
<img data-src="/2020/09/01/sql/selfjoin06.png" class="">
<p>也就是说，这条 SQL 语句会生成这样几个 “同心圆状的” A 递归集合，然后数这些集合的元素个数。正如 “同心圆状” 这个词的字面意思那样，<br>
这几个集合之间存在如下包含关系。</p>
<img data-src="/2020/09/01/sql/selfjoin07.png" class="">
<p>实际上，“通过递归集合来定义数” 这个想法并不算新颖。有趣的是，它和集合论里沿用了 100 多年的自然数（包含 0）的递归定义（recursive<br>
definition）在思想上不谋而合 。研究这种思想的学者形成了几个流派，其中和这道例题的思路类型相同的是计算机之父、数学家冯・诺依曼提出<br>
的想法。冯・诺依曼首先将空集定义为 0，然后按照下面的规则定义了全体自然数。<br>
0 = φ<br>
1 = {0}<br>
2 = {0, 1}<br>
3 = {0, 1, 2}<br>
·<br>
·<br>
定义完 0 之后，用 0 来定义 1，然后用 0 和 1 来定义 2，再用 0、 1 和 2 来定义 3…… 以此类推。这种做法与上面例题里的集合 S0 ～ S3 在<br>
生成方法和结构上都是一样的（正是为了便于比较，例题里的位次才从 0 开始）。这道题很好地直接结合了 SQL 和集合论，而联系二者的正是<br>
自连接。</p>
<p><strong>使用自连接</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> P1.name,</span><br><span class="line">       <span class="built_in">MAX</span>(P1.price) <span class="keyword">AS</span> price,</span><br><span class="line">       <span class="built_in">COUNT</span>(P2.name) <span class="operator">+</span> <span class="number">1</span> <span class="keyword">AS</span> rank_1</span><br><span class="line">  <span class="keyword">FROM</span> Products P1 <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Products P2</span><br><span class="line">    <span class="keyword">ON</span> P1.price <span class="operator">&lt;</span> P2.price</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> P1.name</span><br><span class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> rank_1;</span><br></pre></td></tr></table></figure>
<p>去掉这条 SQL 语句里的聚合并展开成下面这样，就可以更清楚地看出同心圆状的包含关系（为了看得更清楚，我们从表中去掉价格重复的行，<br>
只留下橘子、西瓜、葡萄和柠檬这 4 行）。</p>
<img data-src="/2020/09/01/sql/selfjoin08.png" class="">
<p>使用内连接 第 1 名 “橘子” 竟然从结果里消失了。没有比橘子价格更高的水果，所以它被连接条件 P1.price &lt; P2.price 排除掉了。外连接就是这样一个用于将第 1 名也存储在结果里的小技巧 。</p>
<img data-src="/2020/09/01/sql/selfjoin09.png" class="">
<h2 id="三值逻辑和-null"><a class="markdownIt-Anchor" href="#三值逻辑和-null">#</a> 三值逻辑和 NULL</h2>
<p>总之，数据库里只要存在一个 NULL，查询的结果就可能不正确。而且，一般没有办法确定具体是哪个查询返回了不正确的结果，所以所有的结果看起来都很可疑。没有谁能保证一定能从包含 NULL 的数据库里查询出正确的结果。要我说，这种情况着实令人束手无策。 —C.J. Date</p>
<h3 id="两种-null-三值逻辑还是四值逻辑"><a class="markdownIt-Anchor" href="#两种-null-三值逻辑还是四值逻辑">#</a> 两种 NULL、三值逻辑还是四值逻辑</h3>
<p>说到三值逻辑，笔者认为话题应该从 NULL 开始，因为 NULL 正是产生三值逻辑的 “元凶”。“两种 NULL” 这种说法大家可能会觉得很奇怪，因为 SQL 里只存在一种 NULL。然而在讨论 NULL 时，我们一般都会将它分成两种类型来思考。因此这里先来介绍一些基础知识，即两种 NULL 之间的区别。两 种 NULL 分 别 指 的 是 “ 未 知 ”（unknown） 和 “ 不 适 用 ”（notapplicable, inapplicable）。以 “不知道戴墨镜的人眼睛是什么颜色” 这种情况为例，这个人的眼睛肯定是有颜色的，但是如果他不摘掉眼镜，别人就不知道他的眼睛是什么颜色。这就叫作未知。而 “不知道冰箱的眼睛是什么颜色” 则属于 “不适用”。因为冰箱根本就没有眼睛，所以 “眼睛的颜色” 这一属性并不适用于冰箱。“冰箱的眼睛的颜色” 这种说法和 “圆的体积”“男性的分娩次数” 一样，都是没有意义的。平时，我们习惯了说 “不知道”，但是 “不知道” 也分很多种。“不适用” 这种情况下的 NULL，在语义上更接近于 “无意义”，而不是 “不确定”。这里总结一下：“未知” 指的是 “虽然现在不知道，但加上某些条件后就可以知道”；而 “不适用” 指的是 “无论怎么努力都无法知道”。</p>
<img data-src="/2020/09/01/sql/null01.png" class="">
<p>Codd 曾经认为应该严格地区分两种类型的 NULL，并提倡在关系数据库中使用四值逻辑 。不知道是幸运还是不幸（笔者认为肯定是幸运），他的这个想法并没有得到广泛支持，现在所有的 DBMS 都将两种类型的 NULL 归为了一类并采用了三值逻辑。但是他的这种分类方法本身还是有很多优点的，因此后来依然有很多学者支持。</p>
<h3 id="为什么必须写成is-null而不是-null"><a class="markdownIt-Anchor" href="#为什么必须写成is-null而不是-null">#</a> 为什么必须写成 “IS NULL”，而不是 “＝ NULL”</h3>
<p>对 NULL 使用比较谓词后得到的结果总是 unknown。而查询结果只会包含 WHERE 子句里的判断结果为 true 的行，不会包含判断结果为 false 和 unknown 的行。不只是等号，对 NULL 使用<br>
其他比较谓词，结果也都是一样的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 以下的式子都会被判为 unknown</span></span><br><span class="line"><span class="number">1</span> <span class="operator">=</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="number">2</span> <span class="operator">&gt;</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="number">3</span> <span class="operator">&lt;</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="number">4</span> <span class="operator">&lt;&gt;</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">NULL</span> <span class="operator">=</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>
<p>那么，为什么对 NULL 使用比较谓词后得到的结果永远不可能为真呢？这是因为， NULL 既不是值也不是变量。 NULL 只是一个表示 “没有值” 的标记，而比较谓词只适用于值。因此，对并非值的 NULL 使用比较谓词本来就是没有意义的 (“我们先从定义一个表示‘虽然丢失了，但却适用的值’的标记开始。我们把它叫作 A-Mark。这个标记在关系数据库里既不被当作值（value），也不被当作变量（variable）。”（E.F. Codd， TheRelational Model for DatabaseManagement ：Version 2, P.173）“关于 NULL 的很重要的一件事情是， NULL 并不是值。”（C.J. Date，An Intruction To Database System（6thedition） , P.619） )。“列的值为 NULL”“NULL 值” 这样的说法本身就是错误的。因为 NULL 不是值，所以不在定义域（domain）中。相反，如果有人认为 NULL 是值，那么笔者倒想请教一下：它是什么类型的值？关系数据库中存在的值必然属于某种类型，比如字符型或数值型等。所以，假如 NULL 是值，那么它就必须属于某种类型。</p>
<p>NULL 容易被认为是值的原因恐怕有两个。第一个是在 C 语言等编程语言里面， NULL 被定义为了一个常量（很多语言将其定义为了整数 0），这导致了人们的混淆。但是，其实 SQL 里的 NULL 和其他编程语言里的 NULL 是完全不同的东西。第二个原因是， IS NULL 这样的谓词是由两个单词构成的，所以人们容易把 IS 当作谓词，而把 NULL 当作值。特别是 SQL 里还有 IS TRUE、IS FALSE 这样的谓词，人们由此类推，从而这样认为也不是没有道理。但是正如讲解标准 SQL 的书里提醒人们注意的那样，我们应该把 IS NULL 看作是一个谓词。因此，如果可以的话，写成 IS_NULL 这样也许更合适 。</p>
<h3 id="unknown-第三个真值"><a class="markdownIt-Anchor" href="#unknown-第三个真值">#</a> unknown、第三个真值</h3>
<img data-src="/2020/09/01/sql/null02.png" class="">
<p>三个真值之间有下面这样的优先级顺序。</p>
<ul>
<li>AND 的情况： false ＞  unknown ＞  true</li>
<li>OR 的情况： true ＞  unknown ＞  false</li>
</ul>
<p>优先级高的真值会决定计算结果。例如 true AND unknown，因为 unknown 的优先级更高，所以结果是 unknown。而 true OR unknown 的话，因为 true 优先级更高，所以结果是 true。记住这个顺序后就能更方便地进行三值逻辑运算了。特别需要记住的是，当 AND 运算中包含 unknown 时，结果肯定不会是 true（反之，如果 AND 运算结果为 true，则参与运算的双方必须都为 true）。</p>
<p>问题：假设 a = 2, b = 5, c = NULL，此时下面这些式子的真值是什么？<br>
1. a &lt; b AND b &gt; c<br>
2. a &gt; b OR b &lt; c<br>
3. a &lt; b OR b &lt; c<br>
4. NOT (b &lt;&gt; c)</p>
<p>答案：unknown； 2. unknown； 3. true； 4. unknown</p>
<h3 id="比较谓词和-null1-排中律不成立"><a class="markdownIt-Anchor" href="#比较谓词和-null1-排中律不成立">#</a> 比较谓词和 NULL (1) ：排中律不成立</h3>
<img data-src="/2020/09/01/sql/null03.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询年龄是 20 岁或者不是 20 岁的学生</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Students</span><br><span class="line"> <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">20</span></span><br><span class="line">    <span class="keyword">OR</span> age <span class="operator">&lt;&gt;</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1. 约翰年龄是 NULL（未知的 NULL ！</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Students</span><br><span class="line"> <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="keyword">NULL</span></span><br><span class="line">   <span class="keyword">OR</span> age <span class="operator">&lt;&gt;</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 对 NULL 使用比较谓词后，结果为 unknown</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Students</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="literal">unknown</span></span><br><span class="line">    <span class="keyword">OR</span> <span class="literal">unknown</span>;</span><br><span class="line"><span class="comment">-- 3． unknown OR unknown 的结果是 unknown（不为 true, 约翰不会被查询出来）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Students</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="literal">unknown</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加第 3 个条件 ：年龄是 20 岁，或者不是 20 岁，或者年龄未知</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Students</span><br><span class="line"> <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">20</span></span><br><span class="line">    <span class="keyword">OR</span> age <span class="operator">&lt;&gt;</span> <span class="number">20</span></span><br><span class="line">    <span class="keyword">OR</span> age <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
<h3 id="比较谓词和-null2-case-表达式和-null"><a class="markdownIt-Anchor" href="#比较谓词和-null2-case-表达式和-null">#</a> 比较谓词和 NULL (2) ：CASE 表达式和 NULL</h3>
<p>这个 CASE 表达式一定不会返回 ×。这是因为，第二个 WHEN 子句是 col_1 = NULL 的缩写形式。正如大家所知，这个式子的真值永远是 unknown。而且 CASE 表达式的判断方法与 WHERE 子句一样，只认可真值为 true 的条件。 需要将 WHEN NULL 修改为 WHEN IS NULL。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--col_1 为 1 时返回○、为 NULL 时返回 × 的 CASE 表达式？</span></span><br><span class="line"><span class="keyword">CASE</span> col_1</span><br><span class="line">	<span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span> <span class="string">&#x27;○&#x27;</span></span><br><span class="line">    <span class="keyword">WHEN</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span> <span class="string">&#x27;×&#x27;</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<h3 id="not-in-和-not-exists-不是等价的"><a class="markdownIt-Anchor" href="#not-in-和-not-exists-不是等价的">#</a> NOT IN 和 NOT EXISTS 不是等价的</h3>
<p>查询 “与 B 班住在东京的学生年龄不同的 A 班学生”</p>
<img data-src="/2020/09/01/sql/null04.png" class="">
<img data-src="/2020/09/01/sql/null05.png" class="">
<p><strong>NOT IN</strong></p>
<p>使用 NOT IN 结果是空，查询不到任何数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询与 B 班住在东京的学生年龄不同的 A 班学生的 SQL 语句？</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"> <span class="keyword">FROM</span> Class_A</span><br><span class="line"><span class="keyword">WHERE</span> age <span class="keyword">NOT</span> <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> age</span><br><span class="line">                     <span class="keyword">FROM</span> Class_B</span><br><span class="line">                    <span class="keyword">WHERE</span> city <span class="operator">=</span> <span class="string">&#x27;东京&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">--1. 执行子查询，获取年龄列表</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Class_A</span><br><span class="line"> <span class="keyword">WHERE</span> age <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="number">22</span>, <span class="number">23</span>, <span class="keyword">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--2. 用 NOT 和 IN 等价改写 NOT IN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Class_A</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="keyword">NOT</span> age <span class="keyword">IN</span> (<span class="number">22</span>, <span class="number">23</span>, <span class="keyword">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--3. 用 OR 等价改写谓词 IN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Class_A</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="keyword">NOT</span> ( (age <span class="operator">=</span> <span class="number">22</span>) <span class="keyword">OR</span> (age <span class="operator">=</span> <span class="number">23</span>) <span class="keyword">OR</span> (age <span class="operator">=</span> <span class="keyword">NULL</span>) );</span><br><span class="line"></span><br><span class="line"><span class="comment">--4. 使用德 · 摩根定律等价改写</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Class_A</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="keyword">NOT</span> (age <span class="operator">=</span> <span class="number">22</span>) <span class="keyword">AND</span> <span class="keyword">NOT</span>(age <span class="operator">=</span> <span class="number">23</span>) <span class="keyword">AND</span> <span class="keyword">NOT</span> (age <span class="operator">=</span> <span class="keyword">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--5. 用 &lt;&gt; 等价改写 NOT 和 =</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Class_A</span><br><span class="line"> <span class="keyword">WHERE</span> (age <span class="operator">&lt;&gt;</span> <span class="number">22</span>) <span class="keyword">AND</span> (age <span class="operator">&lt;&gt;</span> <span class="number">23</span>) <span class="keyword">AND</span> (age <span class="operator">&lt;&gt;</span> <span class="keyword">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--6. 对 NULL 使用 &lt;&gt; 后，结果为 unknown</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Class_A</span><br><span class="line"> <span class="keyword">WHERE</span> (age <span class="operator">&lt;&gt;</span> <span class="number">22</span>) <span class="keyword">AND</span> (age <span class="operator">&lt;&gt;</span> <span class="number">23</span>) <span class="keyword">AND</span> <span class="literal">unknown</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--7．如果 AND 运算里包含 unknown，则结果不为 true</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> Class_A</span><br><span class="line"><span class="keyword">WHERE</span> <span class="literal">false</span> 或 <span class="literal">unknown</span>;</span><br></pre></td></tr></table></figure>
<p>为了得到正确的结果，我们需要使用 EXISTS 谓词 。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 正确的 SQL 语句 ：拉里和伯杰将被查询到</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Class_A A</span><br><span class="line">  <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ( <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">                       <span class="keyword">FROM</span> Class_B B</span><br><span class="line">                      <span class="keyword">WHERE</span> A.age <span class="operator">=</span> B.age</span><br><span class="line">                        <span class="keyword">AND</span> B.city <span class="operator">=</span> <span class="string">&#x27;东京&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">--1. 在子查询里和 NULL 进行比较运算</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Class_A A</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ( <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">                      <span class="keyword">FROM</span> Class_B B</span><br><span class="line">                     <span class="keyword">WHERE</span> A.age <span class="operator">=</span> <span class="keyword">NULL</span></span><br><span class="line">                       <span class="keyword">AND</span> B.city <span class="operator">=</span> <span class="string">&#x27;东京&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">--2. 对 NULL 使用“=”后，结果为 unknown</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Class_A A</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ( <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">                      <span class="keyword">FROM</span> Class_B B</span><br><span class="line">                     <span class="keyword">WHERE</span> <span class="literal">unknown</span></span><br><span class="line">                       <span class="keyword">AND</span> B.city <span class="operator">=</span> <span class="string">&#x27;东京&#x27;</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">--3. 如果 AND 运算里包含 unknown，结果不会是 true</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Class_A A</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> ( <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">                      <span class="keyword">FROM</span> Class_B B</span><br><span class="line">                     <span class="keyword">WHERE</span> <span class="literal">false</span> 或 <span class="literal">unknown</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--4. 子查询没有返回结果，因此相反地， NOT EXISTS 为 true</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Class_A A</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h3 id="限定谓词和-null"><a class="markdownIt-Anchor" href="#限定谓词和-null">#</a> 限定谓词和 NULL</h3>
<p>SQL 里有 ALL 和 ANY 两个限定谓词。因为 ANY 与 IN 是等价的，所以<br>
我们不经常使用 ANY。</p>
<img data-src="/2020/09/01/sql/null07.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询比 B 班住在东京的所有学生年龄都小的 A 班学生</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Class_A</span><br><span class="line"> <span class="keyword">WHERE</span> age <span class="operator">&lt;</span> <span class="keyword">ALL</span> ( <span class="keyword">SELECT</span> age</span><br><span class="line">                     <span class="keyword">FROM</span> Class_B</span><br><span class="line">                    <span class="keyword">WHERE</span> city <span class="operator">=</span> <span class="string">&#x27;东京&#x27;</span> );</span><br><span class="line"></span><br><span class="line">name  age  city</span><br><span class="line"><span class="comment">----- ---- ----</span></span><br><span class="line">拉里   <span class="number">19</span>  埼 玉</span><br></pre></td></tr></table></figure>
<p>如果山田年龄不详，就会有问题了。凭直觉来说，此时查询到的可能是比 22 岁的齐藤年龄小的拉里和伯杰。然而，这条 SQL 语句的执行结果还是空。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1. 执行子查询获取年龄列表</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Class_A</span><br><span class="line"> <span class="keyword">WHERE</span> age <span class="operator">&lt;</span> <span class="keyword">ALL</span> ( <span class="number">22</span>, <span class="number">23</span>, <span class="keyword">NULL</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">--2. 将 ALL 谓词等价改写为 AND</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Class_A</span><br><span class="line"> <span class="keyword">WHERE</span> (age <span class="operator">&lt;</span> <span class="number">22</span>) <span class="keyword">AND</span> (age <span class="operator">&lt;</span> <span class="number">23</span>) <span class="keyword">AND</span> (age <span class="operator">&lt;</span> <span class="keyword">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--3. 对 NULL 使用“&lt;”后，结果变为 unknown</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Class_A</span><br><span class="line"> <span class="keyword">WHERE</span> (age <span class="operator">&lt;</span> <span class="number">22</span>) <span class="keyword">AND</span> (age <span class="operator">&lt;</span> <span class="number">23</span>) <span class="keyword">AND</span> <span class="literal">unknown</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--4. 如果 AND 运算里包含 unknown，则结果不为 true</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Class_A</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="literal">false</span> 或 <span class="literal">unknown</span>;</span><br></pre></td></tr></table></figure>
<h3 id="限定谓词和极值函数不是等价的"><a class="markdownIt-Anchor" href="#限定谓词和极值函数不是等价的">#</a> 限定谓词和极值函数不是等价的</h3>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询比 B 班住在东京的年龄最小的学生还要小的 A 班学生</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Class_A</span><br><span class="line"> <span class="keyword">WHERE</span> age <span class="operator">&lt;</span> ( <span class="keyword">SELECT</span> <span class="built_in">MIN</span>(age)</span><br><span class="line">                 <span class="keyword">FROM</span> Class_B</span><br><span class="line">                <span class="keyword">WHERE</span> city <span class="operator">=</span> <span class="string">&#x27;东京&#x27;</span> );</span><br><span class="line"></span><br><span class="line">name  age  city</span><br><span class="line"><span class="comment">----- ---- ----</span></span><br><span class="line">拉里   <span class="number">19</span>   埼 玉</span><br><span class="line">伯杰   <span class="number">21</span>   千 叶</span><br></pre></td></tr></table></figure>
<p>即使山田的年龄无法确定，这段代码也能查询到拉里和伯杰两人。这是因为， 极值函数在统计时会把为 NULL 的数据排除掉。使用极值函数能使 Class_B 这张表里看起来就像不存在 NULL 一样。</p>
<p>ALL 谓词和极值函数表达的命题含义分别如下所示。</p>
<ul>
<li>ALL 谓词：他的年龄比在东京住的所有学生都小 — Q1</li>
<li>极值函数：他的年龄比在东京住的年龄最小的学生还要小 — Q2</li>
</ul>
<p>在现实世界中，这两个命题是一个意思。但是，正如我们通过前面的例题看到的那样，表里存在 NULL 时它们是不等价的。其实还有一种情况下它们也是不等价的，大家知道是什么吗？ 答案是，谓词（或者函数）的输入为空集的情况。 例如 Class_B 这张表为如下所示的情况。</p>
<img data-src="/2020/09/01/sql/null06.png" class="">
<p>如上表所示， B 班里没有学生住在东京。这时，使用 ALL 谓词的 SQL 语句会查询到 A 班的所有学生。然而，用极值函数查询时一行数据都查询不到。这是因为，极值函数在输入为空表（空集）时会返回 NULL。因此，使用极值函数的 SQL 语句会像下面这样一步步被执行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1. 极值函数返回 NULL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Class_A</span><br><span class="line"> <span class="keyword">WHERE</span> age <span class="operator">&lt;</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--2. 对 NULL 使用“&lt;”后结果为 unknown</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Class_A</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="literal">unknown</span>;</span><br></pre></td></tr></table></figure>
<h3 id="聚合函数和-null"><a class="markdownIt-Anchor" href="#聚合函数和-null">#</a> 聚合函数和 NULL</h3>
<p>实际上，当输入为空表时返回 NULL 的不只是极值函数， COUNT 以外的聚合函数也是如此。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询比住在东京的学生的平均年龄还要小的 A 班学生的 SQL 语句？</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Class_A</span><br><span class="line"> <span class="keyword">WHERE</span> age <span class="operator">&lt;</span> ( <span class="keyword">SELECT</span> <span class="built_in">AVG</span>(age)</span><br><span class="line">                 <span class="keyword">FROM</span> Class_B</span><br><span class="line">                <span class="keyword">WHERE</span> city <span class="operator">=</span> <span class="string">&#x27;东京&#x27;</span> );</span><br></pre></td></tr></table></figure>
<p>没有住在东京的学生时， AVG 函数返回 NULL。因此，外侧的 WHERE 子句永远是 unknown，也就查询不到行。使用 SUM 也是一样。这种情况的解决方法只有两种：要么把 NULL 改写成具体值，要么闭上眼睛接受 NULL。但是如果某列有 NOT NULL 约束，而我们需要往其中插入平均值或汇总值，那么就只能选择将 NULL 改写成具体值了。</p>
<h2 id="having-子句的力量"><a class="markdownIt-Anchor" href="#having-子句的力量">#</a> HAVING 子句的力量</h2>
<h3 id="寻找缺失的编号"><a class="markdownIt-Anchor" href="#寻找缺失的编号">#</a> 寻找缺失的编号</h3>
<img data-src="/2020/09/01/sql/having01.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 如果有查询结果，说明存在缺失的编号</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;存在缺失的编号&#x27;</span> <span class="keyword">AS</span> gap</span><br><span class="line">  <span class="keyword">FROM</span>  SeqTbl</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&lt;&gt;</span> <span class="built_in">MAX</span>(seq);</span><br><span class="line"></span><br><span class="line">gap</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line"><span class="string">&#x27;存在缺失的编号&#x27;</span></span><br></pre></td></tr></table></figure>
<p>如果用集合论的语言来描述，那么这个查询所做的事情就是检查自然数集合和 SeqTbl 集合之间是否存在一一映射（又称双射）。换句话说，就是像下图展示的那样， MAX (seq) 计算的，是由 “到 seq 最大值为止的没有缺失的连续编号（即自然数）” 构成的集合的元素个数，而 COUNT (*) 计算的是 SeqTbl 这张表里实际的元素个数（即行数）。</p>
<img data-src="/2020/09/01/sql/having02.png" class="">
<p>查询缺失编号的最小值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询缺失编号的最小值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(seq <span class="operator">+</span> <span class="number">1</span>) <span class="keyword">AS</span> gap</span><br><span class="line">  <span class="keyword">FROM</span> SeqTbl</span><br><span class="line">  <span class="keyword">WHERE</span> (seq<span class="operator">+</span> <span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> seq <span class="keyword">FROM</span> SeqTbl);</span><br><span class="line"></span><br><span class="line">gap</span><br><span class="line"><span class="comment">---</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>上面展示了通过 SQL 语句查询缺失编号的最基本的思路，然而这个查询还不够周全，并不能涵盖所有情况。例如，如果表 SeqTbl 里没有编号 1，那么缺失编号的最小值应该是 1，但是这两条 SQL 语句都不能得出正确的结果。</p>
<h3 id="用-having-子句进行子查询-求众数"><a class="markdownIt-Anchor" href="#用-having-子句进行子查询-求众数">#</a> 用 HAVING 子句进行子查询 ：求众数</h3>
<img data-src="/2020/09/01/sql/having03.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 求众数的SQL语句（1）：使用谓词</span></span><br><span class="line"><span class="keyword">SELECT</span> income, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> cnt</span><br><span class="line">  <span class="keyword">FROM</span> Graduates</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> income</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span> <span class="keyword">ALL</span> ( <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line">						   <span class="keyword">FROM</span> Graduates</span><br><span class="line">					   <span class="keyword">GROUP</span> <span class="keyword">BY</span> income);</span><br><span class="line"></span><br><span class="line">income cnt</span><br><span class="line"><span class="comment">------ ---</span></span><br><span class="line"><span class="number">10000</span>  <span class="number">3</span></span><br><span class="line"><span class="number">20000</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>GROUP BY 子句的作用是根据最初的集合生成若干个子集。因此，将收入（income）作为 GROUP BY 的列时，将得到 S1 ～ S5 这样 5 个子集。这几个子集里，元素数最多的是 S3 和 S5，都是 3 个元素，因此查询的结果也是这 2 个集合。</p>
<img data-src="/2020/09/01/sql/having04.png" class="">
<p>ALL 谓词用于 NULL 或空集时会出现问题，可以用极值函数来代替。这里要求的是元素数最多的集合，因此可以用 MAX 函数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 求众数的SQL语句(2)：使用极值函数</span></span><br><span class="line"><span class="keyword">SELECT</span> income, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> cnt</span><br><span class="line">  <span class="keyword">FROM</span> Graduates</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> income</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;=</span>  ( <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(cnt)</span><br><span class="line">                        <span class="keyword">FROM</span> ( <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> cnt</span><br><span class="line">                                 <span class="keyword">FROM</span> Graduates</span><br><span class="line">                             <span class="keyword">GROUP</span> <span class="keyword">BY</span> income) TMP) ;</span><br></pre></td></tr></table></figure>
<h3 id="用-having-子句进行自连接-求中位数"><a class="markdownIt-Anchor" href="#用-having-子句进行自连接-求中位数">#</a> 用 HAVING 子句进行自连接 ：求中位数</h3>
<p>将集合里的元素按照大小分为上半部分和下半部分两个子集，同时让这 2 个子集共同拥有集合正中间的元素。这样，共同部分的元素的平均值就是中位数，思路如下图所示。</p>
<img data-src="/2020/09/01/sql/having05.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 求中位数的SQL语句：在HAVING子句中使用非等值自连接</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(<span class="keyword">DISTINCT</span> income)</span><br><span class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> T1.income</span><br><span class="line">          <span class="keyword">FROM</span> Graduates T1, Graduates T2</span><br><span class="line">      <span class="keyword">GROUP</span> <span class="keyword">BY</span> T1.income</span><br><span class="line">               <span class="comment">-- S1的条件</span></span><br><span class="line">        <span class="keyword">HAVING</span> <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> T2.income <span class="operator">&gt;=</span> T1.income <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)</span><br><span class="line">                   <span class="operator">&gt;=</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">/</span> <span class="number">2</span></span><br><span class="line">               <span class="comment">-- S2的条件</span></span><br><span class="line">           <span class="keyword">AND</span> <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> T2.income <span class="operator">&lt;=</span> T1.income <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)</span><br><span class="line">                   <span class="operator">&gt;=</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">/</span> <span class="number">2</span> ) TMP;</span><br></pre></td></tr></table></figure>
<p>这条 SQL 语句的要点在于比较条件 <code>&gt;= COUNT(*)/2</code>  里的等号，这个等号是有意地加上的。加上等号并不是为了清晰地分开子集 S1 和 S2，而是为了让这 2 个子集拥有共同部分。如果去掉等号，将条件改成 <code>&gt;COUNT(*)/2</code> ，那么当元素个数为偶数时， S1 和 S2 就没有共同的元素了，也就无法求出中位数了。</p>
<h3 id="查询不包含-null-的集合"><a class="markdownIt-Anchor" href="#查询不包含-null-的集合">#</a> 查询不包含 NULL 的集合</h3>
<p>COUNT 函数的使用方法有  <code>COUNT(*) 和 COUNT( 列名 ) </code> 两种，它们的区<br>
别有两个：第一个是性能上的区别；第二个是 <code> COUNT(*)</code>  可以用于 NULL，<br>
而  <code>COUNT( 列名 )</code>  与其他聚合函数一样，要先排除掉 NULL 的行再进行统计。第二个区别也可以这么理解：  <code>COUNT(*) </code> 查询的是所有行的数目，而<br>
 <code>COUNT( 列名 )</code>  查询的则不一定是。<br>
对一张全是 NULL 的表 NullTbl 执行 SELECT 子句就能清楚地知道两<br>
者的区别了。</p>
<img data-src="/2020/09/01/sql/having06.png" class="">
<p>如下一张存储了学生提交报告的日期的表 Students 。学生提交报告后，“提交日期” 列会被写入日期，而提交之前是 NULL。现在我们需要从这张表里找出哪些学院的学生全部都提交了报告（即理学院、经济学院）。</p>
<img data-src="/2020/09/01/sql/having07.png" class="">
<p>以 “学院” 为 GROUP BY 的列生成下面这样的子集。</p>
<img data-src="/2020/09/01/sql/having08.png" class="">
<p>这样生成的 4 个子集里，我们想要的是 S1 和 S4。那么，这 2 个子集具备而其他子集不具备的特征是 <code>COUNT(*) 和 COUNT(sbmt_date) 结果一致</code> 。这是因为 S2 和 S3 这 2 个子集里存在 NULL。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询“提交日期”列内不包含NULL的学院(1)：使用COUNT函数</span></span><br><span class="line"><span class="keyword">SELECT</span> dpt</span><br><span class="line">  <span class="keyword">FROM</span> Students</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> dpt</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">=</span> <span class="built_in">COUNT</span>(sbmt_date);</span><br><span class="line"></span><br><span class="line">dpt</span><br><span class="line"><span class="comment">--------</span></span><br><span class="line">理学院</span><br><span class="line">经济学院</span><br></pre></td></tr></table></figure>
<p>使用 CASE 表达式也可以实现同样的功能，而且更加通用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询“提交日期”列内不包含NULL的学院(2)：使用CASE表达式</span></span><br><span class="line"><span class="keyword">SELECT</span> dpt</span><br><span class="line">  <span class="keyword">FROM</span> Students</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> dpt</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">=</span> <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sbmt_date <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">                           <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">                           <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到，使用 CASE 表达式时，将 “提交日期” 不是 NULL 的行标记为 1，将 “提交日期” 为 NULL 的行标记为 0。在这里， CASE 表达式的 作用相当于进行判断的函数，用来判断各个元素（= 行）是否属于满足了某种条件的集合。这样的函数我们称为特征函数（characteristic function），或者从定义了集合的角度来将它称为定义函数。</p>
<h3 id="用关系除法运算进行购物篮分析"><a class="markdownIt-Anchor" href="#用关系除法运算进行购物篮分析">#</a> 用关系除法运算进行购物篮分析</h3>
<p>如下是全国连锁折扣店的商品表 Items，以及各个店铺的库存管理表 ShopItems。</p>
<img data-src="/2020/09/01/sql/having09.png" class="">
<p>这次我们要查询的是囊括了表 Items 中所有商品的店铺。也就是说，要查询的是仙台店和东京店。大阪店没有啤酒，所以不是我们的目标。这个问题在实际工作中的原型是数据挖掘技术中的 “购物篮分析” (购物篮分析是市场分析领域常用的一种分析手段，用来发现 “经常被一起购买的商品” 具有的规律。有一个有名的例子：某家超市发现，虽然不知为什么，但啤酒和纸尿裤经常被一起购买也许是因为来买纸尿裤的爸爸都会想顺便买些啤酒回去，于是便将啤酒和纸尿裤摆在相邻的货架，从而提升了销售额。)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询啤酒、纸尿裤和自行车同时在库的店铺：正确的SQL语句</span></span><br><span class="line"><span class="keyword">SELECT</span> SI.shop</span><br><span class="line">  <span class="keyword">FROM</span> ShopItems SI, Items I</span><br><span class="line"> <span class="keyword">WHERE</span> SI.item <span class="operator">=</span> I.item</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> SI.shop</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(SI.item) <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(item) <span class="keyword">FROM</span> Items);</span><br><span class="line"></span><br><span class="line">shop</span><br><span class="line"><span class="comment">----</span></span><br><span class="line">仙台</span><br><span class="line">东京</span><br></pre></td></tr></table></figure>
<p>如果把 HAVING 子句改成 HAVING COUNT (SI.item) =COUNT (I.item)，结果就不对了。如果使用这个条件，仙台、东京、大阪这 3 个店铺都会被选中。这是因为，受到连接操作的影响， COUNT (I.item) 的值和表 Items 原本的行数不一样了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- COUNT(I.item)的值已经不一定是3了</span></span><br><span class="line"><span class="keyword">SELECT</span> SI.shop, <span class="built_in">COUNT</span>(SI.item), <span class="built_in">COUNT</span>(I.item)</span><br><span class="line">  <span class="keyword">FROM</span> ShopItems SI, Items I</span><br><span class="line"> <span class="keyword">WHERE</span> SI.item <span class="operator">=</span> I.item</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> SI.shop;</span><br><span class="line"></span><br><span class="line">shop  <span class="built_in">COUNT</span>(SI.item)  <span class="built_in">COUNT</span>(I.item)</span><br><span class="line"><span class="comment">----- --------------- --------------</span></span><br><span class="line">仙台   <span class="number">3</span>               <span class="number">3</span></span><br><span class="line">东京   <span class="number">3</span>               <span class="number">3</span></span><br><span class="line">大阪   <span class="number">2</span>               <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这里也可以使用外连接</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用外连接进行关系除法运算：差集的应用</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> shop</span><br><span class="line">  <span class="keyword">FROM</span> ShopItems SI1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">      (<span class="keyword">SELECT</span> I.item</span><br><span class="line">         <span class="keyword">FROM</span> Items I <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> ShopItems SI2</span><br><span class="line">           <span class="keyword">ON</span> SI1.shop <span class="operator">=</span> SI2.shop</span><br><span class="line">          <span class="keyword">AND</span> I.item   <span class="operator">=</span> SI2.item</span><br><span class="line">        <span class="keyword">WHERE</span> SI2.item <span class="keyword">IS</span> <span class="keyword">NULL</span>) ;</span><br></pre></td></tr></table></figure>
<p>接下来我们把条件变一下，看看如何排除掉仙台店（仙台店的仓库中存在 “窗帘”，但商品表里没有 “窗帘”），让结果里只出现东京店。这类问题被称为 “精确关系除法”（exact relational division），即只选择没有剩余商品的店铺（与此相对，前一个问题被称为 “带余除法”（division with a remainder））。解决这个问题我们需要使用外连接。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 精确关系除法运算：使用外连接和COUNT函数</span></span><br><span class="line">  <span class="keyword">SELECT</span> SI.shop</span><br><span class="line">    <span class="keyword">FROM</span> ShopItems <span class="keyword">AS</span> SI <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Items <span class="keyword">AS</span> I</span><br><span class="line">      <span class="keyword">ON</span> SI.item<span class="operator">=</span>I.item</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> SI.shop</span><br><span class="line">  <span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(SI.item) <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(item) <span class="keyword">FROM</span> Items)   <span class="comment">-- 条件1</span></span><br><span class="line">     <span class="keyword">AND</span> <span class="built_in">COUNT</span>(I.item)  <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(item) <span class="keyword">FROM</span> Items);  <span class="comment">-- 条件2</span></span><br><span class="line"></span><br><span class="line">shop</span><br><span class="line"><span class="comment">----</span></span><br><span class="line">东京</span><br></pre></td></tr></table></figure>
<p>以表 ShopItems 为主表进行外连接操作后，因为表 Items 里不存在窗帘和电视，所以连接后相应行的 “I.item” 列是 NULL。然后，我们就可以使用之前用到的检查学生提交报告日期的 COUNT 函数的技巧了。条件 1 会排除掉 COUNT (SI.item) = 4 的仙台店，条件 2 会排除掉 COUNT (I.item)= 2 的大阪店（NULL 不会被计数）。</p>
<img data-src="/2020/09/01/sql/having10.png" class="">
<h3 id="关系除法运算"><a class="markdownIt-Anchor" href="#关系除法运算">#</a> 关系除法运算</h3>
<p>如果模仿数值运算的写法来写，可以写作 ShopItems ÷ Items。至于为什么称它为除法运算，我们可以从除法运算的逆运算 —— 乘法运算的角度来理解一下。除法运算和乘法运算之间有这样的关系：除法运算的商和除数的乘积等于被除数。</p>
<img data-src="/2020/09/01/sql/having11.png" class="">
<p>在 SQL 里，交叉连接相当于乘法运算。把商和除数（表 Items）交叉连接，然后求笛卡儿积，就能得到表 ShopItems 的子集（不一定是完整的表 ShopItems），也就是被除数。这就是 “除法运算” 这一名称的由来。</p>
<p>关系除法运算是关系代数中知名度最低的运算。不过，在实际工作中用到的机会并不少。像文中例题这样，应用场景很多（很多时候都是不经意间就使用了）。关系除法运算也是 Codd 最初定义的 8 种关系运算中的一种，也算正<br>
宗的关系运算。</p>
<h3 id="各队全体点名"><a class="markdownIt-Anchor" href="#各队全体点名">#</a> 各队，全体点名</h3>
<p>查出现在可以出勤的队伍。可以出勤即队伍里所有队员都处于 “待命” 状态。</p>
<img data-src="/2020/09/01/sql/having12.png" class="">
<p>用谓词表达全称量化命题，“所有队员都处于待命状态”＝“不存在不处于待命状态的队员”</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用谓词表达全称量化命题 */</span></span><br><span class="line"><span class="keyword">SELECT</span> team_id, <span class="keyword">member</span></span><br><span class="line">  <span class="keyword">FROM</span> Teams T1</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">        (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">           <span class="keyword">FROM</span> Teams T2</span><br><span class="line">          <span class="keyword">WHERE</span> T1.team_id <span class="operator">=</span> T2.team_id</span><br><span class="line">            <span class="keyword">AND</span> status <span class="operator">&lt;&gt;</span> <span class="string">&#x27;待命&#x27;</span> );</span><br><span class="line"></span><br><span class="line">team_id <span class="keyword">member</span></span><br><span class="line"><span class="comment">------- ------</span></span><br><span class="line"><span class="number">3</span>       简</span><br><span class="line"><span class="number">3</span>       哈特</span><br><span class="line"><span class="number">3</span>       迪克</span><br><span class="line"><span class="number">4</span>       贝斯</span><br></pre></td></tr></table></figure>
<p>用集合表达全称量化命题</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用集合表达全称量化命题（1） */</span></span><br><span class="line"><span class="keyword">SELECT</span> team_id</span><br><span class="line">  <span class="keyword">FROM</span> Teams</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> team_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">=</span> <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> status <span class="operator">=</span> <span class="string">&#x27;待命&#x27;</span></span><br><span class="line">                           <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">                           <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>);</span><br><span class="line">team_id</span><br><span class="line"><span class="comment">-------</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>使用 GROUP BY 子句将 Teams 集合以队伍为单位划分成几个子集。</p>
<img data-src="/2020/09/01/sql/having13.png" class="">
<p>目标集合是 S3 和 S4，那么只有这两个集合拥有而其他集合没有的特征是什么呢？答案是，处于 “待命” 状态的数据行数与集合中数据总行数相等。这个条件可以用 CASE 表达式来表达，状态为 “待命” 的情况下返回 1，其他情况下返回 0。也许大家已经注意到了，这里使用的是特征函数的方法。<br>
根据是否满足条件分别为表里的每一行数据加上标记 1 或 0，这样更好理解一些。</p>
<img data-src="/2020/09/01/sql/having14.png" class="">
<p>HAVING 子句中的条件还可以像下面这样写 。某个集合中，如果元素最大值和最小值相等，那么这个集合中肯定只有一种值。因为如果包含多种值，最大值和最小值肯定不会相等。极值函数可以使用参数字段的索引，所以这种写法性能更好 。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 用集合表达全称量化命题（2） */</span></span><br><span class="line"><span class="keyword">SELECT</span> team_id</span><br><span class="line">  <span class="keyword">FROM</span> Teams</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> team_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MAX</span>(status) <span class="operator">=</span> <span class="string">&#x27;待命&#x27;</span></span><br><span class="line">   <span class="keyword">AND</span> <span class="built_in">MIN</span>(status) <span class="operator">=</span> <span class="string">&#x27;待命&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>当然也可以把条件放在 SELECT 子句里，以列表形式显示出各个队伍是否所有队员都在待命，这样的结果更加一目了然。 需要注意的是，条件移到 SELECT 子句后，查询可能就不会被数据库优化了，所以性能上相比 HAVING 子句的写法会差一些。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 列表显示各个队伍是否所有队员都在待命 */</span></span><br><span class="line"><span class="keyword">SELECT</span> team_id,</span><br><span class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="built_in">MAX</span>(status) <span class="operator">=</span> <span class="string">&#x27;待命&#x27;</span> <span class="keyword">AND</span> <span class="built_in">MIN</span>(status) <span class="operator">=</span> <span class="string">&#x27;待命&#x27;</span></span><br><span class="line">            <span class="keyword">THEN</span> <span class="string">&#x27;全都在待命&#x27;</span></span><br><span class="line">            <span class="keyword">ELSE</span> <span class="string">&#x27;队长！人手不够&#x27;</span> <span class="keyword">END</span> <span class="keyword">AS</span> status</span><br><span class="line">  <span class="keyword">FROM</span> Teams</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> team_id;</span><br><span class="line"></span><br><span class="line">team_id status</span><br><span class="line"><span class="comment">------- --------------------------</span></span><br><span class="line"><span class="number">1</span>       队长！人手不够</span><br><span class="line"><span class="number">2</span>       队长！人手不够</span><br><span class="line"><span class="number">3</span>       全都在待命</span><br><span class="line"><span class="number">4</span>       全都在待命</span><br><span class="line"><span class="number">5</span>       队长！人手不够</span><br></pre></td></tr></table></figure>
<h3 id="单重集合与多重集合"><a class="markdownIt-Anchor" href="#单重集合与多重集合">#</a> 单重集合与多重集合</h3>
<p>查出存在重复材料的生产地。</p>
<img data-src="/2020/09/01/sql/having15.png" class="">
<p>从表中我们可以看到，一个生产地对应着多条数据，因此 “生产地” 这一实体在表中是以集合的形式，而不是以元素的形式存在的。处理这种情况的基本方法就是使用 GROUP BY 子句将集合划分为若干个子集，像下面这样。</p>
<img data-src="/2020/09/01/sql/having16.png" class="">
<p>目标集合是锌重复的东京，以及钛和钢重复的名古屋。那么这两个集合满足而其他集合不满足的条件是什么呢？这个条件是，“排除掉重复元素后和排除掉重复元素前元素个数不相同”。这是因为，如果不存在重复的元素，不管是否加上 DISTINCT 可选项，COUNT 的结果都是相同的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 选中材料存在重复的生产地 */</span></span><br><span class="line"><span class="keyword">SELECT</span> center</span><br><span class="line">  <span class="keyword">FROM</span> Materials</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> center</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(material) <span class="operator">&lt;&gt;</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> material);</span><br><span class="line"></span><br><span class="line">center</span><br><span class="line"><span class="comment">------</span></span><br><span class="line">东京</span><br><span class="line">名古屋</span><br></pre></td></tr></table></figure>
<p>这个问题也可以通过将 HAVING 改写成 EXISTS 的方式来解决。用 EXISTS 改写后的 SQL 语句也能够查出重复的具体是哪一种材料，而且使用 EXISTS 后性能也很好。相反地，如果想要查出不存在重复材料的生产地有哪些，只需要把 EXISTS 改写为 NOT EXISTS 就可以了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 存在重复的集合：使用EXISTS */</span></span><br><span class="line"><span class="keyword">SELECT</span> center, material</span><br><span class="line">  <span class="keyword">FROM</span> Materials M1</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">       (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">          <span class="keyword">FROM</span> Materials M2</span><br><span class="line">         <span class="keyword">WHERE</span> M1.center <span class="operator">=</span> M2.center</span><br><span class="line">           <span class="keyword">AND</span> M1.receive_date <span class="operator">&lt;&gt;</span> M2.receive_date</span><br><span class="line">           <span class="keyword">AND</span> M1.material <span class="operator">=</span> M2.material);</span><br><span class="line"></span><br><span class="line">center  material</span><br><span class="line"><span class="comment">------- ---------</span></span><br><span class="line">东京     锌</span><br><span class="line">东京     锌</span><br><span class="line">名古屋   钛</span><br><span class="line">名古屋   钢</span><br><span class="line">名古屋   钢</span><br><span class="line">名古屋   钛</span><br></pre></td></tr></table></figure>
<h3 id="寻找缺失的编号-升级版"><a class="markdownIt-Anchor" href="#寻找缺失的编号-升级版">#</a> 寻找缺失的编号 ： 升级版</h3>
<img data-src="/2020/09/01/sql/having17.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 如果有查询结果，说明存在缺失的编号：只调查数列的连续性 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;存在缺失的编号&#x27;</span> <span class="keyword">AS</span> gap</span><br><span class="line">  <span class="keyword">FROM</span> SeqTbl</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&lt;&gt;</span> <span class="built_in">MAX</span>(seq) <span class="operator">-</span> <span class="built_in">MIN</span>(seq) <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不论是否存在缺失的编号都返回一行结果 */</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">               <span class="keyword">THEN</span> <span class="string">&#x27;表为空&#x27;</span></span><br><span class="line">            <span class="keyword">WHEN</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&lt;&gt;</span> <span class="built_in">MAX</span>(seq) <span class="operator">-</span> <span class="built_in">MIN</span>(seq) <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">               <span class="keyword">THEN</span> <span class="string">&#x27;存在缺失的编号&#x27;</span></span><br><span class="line">            <span class="keyword">ELSE</span> <span class="string">&#x27;连续&#x27;</span> <span class="keyword">END</span> <span class="keyword">AS</span> gap</span><br><span class="line">  <span class="keyword">FROM</span> SeqTbl;</span><br></pre></td></tr></table></figure>
<p>查找最小的缺失编号 。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 查找最小的缺失编号：表中没有1时返回1 */</span></span><br><span class="line"><span class="comment">-- Oracle: ORA-00937: not a single-group group function</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">=</span> <span class="number">0</span> <span class="keyword">OR</span> <span class="keyword">WHEN</span> <span class="built_in">MIN</span>(seq) <span class="operator">&gt;</span> <span class="number">1</span>    <span class="comment">/* 最小值不是1时→返回1 */</span></span><br><span class="line">            <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">ELSE</span> (<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(seq <span class="operator">+</span><span class="number">1</span>)  <span class="comment">/* 最小值是1时→返回最小的缺失编号 */</span></span><br><span class="line">                    <span class="keyword">FROM</span> SeqTbl S1</span><br><span class="line">                   <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">                        (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">                           <span class="keyword">FROM</span> SeqTbl S2</span><br><span class="line">                          <span class="keyword">WHERE</span> S2.seq <span class="operator">=</span> S1.seq <span class="operator">+</span> <span class="number">1</span>))</span><br><span class="line">             <span class="keyword">END</span> <span class="keyword">AS</span> min_gap</span><br><span class="line">  <span class="keyword">FROM</span> SeqTbl;</span><br></pre></td></tr></table></figure>
<h3 id="为集合设置详细的条件"><a class="markdownIt-Anchor" href="#为集合设置详细的条件">#</a> 为集合设置详细的条件</h3>
<img data-src="/2020/09/01/sql/having18.png" class="">
<p>查询出 75% 以上的学生分数都在 80 分以上的班级</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 75%以上的学生分数都在80分以上的班级 */</span></span><br><span class="line"><span class="keyword">SELECT</span> class</span><br><span class="line">  <span class="keyword">FROM</span> TestResults</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> class</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">*</span> <span class="number">0.75</span></span><br><span class="line">         <span class="operator">&lt;=</span> <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> score <span class="operator">&gt;=</span> <span class="number">80</span></span><br><span class="line">                     <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">                     <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) ;</span><br><span class="line"></span><br><span class="line">class</span><br><span class="line"><span class="comment">-------</span></span><br><span class="line">B</span><br></pre></td></tr></table></figure>
<p>查询出分数在 50 分以上的男生的人数比分数在 50 分以上的女生的人数多的班级</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 分数在50分以上的男生的人数比分数在50分以上的女生的人数多的班级 */</span></span><br><span class="line"><span class="keyword">SELECT</span> class</span><br><span class="line">  <span class="keyword">FROM</span> TestResults</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> class</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> score <span class="operator">&gt;=</span> <span class="number">50</span> <span class="keyword">AND</span> sex <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span></span><br><span class="line">                <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">                <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)</span><br><span class="line">       <span class="operator">&gt;</span> <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> score <span class="operator">&gt;=</span> <span class="number">50</span> <span class="keyword">AND</span> sex <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span></span><br><span class="line">                  <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">                  <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) ;</span><br><span class="line"></span><br><span class="line">class</span><br><span class="line"><span class="comment">-------</span></span><br><span class="line">B</span><br><span class="line">C</span><br></pre></td></tr></table></figure>
<p>查询出女生平均分比男生平均分高的班级</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 比较男生和女生平均分的SQL语句（1）：对空集使用AVG后返回0 */</span></span><br><span class="line"><span class="keyword">SELECT</span> class</span><br><span class="line">  <span class="keyword">FROM</span> TestResults</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> class</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span></span><br><span class="line">                <span class="keyword">THEN</span> score</span><br><span class="line">                <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)</span><br><span class="line">     <span class="operator">&lt;</span> <span class="built_in">AVG</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span></span><br><span class="line">                <span class="keyword">THEN</span> score</span><br><span class="line">                <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>) ;</span><br><span class="line"></span><br><span class="line">class</span><br><span class="line"><span class="comment">-------</span></span><br><span class="line">A</span><br><span class="line">D</span><br></pre></td></tr></table></figure>
<p>从表中的数据我们可以发现， D 班全是女生。在上面的解答中，用于判断男生的 CASE 表达式里分支 ELSE 0 生效了，于是男生的平均分就成了 0 分。对于女生的平均分约为 33.3 的 D 班，条件 0 &lt;33.3 也成立，所以 D 班也出现在查询结果里了。这种处理方法看起来好像也没什么问题。但是，如果学号 013 的学生分数刚好也是 0 分，结果会怎么样呢？这种情况下，女生的平均分会变为 0 分，所以 D 班不会被查询出来。男生和女生的平均分都是 0，但是两个 0 的意义完全不同。女生的平均分是正常计算出来的，而男生的平均分本来就无法计算，只是强行赋值为 0 而已。真正合理的处理方法是，保证对空集求平均的结果是 “未定义”，就像除以 0 的结果是未定义一样。根据标准 SQL 的定义，对空集使用 AVG 函数时，结果会返回 NULL （用 NULL 来代替未定义这种做法本身也有问题，但是在这里我们不深究)。这回 D 班男生的平均分是 NULL。因此不管女生的平均分多少， D 班都会被排除在查询结果之外。这种处理方法和 AVG 函数的处理逻辑也是一致的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 比较男生和女生平均分的SQL语句（2）：对空集求平均值后返回NULL */</span></span><br><span class="line"><span class="keyword">SELECT</span> class</span><br><span class="line">  <span class="keyword">FROM</span> TestResults</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> class</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">AVG</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex <span class="operator">=</span> <span class="string">&#x27;男&#x27;</span></span><br><span class="line">                <span class="keyword">THEN</span> score</span><br><span class="line">                <span class="keyword">ELSE</span> <span class="keyword">NULL</span> <span class="keyword">END</span>)</span><br><span class="line">     <span class="operator">&lt;</span> <span class="built_in">AVG</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex <span class="operator">=</span> <span class="string">&#x27;女&#x27;</span></span><br><span class="line">                <span class="keyword">THEN</span> score</span><br><span class="line">                <span class="keyword">ELSE</span> <span class="keyword">NULL</span> <span class="keyword">END</span>);</span><br></pre></td></tr></table></figure>
<h3 id="调查集合性质时经常用到的条件"><a class="markdownIt-Anchor" href="#调查集合性质时经常用到的条件">#</a> 调查集合性质时经常用到的条件</h3>
<img data-src="/2020/09/01/sql/having19.png" class="">
<h2 id="外连接的用法"><a class="markdownIt-Anchor" href="#外连接的用法">#</a> 外连接的用法</h2>
<h3 id="用外连接进行行列转换-1行-列制作交叉表"><a class="markdownIt-Anchor" href="#用外连接进行行列转换-1行-列制作交叉表">#</a> 用外连接进行行列转换 (1)（行 → 列）：制作交叉表</h3>
<img data-src="/2020/09/01/sql/outer_join01.png" class="">
<img data-src="/2020/09/01/sql/outer_join02.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 水平展开求交叉表（1）：使用外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> C0.name,</span><br><span class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> C1.name <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span> <span class="string">&#x27;○&#x27;</span> <span class="keyword">ELSE</span> <span class="keyword">NULL</span> <span class="keyword">END</span> <span class="keyword">AS</span> &quot;SQL入门&quot;,</span><br><span class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> C2.name <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span> <span class="string">&#x27;○&#x27;</span> <span class="keyword">ELSE</span> <span class="keyword">NULL</span> <span class="keyword">END</span> <span class="keyword">AS</span> &quot;UNIX基础&quot;,</span><br><span class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> C3.name <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">THEN</span> <span class="string">&#x27;○&#x27;</span> <span class="keyword">ELSE</span> <span class="keyword">NULL</span> <span class="keyword">END</span> <span class="keyword">AS</span> &quot;Java中级&quot;</span><br><span class="line">  <span class="keyword">FROM</span>  (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name <span class="keyword">FROM</span>  Courses) C0</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span></span><br><span class="line">    (<span class="keyword">SELECT</span> name <span class="keyword">FROM</span> Courses <span class="keyword">WHERE</span> course <span class="operator">=</span> <span class="string">&#x27;SQL入门&#x27;</span> ) C1</span><br><span class="line">    <span class="keyword">ON</span>  C0.name <span class="operator">=</span> C1.name</span><br><span class="line">      <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span></span><br><span class="line">        (<span class="keyword">SELECT</span> name <span class="keyword">FROM</span> Courses <span class="keyword">WHERE</span> course <span class="operator">=</span> <span class="string">&#x27;UNIX基础&#x27;</span> ) C2</span><br><span class="line">        <span class="keyword">ON</span>  C0.name <span class="operator">=</span> C2.name</span><br><span class="line">          <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span></span><br><span class="line">            (<span class="keyword">SELECT</span> name <span class="keyword">FROM</span> Courses <span class="keyword">WHERE</span> course <span class="operator">=</span> <span class="string">&#x27;Java中级&#x27;</span> ) C3</span><br><span class="line">            <span class="keyword">ON</span>  C0.name <span class="operator">=</span> C3.name;</span><br></pre></td></tr></table></figure>
<p>一般情况下，外连接都可以用标量子查询替代 。这种做法的优点在于，需要增加或者减少课程时，只修改 SELECT 子句即可，代码修改起来比较简单。对于需要动态生成 SQL 的系统也是很有好处的。缺点是性能不太好，目前在 SELECT 子句中使用标量子查询（或者关联子查询）的话，性能开销还是相当大的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 水平展开（2）：使用标量子查询</span></span><br><span class="line"><span class="keyword">SELECT</span>  C0.name,</span><br><span class="line">  (<span class="keyword">SELECT</span> <span class="string">&#x27;○&#x27;</span></span><br><span class="line">     <span class="keyword">FROM</span> Courses C1</span><br><span class="line">    <span class="keyword">WHERE</span> course <span class="operator">=</span> <span class="string">&#x27;SQL入门&#x27;</span></span><br><span class="line">      <span class="keyword">AND</span> C1.name <span class="operator">=</span> C0.name) <span class="keyword">AS</span> &quot;SQL入门&quot;,</span><br><span class="line">  (<span class="keyword">SELECT</span> <span class="string">&#x27;○&#x27;</span></span><br><span class="line">     <span class="keyword">FROM</span> Courses C2</span><br><span class="line">    <span class="keyword">WHERE</span> course <span class="operator">=</span> <span class="string">&#x27;UNIX基础&#x27;</span></span><br><span class="line">      <span class="keyword">AND</span> C2.name <span class="operator">=</span> C0.name) <span class="keyword">AS</span> &quot;UNIX基础&quot;,</span><br><span class="line">  (<span class="keyword">SELECT</span> <span class="string">&#x27;○&#x27;</span></span><br><span class="line">     <span class="keyword">FROM</span> Courses C3</span><br><span class="line">    <span class="keyword">WHERE</span> course <span class="operator">=</span> <span class="string">&#x27;Java中级&#x27;</span></span><br><span class="line">      <span class="keyword">AND</span> C3.name <span class="operator">=</span> C0.name) <span class="keyword">AS</span> &quot;Java中级&quot;</span><br><span class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> name <span class="keyword">FROM</span> Courses) C0;</span><br></pre></td></tr></table></figure>
<p>使用 CASE 表达式。 CASE 表达式可以写在 SELECT 子句里的聚合函数内部，也可以写在聚合函数外部。这里，我们先把 SUM 函数的结果处理成 1 或者 NULL，然后在外层的 CASE 表达式里将 1 转换成 ○。 如果不使用聚合，那么返回结果的行数会是表 Courses 的行数，所以这里以参加培训课程的员工为单位进行聚合。这种做法和标量子查询的做法一样简洁，也能灵活地应对需求变更。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 水平展开（3）：嵌套使用CASE表达式</span></span><br><span class="line"><span class="keyword">SELECT</span>  name,</span><br><span class="line">        <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> course <span class="operator">=</span> <span class="string">&#x27;SQL入门&#x27;</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="keyword">NULL</span> <span class="keyword">END</span>) <span class="operator">&gt;=</span> <span class="number">1</span></span><br><span class="line">             <span class="keyword">THEN</span> <span class="string">&#x27;○&#x27;</span> <span class="keyword">ELSE</span> <span class="keyword">NULL</span> <span class="keyword">END</span> <span class="keyword">AS</span> &quot;SQL入门&quot;,</span><br><span class="line">        <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> course <span class="operator">=</span> <span class="string">&#x27;UNIX基础&#x27;</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="keyword">NULL</span> <span class="keyword">END</span>) <span class="operator">&gt;=</span> <span class="number">1</span></span><br><span class="line">             <span class="keyword">THEN</span> <span class="string">&#x27;○&#x27;</span> <span class="keyword">ELSE</span> <span class="keyword">NULL</span> <span class="keyword">END</span> <span class="keyword">AS</span> &quot;UNIX基础&quot;,</span><br><span class="line">        <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> course <span class="operator">=</span> <span class="string">&#x27;Java中级&#x27;</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="keyword">NULL</span> <span class="keyword">END</span>) <span class="operator">&gt;=</span> <span class="number">1</span></span><br><span class="line">             <span class="keyword">THEN</span> <span class="string">&#x27;○&#x27;</span> <span class="keyword">ELSE</span> <span class="keyword">NULL</span> <span class="keyword">END</span> <span class="keyword">AS</span> &quot;Java中级&quot;</span><br><span class="line">  <span class="keyword">FROM</span> Courses</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> name;</span><br></pre></td></tr></table></figure>
<h3 id="用外连接进行行列转换-2列-行汇总重复项于一列"><a class="markdownIt-Anchor" href="#用外连接进行行列转换-2列-行汇总重复项于一列">#</a> 用外连接进行行列转换 (2)（列 → 行）：汇总重复项于一列</h3>
<img data-src="/2020/09/01/sql/outer_join03.png" class="">
<img data-src="/2020/09/01/sql/outer_join04.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 获取员工子女列表的SQL语句（没有孩子的员工也输出）</span></span><br><span class="line"><span class="keyword">SELECT</span> EMP.employee, CHILDREN.child</span><br><span class="line"> <span class="keyword">FROM</span>  Personnel EMP</span><br><span class="line">  <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span></span><br><span class="line">   (<span class="keyword">SELECT</span> child_1 <span class="keyword">AS</span> child <span class="keyword">FROM</span> Personnel</span><br><span class="line">    <span class="keyword">UNION</span></span><br><span class="line">    <span class="keyword">SELECT</span> child_2 <span class="keyword">AS</span> child <span class="keyword">FROM</span> Personnel</span><br><span class="line">    <span class="keyword">UNION</span></span><br><span class="line">    <span class="keyword">SELECT</span> child_3 <span class="keyword">AS</span> child <span class="keyword">FROM</span> Personnel) CHILDREN</span><br><span class="line">  <span class="keyword">ON</span> CHILDREN.child <span class="keyword">IN</span> (EMP.child_1, EMP.child_2, EMP.child_3);</span><br></pre></td></tr></table></figure>
<h3 id="在交叉表里制作嵌套式表侧栏"><a class="markdownIt-Anchor" href="#在交叉表里制作嵌套式表侧栏">#</a> 在交叉表里制作嵌套式表侧栏</h3>
<p>表 TblPop 是一张按照县、年龄层级和性别统计的人口分布表，要求根据表 TblPop 生成交叉表 “包含嵌套式表侧栏的统计表”。</p>
<img data-src="/2020/09/01/sql/outer_join05.png" class="">
<img data-src="/2020/09/01/sql/outer_join06.png" class="">
<img data-src="/2020/09/01/sql/outer_join07.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用外连接生成嵌套式表侧栏：错误的SQL语句</span></span><br><span class="line"><span class="keyword">SELECT</span> MASTER1.age_class <span class="keyword">AS</span> age_class,</span><br><span class="line">       MASTER2.sex_cd <span class="keyword">AS</span> sex_cd,</span><br><span class="line">       DATA.pop_tohoku <span class="keyword">AS</span> pop_tohoku,</span><br><span class="line">       DATA.pop_kanto <span class="keyword">AS</span> pop_kanto</span><br><span class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> age_class, sex_cd,</span><br><span class="line">               <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> pref_name <span class="keyword">IN</span> (<span class="string">&#x27;青森&#x27;</span>, <span class="string">&#x27;秋田&#x27;</span>)</span><br><span class="line">                        <span class="keyword">THEN</span> population <span class="keyword">ELSE</span> <span class="keyword">NULL</span> <span class="keyword">END</span>) <span class="keyword">AS</span> pop_tohoku,</span><br><span class="line">               <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> pref_name <span class="keyword">IN</span> (<span class="string">&#x27;东京&#x27;</span>, <span class="string">&#x27;千叶&#x27;</span>)</span><br><span class="line">                        <span class="keyword">THEN</span> population <span class="keyword">ELSE</span> <span class="keyword">NULL</span> <span class="keyword">END</span>) <span class="keyword">AS</span> pop_kanto</span><br><span class="line">          <span class="keyword">FROM</span> TblPop</span><br><span class="line">         <span class="keyword">GROUP</span> <span class="keyword">BY</span> age_class, sex_cd) DATA</span><br><span class="line">        <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> TblAge MASTER1  <span class="comment">-- 外连接1：和年龄层级主表进行外连接</span></span><br><span class="line">           <span class="keyword">ON</span> MASTER1.age_class <span class="operator">=</span> DATA.age_class</span><br><span class="line">              <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> TblSex MASTER2 <span class="comment">-- 外连接2：和性别主表进行外连接</span></span><br><span class="line">                 <span class="keyword">ON</span> MASTER2.sex_cd <span class="operator">=</span> DATA.sex_cd;</span><br><span class="line"></span><br><span class="line">age_class sex_cd pop_tohoku pop_kanto</span><br><span class="line"><span class="comment">--------- ------ ---------- ---------</span></span><br><span class="line"><span class="number">1</span>         m      <span class="number">1100</span>       <span class="number">1800</span></span><br><span class="line"><span class="number">1</span>         f      <span class="number">1300</span>       <span class="number">2500</span></span><br><span class="line"><span class="number">3</span>         m      <span class="number">1000</span></span><br><span class="line"><span class="number">3</span>         f      <span class="number">1800</span>       <span class="number">2100</span></span><br></pre></td></tr></table></figure>
<p>原因是表 TblPop 里没有年龄层级为 2 的数据。 实际上，与年龄层级主表外连接之后，结果里是包含年龄层级为 2 的数据的。但是虽然年龄层级 2 确实可以通过外连接从表 TblAge 获取，但是在表 TblPop 里，与之相应的 “性别编号” 列却是 NULL。原因也不难理解。表 TblPop 里本来就没有年龄层级为 2 的数据，自然也没有相应的性别信息 m 或 f，于是 “性别编号” 列只能是 NULL。因此与性别主表进行外连接时，连接条件会变成 ON MASTER2.sex_cd =<br>
NULL，结果是 unknown。因此，最终结果里永远不会出现年龄层级为 2 的数据，即使改变两次外连接的先后顺序，结果也还是一样的</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 停在第1个外连接处时：结果里包含年龄层级为2的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> MASTER1.age_class <span class="keyword">AS</span> age_class,</span><br><span class="line">       DATA.sex_cd <span class="keyword">AS</span> sex_cd,</span><br><span class="line">       DATA.pop_tohoku <span class="keyword">AS</span> pop_tohoku,</span><br><span class="line">       DATA.pop_kanto <span class="keyword">AS</span> pop_kanto</span><br><span class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> age_class, sex_cd,</span><br><span class="line">               <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> pref_name <span class="keyword">IN</span> (<span class="string">&#x27;青森&#x27;</span>, <span class="string">&#x27;秋田&#x27;</span>)</span><br><span class="line">                        <span class="keyword">THEN</span> population <span class="keyword">ELSE</span> <span class="keyword">NULL</span> <span class="keyword">END</span>) <span class="keyword">AS</span> pop_tohoku,</span><br><span class="line">               <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> pref_name <span class="keyword">IN</span> (<span class="string">&#x27;东京&#x27;</span>, <span class="string">&#x27;千叶&#x27;</span>)</span><br><span class="line">                        <span class="keyword">THEN</span> population <span class="keyword">ELSE</span> <span class="keyword">NULL</span> <span class="keyword">END</span>) <span class="keyword">AS</span> pop_kanto</span><br><span class="line">          <span class="keyword">FROM</span> TblPop</span><br><span class="line">         <span class="keyword">GROUP</span> <span class="keyword">BY</span> age_class, sex_cd) DATA</span><br><span class="line">        <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> TblAge MASTER1</span><br><span class="line">           <span class="keyword">ON</span> MASTER1.age_class <span class="operator">=</span> DATA.age_class;</span><br><span class="line">age_class sex_cd pop_tohoku pop_kanto</span><br><span class="line"><span class="comment">--------- ------ ---------- ---------</span></span><br><span class="line"><span class="number">1</span>         m      <span class="number">1100</span>       <span class="number">1800</span></span><br><span class="line"><span class="number">1</span>         f      <span class="number">1300</span>       <span class="number">2500</span></span><br><span class="line"><span class="number">2</span>                           <span class="comment">-- 存在年龄层级为 2 的数据</span></span><br><span class="line"><span class="number">3</span>         m      <span class="number">1000</span></span><br><span class="line"><span class="number">3</span>         f      <span class="number">1800</span>       <span class="number">2100</span></span><br></pre></td></tr></table></figure>
<p>如果不允许进行两次外连接，那么调整成一次就可以了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用外连接生成嵌套式表侧栏：正确的SQL语句</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  MASTER.age_class <span class="keyword">AS</span> age_class,</span><br><span class="line">  MASTER.sex_cd    <span class="keyword">AS</span> sex_cd,</span><br><span class="line">  DATA.pop_tohoku  <span class="keyword">AS</span> pop_tohoku,</span><br><span class="line">  DATA.pop_kanto   <span class="keyword">AS</span> pop_kanto</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  (<span class="keyword">SELECT</span></span><br><span class="line">     age_class,</span><br><span class="line">     sex_cd,</span><br><span class="line">     <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> pref_name <span class="keyword">IN</span> (<span class="string">&#x27;青森&#x27;</span>, <span class="string">&#x27;秋田&#x27;</span>)</span><br><span class="line">              <span class="keyword">THEN</span> population <span class="keyword">ELSE</span> <span class="keyword">NULL</span> <span class="keyword">END</span>) <span class="keyword">AS</span> pop_tohoku,</span><br><span class="line">     <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> pref_name <span class="keyword">IN</span> (<span class="string">&#x27;东京&#x27;</span>, <span class="string">&#x27;千叶&#x27;</span>)</span><br><span class="line">              <span class="keyword">THEN</span> population <span class="keyword">ELSE</span> <span class="keyword">NULL</span> <span class="keyword">END</span>) <span class="keyword">AS</span> pop_kanto</span><br><span class="line">   <span class="keyword">FROM</span> TblPop</span><br><span class="line">   <span class="keyword">GROUP</span> <span class="keyword">BY</span> age_class, sex_cd) DATA</span><br><span class="line">     <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span></span><br><span class="line">       (<span class="keyword">SELECT</span> age_class, sex_cd</span><br><span class="line">          <span class="keyword">FROM</span> TblAge</span><br><span class="line">                <span class="keyword">CROSS</span> <span class="keyword">JOIN</span></span><br><span class="line">               TblSex ) MASTER</span><br><span class="line">     <span class="keyword">ON</span>  MASTER.age_class <span class="operator">=</span> DATA.age_class</span><br><span class="line">    <span class="keyword">AND</span>  MASTER.sex_cd    <span class="operator">=</span> DATA.sex_cd;</span><br></pre></td></tr></table></figure>
<h3 id="作为乘法运算的连接"><a class="markdownIt-Anchor" href="#作为乘法运算的连接">#</a> 作为乘法运算的连接</h3>
<img data-src="/2020/09/01/sql/outer_join08.png" class="">
<img data-src="/2020/09/01/sql/outer_join09.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 解答（1）：通过在连接前聚合来创建一对一的关系</span></span><br><span class="line"><span class="keyword">SELECT</span> I.item_no, SH.total_qty</span><br><span class="line">  <span class="keyword">FROM</span> Items I <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span></span><br><span class="line">       (<span class="keyword">SELECT</span> item_no, <span class="built_in">SUM</span>(quantity) <span class="keyword">AS</span> total_qty</span><br><span class="line">          <span class="keyword">FROM</span> SalesHistory</span><br><span class="line">         <span class="keyword">GROUP</span> <span class="keyword">BY</span> item_no) SH</span><br><span class="line">    <span class="keyword">ON</span> I.item_no <span class="operator">=</span> SH.item_no;</span><br></pre></td></tr></table></figure>
<p>如果从性能角度考虑，上述 SQL 语句还是有些问题的。比如临时视图 SH 的数据需要临时存储在内存里，还有就是虽然通过聚合将 item_no 变成了主键，但是 SH 上却不存在主键索引，因此我们也就无法利用索引优化查询。要改善这个查询，关键在于导入 “把连接看作乘法运算” 这种视点。商品主表 Items 和视图 SH 确实是一对一的关系，但其实从 “item_no” 列看，表 Items 和表 SalesHistory 是一对多的关系。而且，当连接操作的双方是一对多关系时，结果的行数并不会增加。这就像普通乘法里任意数乘以 1 后，结果不会变化一样 。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 解答(2)：先进行一对多的连接再聚合</span></span><br><span class="line"><span class="keyword">SELECT</span> I.item_no, <span class="built_in">SUM</span>(SH.quantity) <span class="keyword">AS</span> total_qty</span><br><span class="line">  <span class="keyword">FROM</span> Items I <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> SalesHistory SH</span><br><span class="line">    <span class="keyword">ON</span> I.item_no <span class="operator">=</span> SH.item_no <span class="comment">-- 一对多的连接</span></span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> I.item_no;</span><br></pre></td></tr></table></figure>
<h3 id="全外连接"><a class="markdownIt-Anchor" href="#全外连接">#</a> 全外连接</h3>
<p>在两张班级学生表里，田中和铃木同时属于两张表，而伊集院和西园寺只属于其中一张表。全外连接是能够从这样两张内容不一致的表里，没有遗漏地获取全部信息的方法，所以也可以理解成 “把两张表都当作主表来使用” 的连接。</p>
<img data-src="/2020/09/01/sql/outer_join10.png" class="">
<img data-src="/2020/09/01/sql/outer_join11.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 全外连接保留全部信息</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COALESCE</span>(A.id, B.id) <span class="keyword">AS</span> id, <span class="comment">--COALESCE 是SQL 的标准函数，可以接受多个参数，功能是返回第一个非 NULL 的参数。</span></span><br><span class="line">       A.name <span class="keyword">AS</span> A_name,</span><br><span class="line">       B.name <span class="keyword">AS</span> B_name</span><br><span class="line"><span class="keyword">FROM</span> Class_A  A  <span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Class_B  B</span><br><span class="line">  <span class="keyword">ON</span> A.id <span class="operator">=</span> B.id;</span><br><span class="line"></span><br><span class="line">id   A_name B_name</span><br><span class="line"><span class="comment">---- ------ ------</span></span><br><span class="line"><span class="number">1</span>    田中   田中</span><br><span class="line"><span class="number">2</span>    铃木   铃木</span><br><span class="line"><span class="number">3</span>    伊集院</span><br><span class="line"><span class="number">4</span>           西园寺</span><br></pre></td></tr></table></figure>
<p>如果所用的数据库不支持全外连接，可以分别进行左外连接和右外连接，再把两个结果通过 UNION 合并起来，也能达到同样的目的 。这种写法虽然也能获取到同样的结果，但是代码比较冗长，而且使用两次连接后还要用 UNION 来合并，性能也不是很好。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 数据库不支持全外连接时的替代方案</span></span><br><span class="line"><span class="keyword">SELECT</span> A.id <span class="keyword">AS</span> id, A.name, B.name</span><br><span class="line">  <span class="keyword">FROM</span> Class_A  A   <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Class_B  B</span><br><span class="line">    <span class="keyword">ON</span> A.id <span class="operator">=</span> B.id</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> B.id <span class="keyword">AS</span> id, A.name, B.name</span><br><span class="line">  <span class="keyword">FROM</span> Class_A  A  <span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Class_B  B</span><br><span class="line">    <span class="keyword">ON</span> A.id <span class="operator">=</span> B.id;</span><br></pre></td></tr></table></figure>
<p>其实，我们还可以换个角度，把表连接看成集合运算。内连接相当于求集合的积（INTERSECT，也称交集），全外连接相当于求集合的和（UNION，<br>
也称并集）。下面是两者的维恩图（Venn Diagram，亦称文氏图）。</p>
<img data-src="/2020/09/01/sql/outer_join12.png" class="">
<h3 id="用外连接进行集合运算"><a class="markdownIt-Anchor" href="#用外连接进行集合运算">#</a> 用外连接进行集合运算</h3>
<p><strong>用外连接求差集 ： A － B</strong></p>
<img data-src="/2020/09/01/sql/outer_join13.png" class="">
<p><strong>用全外连接求异或集</strong><br>
接下来我们考虑一下如何求两个集合的异或集。 SQL 没有定义求异或集的运算符，如果用集合运算符，可以有两种方法。一种是 (A UNION B)<br>
 EXCEPT (A INTERSECT B)，另一种是 (A EXCEPT B) UNION (B EXCEPT A)。两种方法都比较麻烦，性能开销也会增大。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COALESCE</span>(A.id, B.id) <span class="keyword">AS</span> id,</span><br><span class="line">       <span class="built_in">COALESCE</span>(A.name , B.name ) <span class="keyword">AS</span> name</span><br><span class="line"> <span class="keyword">FROM</span>  Class_A A <span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Class_B B</span><br><span class="line">   <span class="keyword">ON</span> A.id <span class="operator">=</span> B.id</span><br><span class="line"><span class="keyword">WHERE</span> A.name <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line">   <span class="keyword">OR</span> B.name <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"></span><br><span class="line">id   name</span><br><span class="line"><span class="comment">---- -----</span></span><br><span class="line"><span class="number">3</span>    伊集院</span><br><span class="line"><span class="number">4</span>    西园寺</span><br></pre></td></tr></table></figure>
<h2 id="用关联子查询比较行与行"><a class="markdownIt-Anchor" href="#用关联子查询比较行与行">#</a> 用关联子查询比较行与行</h2>
<h3 id="增长-减少-维持现状"><a class="markdownIt-Anchor" href="#增长-减少-维持现状">#</a> 增长、减少、维持现状</h3>
<img data-src="/2020/09/01/sql/subquery01.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 求与上一年营业额一样的年份（1）：使用关联子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span>,sale</span><br><span class="line">  <span class="keyword">FROM</span> Sales S1</span><br><span class="line"> <span class="keyword">WHERE</span> sale <span class="operator">=</span> (<span class="keyword">SELECT</span> sale</span><br><span class="line">                 <span class="keyword">FROM</span> Sales S2</span><br><span class="line">                <span class="keyword">WHERE</span> S2.year <span class="operator">=</span> S1.year <span class="operator">-</span> <span class="number">1</span>)</span><br><span class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">year</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">year</span>  sale</span><br><span class="line"><span class="comment">----- ----</span></span><br><span class="line"><span class="number">1993</span>  <span class="number">52</span></span><br><span class="line"><span class="number">1995</span>  <span class="number">50</span></span><br></pre></td></tr></table></figure>
<img data-src="/2020/09/01/sql/subquery02.png" class="">
<p>子查询里的 S2.year = S1.year – 1 这个条件起到了将要比较的数据偏移一行的作用。关联子查询和自连接在很多时候都是等价的，所以我<br>
们也可以像下面这样使用自连接来实现。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 求与上一年营业额一样的年份（2）：使用自连接</span></span><br><span class="line"><span class="keyword">SELECT</span> S1.year, S1.sale</span><br><span class="line">  <span class="keyword">FROM</span> Sales S1,</span><br><span class="line">       Sales S2</span><br><span class="line"> <span class="keyword">WHERE</span> S2.sale <span class="operator">=</span> S1.sale</span><br><span class="line">   <span class="keyword">AND</span> S2.year <span class="operator">=</span> S1.year <span class="operator">-</span> <span class="number">1</span></span><br><span class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">year</span>;</span><br></pre></td></tr></table></figure>
<p><strong>用列表展示与上一年的比较结果</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 求出是增长了还是减少了，抑或是维持现状（1）：使用关联子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> S1.year, S1.sale,</span><br><span class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> sale <span class="operator">=</span></span><br><span class="line">             (<span class="keyword">SELECT</span> sale</span><br><span class="line">                <span class="keyword">FROM</span> Sales S2</span><br><span class="line">               <span class="keyword">WHERE</span> S2.year <span class="operator">=</span> S1.year <span class="operator">-</span> <span class="number">1</span>) <span class="keyword">THEN</span> <span class="string">&#x27;→&#x27;</span> <span class="comment">-- 持平</span></span><br><span class="line">            <span class="keyword">WHEN</span> sale <span class="operator">&gt;</span></span><br><span class="line">             (<span class="keyword">SELECT</span> sale</span><br><span class="line">                <span class="keyword">FROM</span> Sales S2</span><br><span class="line">               <span class="keyword">WHERE</span> S2.year <span class="operator">=</span> S1.year <span class="operator">-</span> <span class="number">1</span>) <span class="keyword">THEN</span> <span class="string">&#x27;↑&#x27;</span> <span class="comment">-- 增长</span></span><br><span class="line">            <span class="keyword">WHEN</span> sale <span class="operator">&lt;</span></span><br><span class="line">             (<span class="keyword">SELECT</span> sale</span><br><span class="line">                <span class="keyword">FROM</span> Sales S2</span><br><span class="line">               <span class="keyword">WHERE</span> S2.year <span class="operator">=</span> S1.year <span class="operator">-</span> <span class="number">1</span>) <span class="keyword">THEN</span> <span class="string">&#x27;↓&#x27;</span> <span class="comment">-- 减少</span></span><br><span class="line">       <span class="keyword">ELSE</span> <span class="string">&#x27;—&#x27;</span> <span class="keyword">END</span> <span class="keyword">AS</span> var</span><br><span class="line">  <span class="keyword">FROM</span> Sales S1</span><br><span class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">year</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">year</span>   sale var</span><br><span class="line"><span class="comment">------ ---- ---</span></span><br><span class="line"><span class="number">1990</span>   <span class="number">50</span>    —</span><br><span class="line"><span class="number">1991</span>   <span class="number">51</span>    ↑</span><br><span class="line"><span class="number">1992</span>   <span class="number">52</span>    ↑</span><br><span class="line"><span class="number">1993</span>   <span class="number">52</span>    →</span><br><span class="line"><span class="number">1994</span>   <span class="number">50</span>    ↓</span><br><span class="line"><span class="number">1995</span>   <span class="number">50</span>    →</span><br><span class="line"><span class="number">1996</span>   <span class="number">49</span>    ↓</span><br><span class="line"><span class="number">1997</span>   <span class="number">55</span>    ↑</span><br></pre></td></tr></table></figure>
<p>同样，这里也可以改写一下 SQL 语句，使用自连接来实现。采用这种实现方法时，由于这里没有 1990 年之前的数据，所以 1990 年会被排除掉，执行结果会少一行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 求出是增长了还是减少了，抑或是维持现状（2）：使用自连接查询</span></span><br><span class="line"><span class="keyword">SELECT</span> S1.year, S1.sale,</span><br><span class="line">       <span class="keyword">CASE</span> <span class="keyword">WHEN</span> S1.sale <span class="operator">=</span> S2.sale <span class="keyword">THEN</span> <span class="string">&#x27;→&#x27;</span></span><br><span class="line">            <span class="keyword">WHEN</span> S1.sale <span class="operator">&gt;</span> S2.sale <span class="keyword">THEN</span> <span class="string">&#x27;↑&#x27;</span></span><br><span class="line">            <span class="keyword">WHEN</span> S1.sale <span class="operator">&lt;</span> S2.sale <span class="keyword">THEN</span> <span class="string">&#x27;↓&#x27;</span></span><br><span class="line">       <span class="keyword">ELSE</span> <span class="string">&#x27;—&#x27;</span> <span class="keyword">END</span> <span class="keyword">AS</span> var</span><br><span class="line">  <span class="keyword">FROM</span> Sales S1, Sales S2</span><br><span class="line"> <span class="keyword">WHERE</span> S2.year <span class="operator">=</span> S1.year<span class="number">-1</span></span><br><span class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">year</span>;</span><br></pre></td></tr></table></figure>
<h3 id="时间轴有间断时-和过去最临近的时间进行比较"><a class="markdownIt-Anchor" href="#时间轴有间断时-和过去最临近的时间进行比较">#</a> 时间轴有间断时 ： 和过去最临近的时间进行比较</h3>
<img data-src="/2020/09/01/sql/subquery03.png" class="">
<p>使用子查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询与过去最临近的年份营业额相同的年份</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">year</span>, sale</span><br><span class="line">  <span class="keyword">FROM</span> Sales2 S1</span><br><span class="line"> <span class="keyword">WHERE</span> sale <span class="operator">=</span></span><br><span class="line">   (<span class="keyword">SELECT</span> sale</span><br><span class="line">      <span class="keyword">FROM</span> Sales2 S2</span><br><span class="line">     <span class="keyword">WHERE</span> S2.year <span class="operator">=</span></span><br><span class="line">       (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(<span class="keyword">year</span>)            <span class="comment">-- 条件2：在满足条件1的年份中，年份最早的一个</span></span><br><span class="line">          <span class="keyword">FROM</span> Sales2 S3</span><br><span class="line">         <span class="keyword">WHERE</span> S1.year <span class="operator">&gt;</span> S3.year))  <span class="comment">-- 条件1：与该年份相比是过去的年份</span></span><br><span class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">year</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">year</span>  sale</span><br><span class="line"><span class="comment">----- ----</span></span><br><span class="line"><span class="number">1992</span>  <span class="number">50</span></span><br><span class="line"><span class="number">1997</span>  <span class="number">55</span></span><br></pre></td></tr></table></figure>
<p>使用自连接</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询与过去最临近的年份营业额相同的年份：同时使用自连接</span></span><br><span class="line"><span class="keyword">SELECT</span> S1.year <span class="keyword">AS</span> <span class="keyword">year</span>,</span><br><span class="line">       S1.sale <span class="keyword">AS</span> sale</span><br><span class="line">  <span class="keyword">FROM</span> Sales2 S1, Sales2 S2</span><br><span class="line"> <span class="keyword">WHERE</span> S1.sale <span class="operator">=</span> S2.sale</span><br><span class="line">   <span class="keyword">AND</span> S2.year <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(<span class="keyword">year</span>)</span><br><span class="line">                    <span class="keyword">FROM</span> Sales2 S3</span><br><span class="line">                   <span class="keyword">WHERE</span> S1.year <span class="operator">&gt;</span> S3.year)</span><br><span class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">year</span>;</span><br></pre></td></tr></table></figure>
<p>通过这个方法，我们可以查询每一年与过去最临近的年份之间的营业额之差。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 求每一年与过去最临近的年份之间的营业额之差（1）：结果里不包含最早的年份</span></span><br><span class="line"><span class="keyword">SELECT</span> S2.year <span class="keyword">AS</span> pre_year,</span><br><span class="line">       S1.year <span class="keyword">AS</span> now_year,</span><br><span class="line">       S2.sale <span class="keyword">AS</span> pre_sale,</span><br><span class="line">       S1.sale <span class="keyword">AS</span> now_sale,</span><br><span class="line">       S1.sale <span class="operator">-</span> S2.sale  <span class="keyword">AS</span> diff</span><br><span class="line"> <span class="keyword">FROM</span> Sales2 S1, Sales2 S2</span><br><span class="line"> <span class="keyword">WHERE</span> S2.year <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(<span class="keyword">year</span>)</span><br><span class="line">                    <span class="keyword">FROM</span> Sales2 S3</span><br><span class="line">                   <span class="keyword">WHERE</span> S1.year <span class="operator">&gt;</span> S3.year)</span><br><span class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> now_year;</span><br><span class="line"></span><br><span class="line">pre_year now_year pre_sale now_sale diff</span><br><span class="line"><span class="comment">-------- -------- -------- -------- ----</span></span><br><span class="line"><span class="number">1990</span>     <span class="number">1992</span>     <span class="number">50</span>       <span class="number">50</span>       <span class="number">0</span> <span class="comment">--50 - 50 = 0</span></span><br><span class="line"><span class="number">1992</span>     <span class="number">1993</span>     <span class="number">50</span>       <span class="number">52</span>       <span class="number">2</span> <span class="comment">--52 - 50 = 2</span></span><br><span class="line"><span class="number">1993</span>     <span class="number">1994</span>     <span class="number">52</span>       <span class="number">55</span>       <span class="number">3</span> <span class="comment">--55 - 52 = 3</span></span><br><span class="line"><span class="number">1994</span>     <span class="number">1997</span>     <span class="number">55</span>       <span class="number">55</span>       <span class="number">0</span> <span class="comment">--55 - 55 = 0</span></span><br></pre></td></tr></table></figure>
<p>这条 SQL 语句无法获取到最早年份 1990 年的数据。这是因为，表里没有比 1990 年更早的年份，所以在进行内连接的时候 1990 年的数据就被排除掉了。如果想让结果里出现 1990 年的数据，可以使用 “自外连接” 来实现。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 求每一年与过去最临近的年份之间的营业额之差（2）：使用自外连接。结果里包含最早的年份</span></span><br><span class="line"><span class="keyword">SELECT</span> S2.year <span class="keyword">AS</span> pre_year,</span><br><span class="line">       S1.year <span class="keyword">AS</span> now_year,</span><br><span class="line">       S2.sale <span class="keyword">AS</span> pre_sale,</span><br><span class="line">       S1.sale <span class="keyword">AS</span> now_sale,</span><br><span class="line">       S1.sale <span class="operator">-</span> S2.sale <span class="keyword">AS</span> diff</span><br><span class="line"> <span class="keyword">FROM</span> Sales2 S1 <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Sales2 S2</span><br><span class="line">   <span class="keyword">ON</span> S2.year <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(<span class="keyword">year</span>)</span><br><span class="line">                   <span class="keyword">FROM</span> Sales2 S3</span><br><span class="line">                  <span class="keyword">WHERE</span> S1.year <span class="operator">&gt;</span> S3.year)</span><br><span class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> now_year;</span><br><span class="line"></span><br><span class="line">pre_year now_year pre_sale now_sale diff</span><br><span class="line"><span class="comment">-------- -------- -------- -------- ----</span></span><br><span class="line">         <span class="number">1990</span>              <span class="number">50</span>         <span class="comment">--1990 年也会出现</span></span><br><span class="line"><span class="number">1990</span>     <span class="number">1992</span>     <span class="number">50</span>       <span class="number">50</span>       <span class="number">0</span> <span class="comment">--50 - 50 = 0</span></span><br><span class="line"><span class="number">1992</span>     <span class="number">1993</span>     <span class="number">50</span>       <span class="number">52</span>       <span class="number">2</span> <span class="comment">--52 - 50 = 2</span></span><br><span class="line"><span class="number">1993</span>     <span class="number">1994</span>     <span class="number">52</span>       <span class="number">55</span>       <span class="number">3</span> <span class="comment">--55 - 52 = 3</span></span><br><span class="line"><span class="number">1994</span>     <span class="number">1997</span>     <span class="number">55</span>       <span class="number">55</span>       <span class="number">0</span> <span class="comment">--55 - 55 = 0</span></span><br></pre></td></tr></table></figure>
<h3 id="移动累计值和移动平均值"><a class="markdownIt-Anchor" href="#移动累计值和移动平均值">#</a> 移动累计值和移动平均值</h3>
<img data-src="/2020/09/01/sql/subquery04.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 求累计值：使用窗口函数</span></span><br><span class="line"><span class="keyword">SELECT</span> prc_date, prc_amt,</span><br><span class="line">       <span class="built_in">SUM</span>(prc_amt) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> prc_date) <span class="keyword">AS</span> onhand_amt</span><br><span class="line">  <span class="keyword">FROM</span> Accounts;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 求累计值：使用冯·诺依曼型递归集合</span></span><br><span class="line"><span class="keyword">SELECT</span> prc_date, A1.prc_amt,</span><br><span class="line">      (<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(prc_amt)</span><br><span class="line">         <span class="keyword">FROM</span> Accounts A2</span><br><span class="line">        <span class="keyword">WHERE</span> A1.prc_date <span class="operator">&gt;=</span> A2.prc_date ) <span class="keyword">AS</span> onhand_amt</span><br><span class="line">  <span class="keyword">FROM</span> Accounts A1</span><br><span class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> prc_date;</span><br><span class="line"></span><br><span class="line">prc_date   prc_amt onhand_amt</span><br><span class="line"><span class="comment">---------- ------- ----------</span></span><br><span class="line"><span class="number">2006</span><span class="number">-10</span><span class="number">-26</span> <span class="number">12000</span>   <span class="number">12000</span> <span class="comment">-- 12000</span></span><br><span class="line"><span class="number">2006</span><span class="number">-10</span><span class="number">-28</span> <span class="number">2500</span>    <span class="number">14500</span> <span class="comment">-- 12000 + 2500</span></span><br><span class="line"><span class="number">2006</span><span class="number">-10</span><span class="number">-31</span> <span class="number">-15000</span>  <span class="number">-500</span> <span class="comment">-- 12000 + 2500 + (-15000)</span></span><br><span class="line"><span class="number">2006</span><span class="number">-11</span><span class="number">-03</span> <span class="number">34000</span>   <span class="number">33500</span> <span class="comment">-- 12000 + 2500 + (-15000) + 34000</span></span><br><span class="line"><span class="number">2006</span><span class="number">-11</span><span class="number">-04</span> <span class="number">-5000</span>   <span class="number">28500</span> <span class="comment">-- 下同</span></span><br><span class="line"><span class="number">2006</span><span class="number">-11</span><span class="number">-06</span> <span class="number">7200</span>    <span class="number">35700</span> <span class="comment">-- ：</span></span><br><span class="line"><span class="number">2006</span><span class="number">-11</span><span class="number">-11</span> <span class="number">11000</span>   <span class="number">46700</span> <span class="comment">-- ：</span></span><br></pre></td></tr></table></figure>
<p>求移动累计值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 求移动累计值（1）：使用窗口函数</span></span><br><span class="line"><span class="keyword">SELECT</span> prc_date, prc_amt,</span><br><span class="line">       <span class="built_in">SUM</span>(prc_amt) <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> prc_date</span><br><span class="line">                           <span class="keyword">ROWS</span> <span class="number">2</span> PRECEDING) <span class="keyword">AS</span> onhand_amt</span><br><span class="line">  <span class="keyword">FROM</span> Accounts;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 求移动累计值（2）：不满3行的时间区间也输出</span></span><br><span class="line"><span class="keyword">SELECT</span> prc_date, A1.prc_amt,</span><br><span class="line">      (<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(prc_amt)</span><br><span class="line">         <span class="keyword">FROM</span> Accounts A2</span><br><span class="line">        <span class="keyword">WHERE</span> A1.prc_date <span class="operator">&gt;=</span> A2.prc_date</span><br><span class="line">          <span class="keyword">AND</span> (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line">                 <span class="keyword">FROM</span> Accounts A3</span><br><span class="line">                <span class="keyword">WHERE</span> A3.prc_date</span><br><span class="line">                  <span class="keyword">BETWEEN</span> A2.prc_date <span class="keyword">AND</span> A1.prc_date  ) <span class="operator">&lt;=</span> <span class="number">3</span> ) <span class="keyword">AS</span> mvg_sum</span><br><span class="line">  <span class="keyword">FROM</span> Accounts A1</span><br><span class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> prc_date;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">prc_date   prc_amt mvg_sum</span><br><span class="line"><span class="comment">---------- ------- -------</span></span><br><span class="line"><span class="number">2006</span><span class="number">-10</span><span class="number">-26</span> <span class="number">12000</span>   <span class="number">12000</span> <span class="comment">--12000</span></span><br><span class="line"><span class="number">2006</span><span class="number">-10</span><span class="number">-28</span> <span class="number">2500</span>    <span class="number">14500</span> <span class="comment">--12000 + 2500</span></span><br><span class="line"><span class="number">2006</span><span class="number">-10</span><span class="number">-31</span> <span class="number">-15000</span>  <span class="number">-500</span> <span class="comment">--12000 + 2500 + (-15000)</span></span><br><span class="line"><span class="number">2006</span><span class="number">-11</span><span class="number">-03</span> <span class="number">34000</span>   <span class="number">21500</span> <span class="comment">--2500 + (-15000) + 34000</span></span><br><span class="line"><span class="number">2006</span><span class="number">-11</span><span class="number">-04</span> <span class="number">-5000</span>   <span class="number">14000</span> <span class="comment">-- 下同</span></span><br><span class="line"><span class="number">2006</span><span class="number">-11</span><span class="number">-06</span> <span class="number">7200</span>    <span class="number">36200</span> <span class="comment">-- ：</span></span><br><span class="line"><span class="number">2006</span><span class="number">-11</span><span class="number">-11</span> <span class="number">11000</span>   <span class="number">13200</span> <span class="comment">-- ：</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 求移动累计值（3）：不满3行的区间按无效处理</span></span><br><span class="line"><span class="keyword">SELECT</span> prc_date, A1.prc_amt,</span><br><span class="line"> (<span class="keyword">SELECT</span> <span class="built_in">SUM</span>(prc_amt)</span><br><span class="line">    <span class="keyword">FROM</span> Accounts A2</span><br><span class="line">   <span class="keyword">WHERE</span> A1.prc_date <span class="operator">&gt;=</span> A2.prc_date</span><br><span class="line">     <span class="keyword">AND</span> (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line">            <span class="keyword">FROM</span> Accounts A3</span><br><span class="line">           <span class="keyword">WHERE</span> A3.prc_date</span><br><span class="line">             <span class="keyword">BETWEEN</span> A2.prc_date <span class="keyword">AND</span> A1.prc_date  ) <span class="operator">&lt;=</span> <span class="number">3</span></span><br><span class="line">   <span class="keyword">HAVING</span>  <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">=</span><span class="number">3</span>) <span class="keyword">AS</span> mvg_sum  <span class="comment">-- 不满3行数据的不显示</span></span><br><span class="line">  <span class="keyword">FROM</span>  Accounts A1</span><br><span class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> prc_date;</span><br><span class="line"></span><br><span class="line">prc_date   prc_amt mvg_sum</span><br><span class="line"><span class="comment">---------- ------- -------</span></span><br><span class="line"><span class="number">2006</span><span class="number">-10</span><span class="number">-26</span> <span class="number">12000</span>   <span class="comment">-- 不满 3 行数据，所以不显示</span></span><br><span class="line"><span class="number">2006</span><span class="number">-10</span><span class="number">-28</span> <span class="number">2500</span>    <span class="comment">-- 不满 3 行数据，所以不显示</span></span><br><span class="line"><span class="number">2006</span><span class="number">-10</span><span class="number">-31</span> <span class="number">-15000</span>  <span class="number">-500</span> <span class="comment">-- 凑够了 3 行，所以输出</span></span><br><span class="line"><span class="number">2006</span><span class="number">-11</span><span class="number">-03</span> <span class="number">34000</span>   <span class="number">21500</span></span><br><span class="line"><span class="number">2006</span><span class="number">-11</span><span class="number">-04</span> <span class="number">-5000</span>   <span class="number">14000</span></span><br><span class="line"><span class="number">2006</span><span class="number">-11</span><span class="number">-06</span> <span class="number">7200</span>    <span class="number">36200</span></span><br><span class="line"><span class="number">2006</span><span class="number">-11</span><span class="number">-11</span> <span class="number">11000</span>   <span class="number">13200</span></span><br></pre></td></tr></table></figure>
<p>如果觉得这条 SQL 语句的处理过程难以理解，我们可以输出去掉聚合后的明细数据来看一下，这样应该会好理解 。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 去掉聚合并输出</span></span><br><span class="line"><span class="keyword">SELECT</span> A1.prc_date <span class="keyword">AS</span> A1_date,</span><br><span class="line">       A2.prc_date <span class="keyword">AS</span> A2_date,</span><br><span class="line">       A2.prc_amt <span class="keyword">AS</span> amt</span><br><span class="line"> <span class="keyword">FROM</span> Accounts A1, Accounts A2</span><br><span class="line"><span class="keyword">WHERE</span> A1.prc_date <span class="operator">&gt;=</span> A2.prc_date</span><br><span class="line">  <span class="keyword">AND</span> (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line">       <span class="keyword">FROM</span> Accounts A3</span><br><span class="line">       <span class="keyword">WHERE</span> A3.prc_date <span class="keyword">BETWEEN</span> A2.prc_date <span class="keyword">AND</span> A1.prc_date ) <span class="operator">&lt;=</span> <span class="number">3</span></span><br><span class="line"> <span class="keyword">ORDER</span> <span class="keyword">BY</span> A1_date, A2_date;</span><br><span class="line"></span><br><span class="line">A1_date    A2_date    amt</span><br><span class="line"><span class="comment">---------- ---------- -------</span></span><br><span class="line"><span class="number">2006</span><span class="number">-10</span><span class="number">-26</span> <span class="number">2006</span><span class="number">-10</span><span class="number">-26</span> <span class="number">12000</span></span><br><span class="line"></span><br><span class="line"><span class="number">2006</span><span class="number">-10</span><span class="number">-28</span> <span class="number">2006</span><span class="number">-10</span><span class="number">-26</span> <span class="number">12000</span></span><br><span class="line"><span class="number">2006</span><span class="number">-10</span><span class="number">-28</span> <span class="number">2006</span><span class="number">-10</span><span class="number">-28</span> <span class="number">2500</span></span><br><span class="line"></span><br><span class="line"><span class="number">2006</span><span class="number">-10</span><span class="number">-31</span> <span class="number">2006</span><span class="number">-10</span><span class="number">-26</span> <span class="number">12000</span></span><br><span class="line"><span class="number">2006</span><span class="number">-10</span><span class="number">-31</span> <span class="number">2006</span><span class="number">-10</span><span class="number">-28</span> <span class="number">2500</span>   …S1 ： <span class="number">-500</span></span><br><span class="line"><span class="number">2006</span><span class="number">-10</span><span class="number">-31</span> <span class="number">2006</span><span class="number">-10</span><span class="number">-31</span> <span class="number">-15000</span></span><br><span class="line"></span><br><span class="line"><span class="number">2006</span><span class="number">-11</span><span class="number">-03</span> <span class="number">2006</span><span class="number">-10</span><span class="number">-28</span> <span class="number">2500</span></span><br><span class="line"><span class="number">2006</span><span class="number">-11</span><span class="number">-03</span> <span class="number">2006</span><span class="number">-10</span><span class="number">-31</span> <span class="number">-15000</span> …S2 ： <span class="number">21500</span></span><br><span class="line"><span class="number">2006</span><span class="number">-11</span><span class="number">-03</span> <span class="number">2006</span><span class="number">-11</span><span class="number">-03</span> <span class="number">34000</span></span><br><span class="line"></span><br><span class="line"><span class="number">2006</span><span class="number">-11</span><span class="number">-04</span> <span class="number">2006</span><span class="number">-10</span><span class="number">-31</span> <span class="number">-15000</span></span><br><span class="line"><span class="number">2006</span><span class="number">-11</span><span class="number">-04</span> <span class="number">2006</span><span class="number">-11</span><span class="number">-03</span> <span class="number">34000</span>  …S3 ： <span class="number">14000</span></span><br><span class="line"><span class="number">2006</span><span class="number">-11</span><span class="number">-04</span> <span class="number">2006</span><span class="number">-11</span><span class="number">-04</span> <span class="number">-5000</span></span><br><span class="line"></span><br><span class="line"><span class="number">2006</span><span class="number">-11</span><span class="number">-06</span> <span class="number">2006</span><span class="number">-11</span><span class="number">-03</span> <span class="number">34000</span></span><br><span class="line"><span class="number">2006</span><span class="number">-11</span><span class="number">-06</span> <span class="number">2006</span><span class="number">-11</span><span class="number">-04</span> <span class="number">-5000</span>  …S4 ： <span class="number">36200</span></span><br><span class="line"><span class="number">2006</span><span class="number">-11</span><span class="number">-06</span> <span class="number">2006</span><span class="number">-11</span><span class="number">-06</span> <span class="number">7200</span></span><br><span class="line"></span><br><span class="line"><span class="number">2006</span><span class="number">-11</span><span class="number">-11</span> <span class="number">2006</span><span class="number">-11</span><span class="number">-04</span> <span class="number">-5000</span></span><br><span class="line"><span class="number">2006</span><span class="number">-11</span><span class="number">-11</span> <span class="number">2006</span><span class="number">-11</span><span class="number">-06</span> <span class="number">7200</span>   …S5 ： <span class="number">13200</span></span><br><span class="line"><span class="number">2006</span><span class="number">-11</span><span class="number">-11</span> <span class="number">2006</span><span class="number">-11</span><span class="number">-11</span> <span class="number">11000</span></span><br></pre></td></tr></table></figure>
<p>像上面这样展开后，我们发现，这里的思路与冯・诺依曼型递归集合一样，生成了几个集合。只不过，这些集合间的关系不是嵌套，而是存在交集，又有一点 “偏移”。而且，集合 S3 刚好与所有集合都有交集。</p>
<img data-src="/2020/09/01/sql/subquery05.png" class="">
<p>通过将这个集合簇与冯・诺依曼型同心圆式嵌套集合进行对比，我们可以明白，集合的生成方式是多种多样的，也是非常有趣的。如果自连接的关键字是 “嵌套（递归）”，那么这里的关键字可以暂定为 “偏移”。</p>
<h3 id="查询重叠的时间区间"><a class="markdownIt-Anchor" href="#查询重叠的时间区间">#</a> 查询重叠的时间区间</h3>
<p>表 Reservations，记录了酒店或者旅馆的预约情况。 这张表里没有房间编号，请把表中数据当成是某一房间在某段期间内的预约情况。那么，正常情况下，每天只能有一组客人在该房间住宿。从表中数据可以看出，这里存在重叠的预定日期。</p>
<img data-src="/2020/09/01/sql/subquery08.png" class="">
<img data-src="/2020/09/01/sql/subquery09.png" class="">
<img data-src="/2020/09/01/sql/subquery07.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 求重叠的住宿期间</span></span><br><span class="line"><span class="keyword">SELECT</span> reserver, start_date, end_date</span><br><span class="line">  <span class="keyword">FROM</span> Reservations R1</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">       (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">          <span class="keyword">FROM</span> Reservations R2</span><br><span class="line">         <span class="keyword">WHERE</span> R1.reserver <span class="operator">&lt;&gt;</span> R2.reserver  <span class="comment">-- 与自己以外的客人进行比较</span></span><br><span class="line">           <span class="keyword">AND</span> ( R1.start_date <span class="keyword">BETWEEN</span> R2.start_date <span class="keyword">AND</span> R2.end_date    <span class="comment">-- 条件（1）：自己的入住日期在他人的住宿期间内</span></span><br><span class="line">              <span class="keyword">OR</span> R1.end_date  <span class="keyword">BETWEEN</span> R2.start_date <span class="keyword">AND</span> R2.end_date));  <span class="comment">-- 条件（2）：自己的离店日期在他人的住宿期间内</span></span><br><span class="line"></span><br><span class="line">reserver start_date end_date</span><br><span class="line"><span class="comment">-------- ---------- ----------</span></span><br><span class="line">荒木      <span class="number">2006</span><span class="number">-10</span><span class="number">-28</span> <span class="number">2006</span><span class="number">-10</span><span class="number">-31</span></span><br><span class="line">堀　      <span class="number">2006</span><span class="number">-10</span><span class="number">-31</span> <span class="number">2006</span><span class="number">-11</span><span class="number">-01</span></span><br><span class="line">山本      <span class="number">2006</span><span class="number">-11</span><span class="number">-03</span> <span class="number">2006</span><span class="number">-11</span><span class="number">-04</span></span><br><span class="line">内田      <span class="number">2006</span><span class="number">-11</span><span class="number">-03</span> <span class="number">2006</span><span class="number">-11</span><span class="number">-05</span></span><br></pre></td></tr></table></figure>
<p>如果山本的入住日期不是 11 月 3 号，而是推迟了一天，即 11 月 4 号，那么查询结果里将不会出现内田。这是因为，内田的入住日期和离店日期都不再与任何人重叠，于是条件 (1) 和条件 (2) 就都不满足了。换句话说，像内田这种自己的住宿期间完全包含了他人的住宿期间的情况，会被这条 SQL 语句排除掉。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 升级版：把完全包含别人的住宿期间的情况也输出</span></span><br><span class="line"><span class="keyword">SELECT</span> reserver, start_date, end_date</span><br><span class="line"> <span class="keyword">FROM</span> Reservations R1</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">       (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">          <span class="keyword">FROM</span> Reservations R2</span><br><span class="line">         <span class="keyword">WHERE</span> R1.reserver <span class="operator">&lt;&gt;</span> R2.reserver</span><br><span class="line">           <span class="keyword">AND</span> (  (     R1.start_date <span class="keyword">BETWEEN</span> R2.start_date <span class="keyword">AND</span> R2.end_date</span><br><span class="line">                     <span class="keyword">OR</span> R1.end_date   <span class="keyword">BETWEEN</span> R2.start_date <span class="keyword">AND</span> R2.end_date)</span><br><span class="line">                <span class="keyword">OR</span> (    R2.start_date <span class="keyword">BETWEEN</span> R1.start_date <span class="keyword">AND</span> R1.end_date</span><br><span class="line">                    <span class="keyword">AND</span> R2.end_date   <span class="keyword">BETWEEN</span> R1.start_date <span class="keyword">AND</span> R1.end_date)));</span><br></pre></td></tr></table></figure>
<h2 id="用-sql-进行集合运算"><a class="markdownIt-Anchor" href="#用-sql-进行集合运算">#</a> 用 SQL 进行集合运算</h2>
<h3 id="集合运算的几个注意事项"><a class="markdownIt-Anchor" href="#集合运算的几个注意事项">#</a> 集合运算的几个注意事项</h3>
<p>注意事项 1： SQL 能操作具有重复行的集合，可以通过可选项 ALL 来支持<br>
一般的集合论是不允许集合里存在重复元素的，因此集合 {1, 1, 2, 3, 3,3} 和集合 {1, 2, 3} 被视为相同的集合。但是关系数据库里的表允许存在重复行，称为多重集合（multiset, bag）。因此，SQL 的集合运算符也提供了允许重复和不允许重复的两种用法。如果直接使用 UNION 或 INTERSECT，结果里就不会出现重复的行。如果想在结果里留下重复行，可以加上可选项 ALL，写作 UNION ALL。 ALL 的作用和 SELECT 子句里的 DISTINCT 可选项刚好相反。但是，不知道为什么，SQL 并不支持 UNION DISTINCT 这样的写法。除了运算结果以外，这两种用法还有一个不同。集合运算符为了排除<br>
掉重复行，默认地会发生排序，而加上可选项 ALL 之后，就不会再排序，所以性能会有提升。这是非常有效的用于优化查询性能的方法，所以如果不关心结果是否存在重复行，或者确定结果里不会产生重复行，加上可选项 ALL 会更好些。</p>
<p>注意事项 2：集合运算符有优先级<br>
标准 SQL 规定， INTERSECT 比 UNION 和 EXCEPT 优先级更高。因此，当同时使用 UNION 和 INTERSECT，又想让 UNION 优先执行时，必须用括<br>
号明确地指定运算顺序</p>
<p>注意事项 3：各个 DBMS 提供商在集合运算的实现程度上参差不齐<br>
前面说过，早期的 SQL 对集合运算的支持程度不是很高。受到这一点影响，各个数据库提供商的实现程度也参差不齐。 SQL Server 从 2005 版开始支持 INTERSECT 和 EXCEPT，而 MySQL 还都不支持（包含在 “中长期计划” 里）。还有像 Oracle 这样，实现了 EXCEPT 功能但却命名为 MINUS 的数据库。这一点比较麻烦，因为 Oracle 用户需要在使用时将 EXCEPT 全部改写成 MINUS。</p>
<p>注意事项 4：除法运算没有标准定义</p>
<p>四则运算里的和（UNION）、差（EXCEPT）、积（CROSS JOIN）都被引 入了标准 SQL。但是很遗憾，商（DIVIDE BY）因为各种原因迟迟没能标<br>
准化。因此，现阶段我们需要自己写 SQL 语句来实现除法运算。</p>
<h3 id="比较表和表-检查集合相等性"><a class="markdownIt-Anchor" href="#比较表和表-检查集合相等性">#</a> 比较表和表 ： 检查集合相等性</h3>
<img data-src="/2020/09/01/sql/set01.png" class="">
<p>在集合论里，判定两个集合是否相等时，一般使用下面两种方法。<br>
1. (A  ∩ B )  且  (A ∩  B) ⇔ (A = B) <br>
2. (A ∪ B ) = (A ∩ B) ⇔ (A = B)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 比较表和表：（在Oracle中使用 Minus）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">                     <span class="keyword">THEN</span> <span class="string">&#x27;相等&#x27;</span></span><br><span class="line">                     <span class="keyword">ELSE</span> <span class="string">&#x27;不相等&#x27;</span> <span class="keyword">END</span> <span class="keyword">AS</span> <span class="keyword">result</span></span><br><span class="line">  <span class="keyword">FROM</span> ((<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span>  tbl_A</span><br><span class="line">         <span class="keyword">UNION</span></span><br><span class="line">         <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span>  tbl_B)</span><br><span class="line">         <span class="keyword">EXCEPT</span></span><br><span class="line">        (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span>  tbl_A</span><br><span class="line">         <span class="keyword">INTERSECT</span></span><br><span class="line">         <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span>  tbl_B)) TMP;</span><br></pre></td></tr></table></figure>
<h3 id="用差集实现关系除法运算"><a class="markdownIt-Anchor" href="#用差集实现关系除法运算">#</a> 用差集实现关系除法运算</h3>
<p>从表 EmpSkills 中找出精通表 Skills 中所有技术的员工。也就是说，答案是相田和神崎。平井很可惜，会的技术很多，但是不会 Java，所以落选了。</p>
<img data-src="/2020/09/01/sql/set02.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用求差集的方法进行关系除法运算（有余数）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> emp</span><br><span class="line">  <span class="keyword">FROM</span> EmpSkills ES1</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">        (<span class="keyword">SELECT</span> skill</span><br><span class="line">           <span class="keyword">FROM</span> Skills</span><br><span class="line">         <span class="keyword">EXCEPT</span></span><br><span class="line">         <span class="keyword">SELECT</span> skill</span><br><span class="line">           <span class="keyword">FROM</span> EmpSkills ES2</span><br><span class="line">          <span class="keyword">WHERE</span> ES1.emp <span class="operator">=</span> ES2.emp);</span><br></pre></td></tr></table></figure>
<h3 id="寻找相等的子集"><a class="markdownIt-Anchor" href="#寻找相等的子集">#</a> 寻找相等的子集</h3>
<p>如下是 供应商及其经营的零件的表 ，找出经营的零件在种类数和种类上都完全相同的供应商组合。由表格我们可以看出，答案是 A-C 和 B-D 这两组。</p>
<img data-src="/2020/09/01/sql/set03.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 寻找相等的子集</span></span><br><span class="line"><span class="keyword">SELECT</span> SP1.sup, SP2.sup</span><br><span class="line">  <span class="keyword">FROM</span> SupParts SP1, SupParts SP2</span><br><span class="line"> <span class="keyword">WHERE</span> SP1.sup <span class="operator">&lt;</span> SP2.sup              <span class="comment">-- 生成供应商的全部组合</span></span><br><span class="line">   <span class="keyword">AND</span> SP1.part <span class="operator">=</span> SP2.part            <span class="comment">-- 条件1：经营同种类型的零件</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> SP1.sup, SP2.sup</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)    <span class="comment">-- 条件2：经营的零件种类数相同</span></span><br><span class="line">                     <span class="keyword">FROM</span> SupParts SP3</span><br><span class="line">                    <span class="keyword">WHERE</span> SP3.sup <span class="operator">=</span> SP1.sup)</span><br><span class="line">   <span class="keyword">AND</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line">                     <span class="keyword">FROM</span> SupParts SP4</span><br><span class="line">                    <span class="keyword">WHERE</span> SP4.sup <span class="operator">=</span> SP2.sup);</span><br></pre></td></tr></table></figure>
<h3 id="用于删除重复行的高效-sql"><a class="markdownIt-Anchor" href="#用于删除重复行的高效-sql">#</a> 用于删除重复行的高效 SQL</h3>
<img data-src="/2020/09/01/sql/set04.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除重复行 ：使用关联子查询</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Products</span><br><span class="line"> <span class="keyword">WHERE</span> rowid <span class="operator">&lt;</span> ( <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(P2.rowid)</span><br><span class="line">                   <span class="keyword">FROM</span> Products P2</span><br><span class="line">                  <span class="keyword">WHERE</span> Products.name <span class="operator">=</span> P2. name</span><br><span class="line">                    <span class="keyword">AND</span> Products.price <span class="operator">=</span> P2.price ) ;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用于删除重复行的高效SQL语句（1）：通过EXCEPT求补集</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Products</span><br><span class="line"> <span class="keyword">WHERE</span> rowid <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> rowid</span><br><span class="line">                    <span class="keyword">FROM</span> Products</span><br><span class="line">                  <span class="keyword">EXCEPT</span></span><br><span class="line">                  <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(rowid)</span><br><span class="line">                    <span class="keyword">FROM</span> Products</span><br><span class="line">                   <span class="keyword">GROUP</span> <span class="keyword">BY</span> name, price);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除重复行的高效SQL语句（2）：通过NOT IN求补集</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Products</span><br><span class="line"> <span class="keyword">WHERE</span> rowid <span class="keyword">NOT</span> <span class="keyword">IN</span> ( <span class="keyword">SELECT</span> <span class="built_in">MAX</span>(rowid)</span><br><span class="line">                        <span class="keyword">FROM</span> Products</span><br><span class="line">                       <span class="keyword">GROUP</span> <span class="keyword">BY</span> name, price);</span><br></pre></td></tr></table></figure>
<h2 id="exists-谓词的用法"><a class="markdownIt-Anchor" href="#exists-谓词的用法">#</a> EXISTS 谓词的用法</h2>
<h3 id="什么是谓词"><a class="markdownIt-Anchor" href="#什么是谓词">#</a> 什么是谓词</h3>
<p>SQL 的保留字中，有很多都被归为谓词一类。例如，“=、 &lt;、&gt;” 等比 较谓词，以及 BETWEEN、 LIKE、 IN、 IS NULL 等。在写 SQL 语句时我们几乎离不开这些谓词，那么到底什么是谓词呢？ 用一句话来说，谓词就是函数。当然，谓词与 SUM 或 AVG 这样的函数并不一样，否则就无需再分出谓词这一类，而是统一都叫作函数了。实际上，谓词是一种特殊的函数，返回值是真值。前面提到的每个谓词，返回值都是 true、 false 或者 unknown（一般的谓词逻辑里没有 unknown，但是 SQL 采用的是三值逻辑，因此具有三种真值）。 谓词逻辑提供谓词是为了判断命题（可以理解成陈述句）的真假。例如，我们假设存在 “x 是男的” 这样的谓词，那么我们只要指定 x 为 “小明” 或者 “小红”，就能判断命题 “小明是男的”“小红是男的” 是真命题还是假命题。在谓词逻辑出现之前，命题逻辑中并没有像这样能够深入调查命题内部的工具。谓词逻辑的出现具有划时代的意义，原因就在于为命题分析提供了函数式的方法 。</p>
<p>在关系数据库里，表中的一行数据可以看作是一个命题。</p>
<img data-src="/2020/09/01/sql/exists01.png" class="">
<p>例如，这张表里第一行数据就可以认为表示这样一个命题：田中性别是男，而且年龄是 28 岁。表常常被认为是行的集合，但从谓词逻辑的观点看，也可以认为是命题的集合（＝陈述句的集合）。 C.J. Date 曾经这样调侃过：数据库这种叫法有点名不副实，它存储的与其说是数据，还不如说是命题 。</p>
<p>同样，我们平时使用的 WHERE 子句，其实也可以看成是由多个谓词组合而成的新谓词。只有能让 WHERE 子句的返回值为真的命题，才能从表（命<br>
题的集合）中查询到。</p>
<h3 id="实体的阶层"><a class="markdownIt-Anchor" href="#实体的阶层">#</a> 实体的阶层</h3>
<p>同样是谓词，但是与 =、 BETWEEN 等相比， EXISTS 的用法还是大不相同的。概括来说，区别在于 “谓词的参数可以取什么值”。EXISTS 参数是行数据的集合。之所以这么说，是因为无论子查询中选择什么样的列，对于 EXISTS 来说都是一样的。在 EXISTS 的子查询里，SELECT 子句的列表可以有下面这三种写法。</p>
<ol>
<li>通配符： SELECT *</li>
<li>常量： SELECT ‘这里的内容任意’</li>
<li>列名： SELECT col</li>
</ol>
<p>但是，不管采用上面这三种写法中的哪一种，得到的结果都是一样的。</p>
<img data-src="/2020/09/01/sql/exists02.png" class="">
<p>从上面的图表我们可以知道， EXISTS 的特殊性在于输入值的阶数（输出值和其他谓词一样，都是真值）。谓词逻辑中，根据输入值的阶数对谓词进行分类。 = 或者 BETWEEEN 等输入值为一行的谓词叫作 “一阶谓词”，而像 EXISTS 这样输入值为行的集合的谓词叫作 “二阶谓词”。阶（order）是用来区分集合或谓词的阶数的概念。</p>
<h3 id="全称量化和存在量化"><a class="markdownIt-Anchor" href="#全称量化和存在量化">#</a> 全称量化和存在量化</h3>
<p>从这些我们可以知道，形式语言没必要同时显式地支持 EXISTS 和 FORALL 两者。但是实际上，我们希望同时支持这两者，因为有些问题适合使用 EXISTS 来解决，而有的问题适合使用 FORALL。例如， SQL 支持 EXISTS，不支持 FORALL。于是会有一些查询只能选择用 EXISTS，那么代码写起来就会非常麻烦。 —C.J. Date</p>
<p>谓词逻辑中有量词（限量词、数量词）这类特殊的谓词。我们可以用它们来表达一些这样的命题：“所有的 x 都满足条件 P” 或者 “存在（至少 一个）满足条件 P 的 x”。前者称为 “全称量词”，后者称为 “存在量词”，分别记作 ∀、 ∃。这两个符号看起来很奇怪。其实，全称量词的符号其实是将字母 A 上下颠倒而形成的，存在量词则是将字母 E 左右颠倒而形成的。“对于所有的 x，……” 的英语是 “for All x， …”，而 “存在满足…… 的 x” 的英语是 “there Exists x that…”，这就是这两个符号的由来。也许大家已经明白了， SQL 中的 EXISTS 谓词实现了谓词逻辑中的存在量词。然而遗憾的是，对于与本节核心内容有关的另一个全称量词，SQL 却并没有予以实现。 C.J. Date 在自己的书里写了 FORALL 谓词，但实际上 SQL 里并没有这个实现。但是没有全称量词并不算是 SQL 的致命缺陷。因为全称量词和存在量词只要定义了一个，另一个就可以被推导出来。具体可以参考下面这个等价改写的规则（德・摩根定律）。</p>
<img data-src="/2020/09/01/sql/exists03.png" class="">
<p>因此在 SQL 中，为了表达全称量化，需要将 “所有的行都满足条件 P” 这样的命题转换成 “不存在不满足条件 P 的行”。就像 C.J. Date 所说，虽然 SQL 里有全称量词会很方便，但是既然 SQL 并没有实现它，我们也就没有办法了。</p>
<h3 id="查询表中不存在的数据"><a class="markdownIt-Anchor" href="#查询表中不存在的数据">#</a> 查询表中 “不” 存在的数据</h3>
<img data-src="/2020/09/01/sql/exists04.png" class="">
<p>从这张表中求出 “参加了某次会议的人” 是很容易的。但是，如果反过来求 “没有参加某次会议的人”，该怎么做呢？例如，伊藤参加了第 1 次会议和第 2 次会议，但是没有参加第 3 次会议；坂东没有参加第 2 次会议。也就是说，目标结果如下所示，是各次会议缺席者的列表。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">meeting    person</span><br><span class="line"><span class="comment">---------- --------</span></span><br><span class="line">第 <span class="number">1</span> 次    宫田</span><br><span class="line">第 <span class="number">2</span> 次    坂东</span><br><span class="line">第 <span class="number">2</span> 次    水岛</span><br><span class="line">第 <span class="number">3</span> 次    伊藤</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用于求出缺席者的SQL语句（1）：存在量化的应用</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> M1.meeting, M2.person</span><br><span class="line">  <span class="keyword">FROM</span> Meetings M1 <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> Meetings M2</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">        (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">           <span class="keyword">FROM</span> Meetings M3</span><br><span class="line">          <span class="keyword">WHERE</span> M1.meeting <span class="operator">=</span> M3.meeting</span><br><span class="line">            <span class="keyword">AND</span> M2.person <span class="operator">=</span> M3.person);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用于求出缺席者的SQL语句（2）：使用差集运算</span></span><br><span class="line"><span class="keyword">SELECT</span> M1.meeting, M2.person</span><br><span class="line">  <span class="keyword">FROM</span> Meetings M1, Meetings M2</span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> meeting, person</span><br><span class="line">  <span class="keyword">FROM</span> Meetings;</span><br></pre></td></tr></table></figure>
<h3 id="全称量化-1-习惯肯定-双重否定之间的转换"><a class="markdownIt-Anchor" href="#全称量化-1-习惯肯定-双重否定之间的转换">#</a> 全称量化 (1) ：习惯 “肯定 ⇔ 双重否定” 之间的转换</h3>
<img data-src="/2020/09/01/sql/exists05.png" class="">
<p>查询出 “所有科目分数都在 50 分以上的学生”。答案是学号分别为 100、 200、 400 的 3 人。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 全称量化（1）：习惯“肯定&lt;＝&gt;双重否定”之间的转换</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> student_id</span><br><span class="line">  <span class="keyword">FROM</span> TestScores TS1</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>  <span class="comment">-- 不存在满足以下条件的行</span></span><br><span class="line">        (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">           <span class="keyword">FROM</span> TestScores TS2</span><br><span class="line">          <span class="keyword">WHERE</span> TS2.student_id <span class="operator">=</span> TS1.student_id</span><br><span class="line">            <span class="keyword">AND</span> TS2.score <span class="operator">&lt;</span> <span class="number">50</span>);   <span class="comment">-- 分数不满50分的科目</span></span><br></pre></td></tr></table></figure>
<p>查询 “数学的分数在 80 分以上， 语文的分数在 50 分以上的学生 “</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 全称量化（1）：习惯“肯定&lt;＝&gt;双重否定”之间的转换</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> student_id</span><br><span class="line">  <span class="keyword">FROM</span> TestScores TS1</span><br><span class="line"> <span class="keyword">WHERE</span> subject <span class="keyword">IN</span> (<span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;语文&#x27;</span>)</span><br><span class="line">   <span class="keyword">AND</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">        (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">           <span class="keyword">FROM</span> TestScores TS2</span><br><span class="line">          <span class="keyword">WHERE</span> TS2.student_id <span class="operator">=</span> TS1.student_id</span><br><span class="line">            <span class="keyword">AND</span> <span class="number">1</span> <span class="operator">=</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> subject <span class="operator">=</span> <span class="string">&#x27;数学&#x27;</span> <span class="keyword">AND</span> score <span class="operator">&lt;</span> <span class="number">80</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">                         <span class="keyword">WHEN</span> subject <span class="operator">=</span> <span class="string">&#x27;语文&#x27;</span> <span class="keyword">AND</span> score <span class="operator">&lt;</span> <span class="number">50</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">                         <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>);</span><br></pre></td></tr></table></figure>
<p>排除掉没有语文分数的学号为 400 的学生。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 全称量化（1）：习惯“肯定&lt;＝&gt;双重否定”之间的转换</span></span><br><span class="line"><span class="keyword">SELECT</span> student_id</span><br><span class="line">  <span class="keyword">FROM</span> TestScores TS1</span><br><span class="line"> <span class="keyword">WHERE</span> subject <span class="keyword">IN</span> (<span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;语文&#x27;</span>)</span><br><span class="line">   <span class="keyword">AND</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">        (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">           <span class="keyword">FROM</span> TestScores TS2</span><br><span class="line">          <span class="keyword">WHERE</span> TS2.student_id <span class="operator">=</span> TS1.student_id</span><br><span class="line">            <span class="keyword">AND</span> <span class="number">1</span> <span class="operator">=</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> subject <span class="operator">=</span> <span class="string">&#x27;数学&#x27;</span> <span class="keyword">AND</span> score <span class="operator">&lt;</span> <span class="number">80</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">                         <span class="keyword">WHEN</span> subject <span class="operator">=</span> <span class="string">&#x27;语文&#x27;</span> <span class="keyword">AND</span> score <span class="operator">&lt;</span> <span class="number">50</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">                         <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>)</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> student_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">=</span> <span class="number">2</span>; <span class="comment">-- 必须两门科目都有分数</span></span><br><span class="line"></span><br><span class="line">student_id</span><br><span class="line"><span class="comment">----------</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">200</span></span><br></pre></td></tr></table></figure>
<h3 id="全称量化-2集合-vs-谓词哪个更强大"><a class="markdownIt-Anchor" href="#全称量化-2集合-vs-谓词哪个更强大">#</a> 全称量化 (2)：集合 VS 谓词 —— 哪个更强大？</h3>
<p>从这张表中查询出哪些项目已经完成到了工程 1。可以明显地看出，只完成到工程 0 的项目 AA100 以及还没有开始的项目 B200 不符合条件，而项目 CS300 符合条件。项目 DY400 已经完成到了工程 2，是否符合条件有点微妙，我们先按它不符合条件来实现。</p>
<img data-src="/2020/09/01/sql/exists06.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询完成到了工程1的项目：面向集合的解法</span></span><br><span class="line"><span class="keyword">SELECT</span> project_id</span><br><span class="line">  <span class="keyword">FROM</span> Projects</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> project_id</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">=</span> <span class="built_in">SUM</span>(<span class="keyword">CASE</span> <span class="keyword">WHEN</span> step_nbr <span class="operator">&lt;=</span> <span class="number">1</span> <span class="keyword">AND</span> status <span class="operator">=</span> <span class="string">&#x27;完成&#x27;</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">                           <span class="keyword">WHEN</span> step_nbr <span class="operator">&gt;</span> <span class="number">1</span> <span class="keyword">AND</span> status <span class="operator">=</span> <span class="string">&#x27;等待&#x27;</span> <span class="keyword">THEN</span> <span class="number">1</span></span><br><span class="line">                           <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span>);</span><br><span class="line"></span><br><span class="line">project_id</span><br><span class="line"><span class="comment">-----------</span></span><br><span class="line">CS300</span><br></pre></td></tr></table></figure>
<p>谓词逻辑的解法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询完成到了工程1的项目：谓词逻辑的解法</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Projects P1</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">        (<span class="keyword">SELECT</span> status</span><br><span class="line">           <span class="keyword">FROM</span> Projects P2</span><br><span class="line">          <span class="keyword">WHERE</span> P1.project_id <span class="operator">=</span> P2. project_id  <span class="comment">-- 以项目为单位进行条件判断</span></span><br><span class="line">            <span class="keyword">AND</span> status <span class="operator">&lt;&gt;</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> step_nbr <span class="operator">&lt;=</span> <span class="number">1</span> <span class="comment">-- 使用双重否定来表达全称量化命题</span></span><br><span class="line">                               <span class="keyword">THEN</span> <span class="string">&#x27;完成&#x27;</span></span><br><span class="line">                               <span class="keyword">ELSE</span> <span class="string">&#x27;等待&#x27;</span> <span class="keyword">END</span>);</span><br><span class="line"></span><br><span class="line">project_id  step_nbr status</span><br><span class="line"><span class="comment">----------- -------- ------</span></span><br><span class="line">CS300       <span class="number">0</span>        完成</span><br><span class="line">CS300       <span class="number">1</span>        完成</span><br><span class="line">CS300 	    <span class="number">2</span>        等待</span><br><span class="line">CS300       <span class="number">3</span>        等待</span><br></pre></td></tr></table></figure>
<p>虽然两者都能表达全称量化，但是与 HAVING 相比，使用了双重否定的 NOT EXISTS 代码看起来不是那么容易理解，这是它的缺点。但是这种写法也有优点。第一个优点是性能好。只要有一行满足条件，查询就会终止，不一定需要查询所有行的数据。而且还能通过连接条件使用 “project_id” 列的索引，这样查询起来会更快。第二个优点是结果里能包含的信息量更大。如果使用 HAVING，结果会被聚合，我们只能获取到项目 ID，而如果使用 EXISTS，则能把集合里的元素整体都获取到。</p>
<h3 id="对列进行量化查询全是-1-的行"><a class="markdownIt-Anchor" href="#对列进行量化查询全是-1-的行">#</a> 对列进行量化：查询全是 1 的行</h3>
<img data-src="/2020/09/01/sql/exists07.png" class="">
<p>查询 “都是 1” 的行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- “列方向”的全称量化：优雅的解答</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> ArrayTbl</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="number">1</span> <span class="operator">=</span> <span class="keyword">ALL</span> (col1, col2, col3, col4, col5, col6, col7, col8, col9, col10);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 上面的代码在PostgreSQL中运行时会报错。将代码改为下面这样即可成功运行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> ArrayTbl</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="number">1</span> <span class="operator">=</span> <span class="keyword">ALL</span> (<span class="keyword">values</span> (col1), (col2), (col3), (col4), (col5), (col6), (col7), (col8), (col9), (col10));</span><br></pre></td></tr></table></figure>
<p>查询 “至少有一个 9” 的行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- “列方向”的存在量化（1）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> ArrayTbl</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="number">9</span> <span class="operator">=</span> <span class="keyword">ANY</span> (col1, col2, col3, col4, col5, col6, col7, col8, col9, col10);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*上面的代码在PostgreSQL中运行时会报错。将代码改为下面这样即可成功运行</span></span><br><span class="line"><span class="comment">SELECT *</span></span><br><span class="line"><span class="comment">  FROM ArrayTbl</span></span><br><span class="line"><span class="comment"> WHERE 9 = ANY (values (col1), (col2), (col3), (col4), (col5), (col6), (col7), (col8), (col9), (col10));</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-- “列方向”的存在量化（2）</span></span><br><span class="line"><span class="comment">SELECT *</span></span><br><span class="line"><span class="comment">  FROM ArrayTbl</span></span><br><span class="line"><span class="comment"> WHERE 9 IN (col1, col2, col3, col4, col5, col6, col7, col8, col9, col10);</span></span><br></pre></td></tr></table></figure>
<p>查询全是 NULL 的行</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询全是NULL的行：正确的解法</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> ArrayTbl</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="built_in">COALESCE</span>(col1, col2, col3, col4, col5, col6, col7, col8, col9, col10) <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
<h2 id="用-sql-处理数列"><a class="markdownIt-Anchor" href="#用-sql-处理数列">#</a> 用 SQL 处理数列</h2>
<h3 id="生成连续编号"><a class="markdownIt-Anchor" href="#生成连续编号">#</a> 生成连续编号</h3>
<img data-src="/2020/09/01/sql/arr01.png" class="">
<img data-src="/2020/09/01/sql/arr02.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 求连续编号（1）：求0到99的数</span></span><br><span class="line"><span class="keyword">SELECT</span> D1.digit <span class="operator">+</span> (D2.digit <span class="operator">*</span> <span class="number">10</span>)  <span class="keyword">AS</span> seq</span><br><span class="line">  <span class="keyword">FROM</span> Digits D1, Digits D2</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> seq;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 求连续编号（2）：求1到542的数</span></span><br><span class="line"><span class="keyword">SELECT</span> D1.digit <span class="operator">+</span> (D2.digit <span class="operator">*</span> <span class="number">10</span>) <span class="operator">+</span> (D3.digit <span class="operator">*</span> <span class="number">100</span>) <span class="keyword">AS</span> seq</span><br><span class="line">  <span class="keyword">FROM</span> Digits D1, Digits D2, Digits D3</span><br><span class="line"> <span class="keyword">WHERE</span> D1.digit <span class="operator">+</span> (D2.digit <span class="operator">*</span> <span class="number">10</span>) <span class="operator">+</span> (D3.digit <span class="operator">*</span> <span class="number">100</span>) <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">542</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> seq;</span><br></pre></td></tr></table></figure>
<h3 id="求全部的缺失编号"><a class="markdownIt-Anchor" href="#求全部的缺失编号">#</a> 求全部的缺失编号</h3>
<img data-src="/2020/09/01/sql/arr03.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 生成序列视图（包含0到999）</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> Sequence (seq)</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> D1.digit <span class="operator">+</span> (D2.digit <span class="operator">*</span> <span class="number">10</span>) <span class="operator">+</span> (D3.digit <span class="operator">*</span> <span class="number">100</span>)</span><br><span class="line">     <span class="keyword">FROM</span> Digits D1, Digits D2, Digits D3;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 求所有缺失编号：EXCEPT版</span></span><br><span class="line"><span class="keyword">SELECT</span> seq</span><br><span class="line">  <span class="keyword">FROM</span> Sequence</span><br><span class="line"> <span class="keyword">WHERE</span> seq <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">12</span></span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> seq <span class="keyword">FROM</span> SeqTbl;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 求所有缺失编号：NOT IN版</span></span><br><span class="line"><span class="keyword">SELECT</span> seq</span><br><span class="line">  <span class="keyword">FROM</span> Sequence</span><br><span class="line"> <span class="keyword">WHERE</span> seq <span class="keyword">BETWEEN</span> <span class="number">1</span> <span class="keyword">AND</span> <span class="number">12</span></span><br><span class="line">   <span class="keyword">AND</span> seq <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> seq <span class="keyword">FROM</span> SeqTbl);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 动态地指定连续编号范围的SQL语句</span></span><br><span class="line"><span class="keyword">SELECT</span> seq</span><br><span class="line">  <span class="keyword">FROM</span> Sequence</span><br><span class="line"> <span class="keyword">WHERE</span> seq <span class="keyword">BETWEEN</span> (<span class="keyword">SELECT</span> <span class="built_in">MIN</span>(seq) <span class="keyword">FROM</span> SeqTbl)</span><br><span class="line">               <span class="keyword">AND</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(seq) <span class="keyword">FROM</span> SeqTbl)</span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> seq <span class="keyword">FROM</span> SeqTbl;</span><br></pre></td></tr></table></figure>
<h3 id="三个人能坐得下吗"><a class="markdownIt-Anchor" href="#三个人能坐得下吗">#</a> 三个人能坐得下吗</h3>
<img data-src="/2020/09/01/sql/arr04.png" class="">
<p>假设一共 3 个人一起去旅行，准备预订这列火车的车票。问题是，从 1 ～ 15 的座位编号中，找出连续 3 个空位的全部组合。我们把由连续<br>
的整数构成的集合，也就是连续编号的集合称为 “序列”。</p>
<img data-src="/2020/09/01/sql/arr05.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 找出需要的空位（1）：不考虑座位的换排</span></span><br><span class="line"><span class="keyword">SELECT</span> S1.seat   <span class="keyword">AS</span> start_seat, <span class="string">&#x27;～&#x27;</span> , S2.seat <span class="keyword">AS</span> end_seat</span><br><span class="line">  <span class="keyword">FROM</span> Seats S1, Seats S2</span><br><span class="line"> <span class="keyword">WHERE</span> S2.seat <span class="operator">=</span> S1.seat <span class="operator">+</span> (<span class="number">3</span> <span class="number">-1</span>)  <span class="comment">-- 决定起点和终点</span></span><br><span class="line">   <span class="keyword">AND</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">          (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">             <span class="keyword">FROM</span> Seats S3</span><br><span class="line">            <span class="keyword">WHERE</span> S3.seat <span class="keyword">BETWEEN</span> S1.seat <span class="keyword">AND</span> S2.seat</span><br><span class="line">              <span class="keyword">AND</span> S3.status <span class="operator">&lt;&gt;</span> <span class="string">&#x27;未预订&#x27;</span> )</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> start_seat;</span><br><span class="line"></span><br><span class="line">start_seat <span class="operator">~</span>  end_seat</span><br><span class="line"><span class="comment">---------  -- ----------</span></span><br><span class="line">    <span class="number">3</span>	   <span class="operator">~</span>	<span class="number">5</span></span><br><span class="line">    <span class="number">7</span>	   <span class="operator">~</span>	<span class="number">9</span></span><br><span class="line">    <span class="number">8</span>	   <span class="operator">~</span>	<span class="number">10</span></span><br><span class="line">    <span class="number">9</span> 	   <span class="operator">~</span>	<span class="number">11</span></span><br></pre></td></tr></table></figure>
<p>考虑发生换排的情况。假设这列火车每一排有 5 个座位。我们在表中加上表示行编号 “row_id” 列表示某一排的编号。</p>
<img data-src="/2020/09/01/sql/arr07.png" class="">
<img data-src="/2020/09/01/sql/arr06.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 找出需要的空位（2）：考虑座位的换排</span></span><br><span class="line"><span class="keyword">SELECT</span> S1.seat   <span class="keyword">AS</span> start_seat, <span class="string">&#x27;～&#x27;</span> , S2.seat <span class="keyword">AS</span> end_seat</span><br><span class="line">  <span class="keyword">FROM</span> Seats2 S1, Seats2 S2</span><br><span class="line"> <span class="keyword">WHERE</span> S2.seat <span class="operator">=</span> S1.seat <span class="operator">+</span> (<span class="number">3</span> <span class="number">-1</span>)  <span class="comment">--决定起点和终点</span></span><br><span class="line">   <span class="keyword">AND</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">          (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">             <span class="keyword">FROM</span> Seats2 S3</span><br><span class="line">            <span class="keyword">WHERE</span> S3.seat <span class="keyword">BETWEEN</span> S1.seat <span class="keyword">AND</span> S2.seat</span><br><span class="line">              <span class="keyword">AND</span> (    S3.status <span class="operator">&lt;&gt;</span> <span class="string">&#x27;未预订&#x27;</span></span><br><span class="line">                    <span class="keyword">OR</span> S3.row_id <span class="operator">&lt;&gt;</span> S1.row_id))</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> start_seat;</span><br><span class="line"></span><br><span class="line">start_seat <span class="operator">~</span>  end_seat</span><br><span class="line"><span class="comment">---------  -- ----------</span></span><br><span class="line">    <span class="number">3</span>	   <span class="operator">~</span>	<span class="number">5</span></span><br><span class="line">    <span class="number">8</span>	   <span class="operator">~</span>	<span class="number">10</span></span><br><span class="line">    <span class="number">11</span> 	   <span class="operator">~</span>	<span class="number">13</span></span><br></pre></td></tr></table></figure>
<h3 id="最多能坐下多少人"><a class="markdownIt-Anchor" href="#最多能坐下多少人">#</a> 最多能坐下多少人</h3>
<p>查询 “按现在的空位状况，最多能坐下多少人”。 针对表 Seats3 中的数据，要想保证从座位 A 到另一个座位 B 是一个序列，则下面的 3 个条件必须全部都满足。</p>
<ul>
<li>条件 1：起点到终点之间的所有座位状态都是 “未预订”。</li>
<li>条件 2：起点之前的座位状态不是 “未预订”。</li>
<li>条件 3：终点之后的座位状态不是 “未预订”。</li>
</ul>
<img data-src="/2020/09/01/sql/arr08.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 第一阶段：生成存储了所有序列的视图</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> Sequences (start_seat, end_seat, seat_cnt) <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> S1.seat  <span class="keyword">AS</span> start_seat,</span><br><span class="line">       S2.seat  <span class="keyword">AS</span> end_seat,</span><br><span class="line">       S2.seat <span class="operator">-</span> S1.seat <span class="operator">+</span> <span class="number">1</span> <span class="keyword">AS</span> seat_cnt</span><br><span class="line">  <span class="keyword">FROM</span> Seats3 S1, Seats3 S2</span><br><span class="line"> <span class="keyword">WHERE</span> S1.seat <span class="operator">&lt;=</span> S2.seat  <span class="comment">-- 第一步：生成起点和终点的组合</span></span><br><span class="line">   <span class="keyword">AND</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>   <span class="comment">-- 第二步：描述序列内所有点需要满足的条件</span></span><br><span class="line">       (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">          <span class="keyword">FROM</span> Seats3 S3</span><br><span class="line">         <span class="keyword">WHERE</span> (     S3.seat <span class="keyword">BETWEEN</span> S1.seat <span class="keyword">AND</span> S2.seat</span><br><span class="line">                 <span class="keyword">AND</span> S3.status <span class="operator">&lt;&gt;</span> <span class="string">&#x27;未预订&#x27;</span>)                         <span class="comment">-- 条件1的否定</span></span><br><span class="line">            <span class="keyword">OR</span>  (S3.seat <span class="operator">=</span> S2.seat <span class="operator">+</span> <span class="number">1</span> <span class="keyword">AND</span> S3.status <span class="operator">=</span> <span class="string">&#x27;未预订&#x27;</span> )    <span class="comment">-- 条件2的否定</span></span><br><span class="line">            <span class="keyword">OR</span>  (S3.seat <span class="operator">=</span> S1.seat <span class="operator">-</span> <span class="number">1</span> <span class="keyword">AND</span> S3.status <span class="operator">=</span> <span class="string">&#x27;未预订&#x27;</span> ));  <span class="comment">-- 条件3的否定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 第二阶段：求最长的序列</span></span><br><span class="line"><span class="keyword">SELECT</span> start_seat, <span class="string">&#x27;～&#x27;</span>, end_seat, seat_cnt</span><br><span class="line">  <span class="keyword">FROM</span> Sequences</span><br><span class="line"> <span class="keyword">WHERE</span> seat_cnt <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">MAX</span>(seat_cnt) <span class="keyword">FROM</span> Sequences);</span><br></pre></td></tr></table></figure>
<h3 id="单调递增和单调递减"><a class="markdownIt-Anchor" href="#单调递增和单调递减">#</a> 单调递增和单调递减</h3>
<p>求一下股价单调递增的时间区间。目标结果是 2007-01-06 ～ 2007-01-08 和 2007-01-14 ～ 2007-01-17 。</p>
<img data-src="/2020/09/01/sql/arr09.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 求单调递增的区间的SQL语句：子集也输出</span></span><br><span class="line"><span class="keyword">SELECT</span> S1.deal_date   <span class="keyword">AS</span> start_date,</span><br><span class="line">       S2.deal_date   <span class="keyword">AS</span> end_date</span><br><span class="line">  <span class="keyword">FROM</span> MyStock S1, MyStock S2</span><br><span class="line"> <span class="keyword">WHERE</span> S1.deal_date <span class="operator">&lt;</span> S2.deal_date  <span class="comment">-- 第一步：生成起点和终点的组合</span></span><br><span class="line">   <span class="keyword">AND</span>  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>                  <span class="comment">-- 第二步：描述区间内所有日期需要满足的条件</span></span><br><span class="line">           ( <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">               <span class="keyword">FROM</span> MyStock S3, MyStock S4</span><br><span class="line">              <span class="keyword">WHERE</span> S3.deal_date <span class="keyword">BETWEEN</span> S1.deal_date <span class="keyword">AND</span> S2.deal_date</span><br><span class="line">                <span class="keyword">AND</span> S4.deal_date <span class="keyword">BETWEEN</span> S1.deal_date <span class="keyword">AND</span> S2.deal_date</span><br><span class="line">                <span class="keyword">AND</span> S3.deal_date <span class="operator">&lt;</span> S4.deal_date</span><br><span class="line">                <span class="keyword">AND</span> S3.price <span class="operator">&gt;=</span> S4.price)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> start_date, end_date;</span><br><span class="line"></span><br><span class="line">start_date   end_date</span><br><span class="line"><span class="comment">------------ -------------</span></span><br><span class="line"><span class="number">2007</span><span class="number">-01</span><span class="number">-06</span>   <span class="number">2007</span><span class="number">-01</span><span class="number">-08</span></span><br><span class="line"><span class="number">2007</span><span class="number">-01</span><span class="number">-14</span>   <span class="number">2007</span><span class="number">-01</span><span class="number">-16</span></span><br><span class="line"><span class="number">2007</span><span class="number">-01</span><span class="number">-14</span>   <span class="number">2007</span><span class="number">-01</span><span class="number">-17</span></span><br><span class="line"><span class="number">2007</span><span class="number">-01</span><span class="number">-16</span>   <span class="number">2007</span><span class="number">-01</span><span class="number">-17</span></span><br></pre></td></tr></table></figure>
<p>这个查询的结果里包含像 2007-01-14 ～ 2007-01-17 或 2007-01-16 ～ 2007-01-17 这样的子集。最后，我们要把这些不需要的子集排除掉。使用极值函数很容易就能实现。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--排除掉子集，只取最长的时间区间</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(start_date) <span class="keyword">AS</span> start_date,          <span class="comment">-- 最大限度地向前延伸起点</span></span><br><span class="line">       end_date</span><br><span class="line">  <span class="keyword">FROM</span>  (<span class="keyword">SELECT</span> S1.deal_date <span class="keyword">AS</span> start_date,</span><br><span class="line">                <span class="built_in">MAX</span>(S2.deal_date) <span class="keyword">AS</span> end_date  <span class="comment">-- 最大限度地向后延伸终点</span></span><br><span class="line">           <span class="keyword">FROM</span> MyStock S1, MyStock S2</span><br><span class="line">          <span class="keyword">WHERE</span> S1.deal_date <span class="operator">&lt;</span> S2.deal_date</span><br><span class="line">            <span class="keyword">AND</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">             (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">                <span class="keyword">FROM</span> MyStock S3, MyStock S4</span><br><span class="line">               <span class="keyword">WHERE</span> S3.deal_date <span class="keyword">BETWEEN</span> S1.deal_date <span class="keyword">AND</span> S2.deal_date</span><br><span class="line">                 <span class="keyword">AND</span> S4.deal_date <span class="keyword">BETWEEN</span> S1.deal_date <span class="keyword">AND</span> S2.deal_date</span><br><span class="line">                 <span class="keyword">AND</span> S3.deal_date <span class="operator">&lt;</span> S4.deal_date</span><br><span class="line">                 <span class="keyword">AND</span> S3.price <span class="operator">&gt;=</span> S4.price)</span><br><span class="line">         <span class="keyword">GROUP</span> <span class="keyword">BY</span> S1.deal_date) TMP</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> end_date</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> start_date;</span><br></pre></td></tr></table></figure>
<h2 id="让-sql-飞起来"><a class="markdownIt-Anchor" href="#让-sql-飞起来">#</a> 让 SQL 飞起来</h2>
<h3 id="使用高效查询"><a class="markdownIt-Anchor" href="#使用高效查询">#</a> 使用高效查询</h3>
<p><strong>参数是子查询时，使用 EXISTS 代替 IN</strong></p>
<img data-src="/2020/09/01/sql/optimization01.png" class="">
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 慢</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Class_A</span><br><span class="line"> <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id</span><br><span class="line">               <span class="keyword">FROM</span> Class_B);</span><br><span class="line"><span class="comment">-- 快</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Class_A A</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">        (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">           <span class="keyword">FROM</span> Class_B B</span><br><span class="line">          <span class="keyword">WHERE</span> A.id <span class="operator">=</span> B.id);</span><br></pre></td></tr></table></figure>
<p>使用 EXISTS 时更快的原因有以下两个。</p>
<ul>
<li>如果连接列（id）上建立了索引，那么查询 Class_B 时不用查实际的表，只需查索引就可以了。</li>
<li>如果使用 EXISTS，那么只要查到一行数据满足条件就会终止查询，不用像使用 IN 时一样扫描全表。在这一点上 NOT EXISTS 也一样。</li>
</ul>
<p>当 IN 的参数是子查询时，数据库首先会执行子查询，然后将结果存储在一张临时的工作表里（内联视图），然后扫描整个视图。很多情况下这种做法都非常耗费资源。使用 EXISTS 的话，数据库不会生成临时的工作表。 在 Oracle 数据库中，如果我们使用了建有索引的列，那么即使使用 IN 也会先扫描 索引。此外，PostgreSQL 从版本 7.4 起也改善了使用子查询作为 IN 谓词参数时的查询速度。</p>
<p><strong>参数是子查询时，使用连接代替 IN</strong></p>
<p>要想改善 IN 的性能，除了使用 EXISTS，还可以使用连接。前面的查询语句就可以像下面这样 “扁平化”。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用连接代替 IN</span></span><br><span class="line"><span class="keyword">SELECT</span> A.id, A.name</span><br><span class="line">  <span class="keyword">FROM</span> Class_A A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> Class_B B</span><br><span class="line">    <span class="keyword">ON</span> A.id <span class="operator">=</span> B.id;</span><br></pre></td></tr></table></figure>
<h3 id="避免排序"><a class="markdownIt-Anchor" href="#避免排序">#</a> 避免排序</h3>
<p>与面向过程语言不同，在 SQL 语言中，用户不能显式地命令数据库进行排序操作。对用户隐藏这样的操作正是 SQL 的设计思想。但是，这样并不意味着在数据库内部也不能进行排序。其实正好相反，在数据库内部频繁地进行着暗中的排序。因此最终对于用户来说，了解都有哪些运算会进行排序很有必要（从这个意义上讲，“隐藏操作” 这个目标的实现似乎还任重道远）。</p>
<p>会进行排序的代表性的运算有下面这些。</p>
<ul>
<li>GROUP BY 子句</li>
<li>ORDER BY 子句</li>
<li>聚合函数（SU M、 COUNT、 AVG、 MAX、 MIN）</li>
<li>DISTINCT</li>
<li>集合运算符（UNION、 INTERSECT、 EXCEPT）</li>
<li>窗口函数（RANK、 ROW_NUMBER 等）</li>
</ul>
<p>** 灵活使用集合运算符的 ALL 可选项 **</p>
<p>如果不在乎结果中是否有重复数据，或者事先知道不会有重复数据，请使用 UNION ALL 代替 UNION。这样就不会进行排序了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Class_A</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Class_B;</span><br></pre></td></tr></table></figure>
<img data-src="/2020/09/01/sql/optimization02.png" class="">
<p>** 使用 EXISTS 代替 DISTINCT **</p>
<p>为了排除重复数据， DISTINCT 也会进行排序。如果需要对两张表的连接结果进行去重，可以考虑使用 EXISTS 代替 DISTINCT，以避免排序。</p>
<img data-src="/2020/09/01/sql/optimization03.png" class="">
<p>从上面的商品表 Items 中找出同时存在于销售记录表 SalesHistory 中的商品。简而言之，就是找出有销售记录的商品。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> I.item_no</span><br><span class="line">  <span class="keyword">FROM</span> Items I <span class="keyword">INNER</span> <span class="keyword">JOIN</span> SalesHistory SH</span><br><span class="line">    <span class="keyword">ON</span> I. item_no <span class="operator">=</span> SH. item_no;</span><br><span class="line"></span><br><span class="line">item_no</span><br><span class="line"><span class="comment">-------</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>更好的做法是使用 EXISTS。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> item_no</span><br><span class="line">  <span class="keyword">FROM</span> Items I</span><br><span class="line"> <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">       <span class="keyword">FROM</span> SalesHistory SH</span><br><span class="line">      <span class="keyword">WHERE</span> I.item_no <span class="operator">=</span> SH.item_no);</span><br></pre></td></tr></table></figure>
<p>** 在极值函数中使用索引（MAX/MIN） **</p>
<p>SQL 语言里有 MAX 和 MIN 两个极值函数。使用这两个函数时都会进行排序。但是如果参数字段上建有索引，则只需要扫描索引，不需要扫描整张表。以刚才的表 Items 为例来说， SQL 语句可以像下面这样写。因为 item_no 是表 Items 的唯一索引，所以效果更好。对于联合索引，只要查询条件是联合索引的第一个字段，索引就是有效的。这种方法并不是去掉了排序这一过程，而是优化了排序前的查找速度，从而减弱排序对整体性能的影响。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 这样写需要扫描全表</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(item)</span><br><span class="line">  <span class="keyword">FROM</span> Items;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 这样写能用到索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(item_no)</span><br><span class="line">  <span class="keyword">FROM</span> Items;</span><br></pre></td></tr></table></figure>
<p>** 能写在 WHERE 子句里的条件不要写在 HAVING 子句里 **</p>
<p>例如，下面两条 SQL 语句返回的结果是一样的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 聚合后使用 HAVING 子句过滤</span></span><br><span class="line"><span class="keyword">SELECT</span> sale_date, <span class="built_in">SUM</span>(quantity)</span><br><span class="line">  <span class="keyword">FROM</span> SalesHistory</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> sale_date</span><br><span class="line"><span class="keyword">HAVING</span> sale_date <span class="operator">=</span> <span class="string">&#x27;2007-10-01&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 聚合前使用 WHERE 子句过滤</span></span><br><span class="line"><span class="keyword">SELECT</span> sale_date, <span class="built_in">SUM</span>(quantity)</span><br><span class="line">  <span class="keyword">FROM</span> SalesHistory</span><br><span class="line"> <span class="keyword">WHERE</span> sale_date <span class="operator">=</span> <span class="string">&#x27;2007-10-01&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> sale_date;</span><br><span class="line"></span><br><span class="line">sale_date      <span class="built_in">sum</span>(quantity)</span><br><span class="line"><span class="comment">-------------- --------------</span></span><br><span class="line"><span class="string">&#x27;2007-10-01&#x27;</span>   <span class="number">17</span></span><br></pre></td></tr></table></figure>
<p>但是从性能上来看，第二条语句写法效率更高。原因通常有两个。第一个是在使用 GROUP BY 子句聚合时会进行排序，如果事先通过 WHERE 子句筛选出一部分行，就能够减轻排序的负担。第二个是在 WHERE 子句的条件里可以使用索引。 HAVING 子句是针对聚合后生成的视图进行筛选的，但是很多时候聚合后的视图都没有继承原表的索引结构。</p>
<p>** 在 GROUP BY 子句和 ORDER BY 子句中使用索引 **</p>
<p>一般来说， GROUP BY 子句和 ORDER BY 子句都会进行排序，来对行进行排列和替换。不过，通过指定带索引的列作为 GROUP BY 和 ORDERBY 的列，可以实现高速查询。特别是，在一些数据库中，如果操作对象的列上建立的是唯一索引，那么排序过程本身都会被省略掉。</p>
<h3 id="真的用到索引了吗"><a class="markdownIt-Anchor" href="#真的用到索引了吗">#</a> 真的用到索引了吗</h3>
<p>假设我们在一个叫作 col_1 的列上建立了索引，然后来看一看下面这条 SQL 语句。这条 SQL 语句本来是想使用索引，但实际上执行时却进行了全表扫描。很多时候，大家是否也在无意识间就这么写了呢？</p>
<p><strong>在索引字段上进行运算</strong></p>
<p>使用索引时，条件表达式的左侧应该是原始字段 。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 不会使用索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> SomeTable</span><br><span class="line"> <span class="keyword">WHERE</span> col_1 <span class="operator">*</span> <span class="number">1.1</span> <span class="operator">&gt;</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 会使用索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> SomeTable</span><br><span class="line"> <span class="keyword">WHERE</span> col_1 <span class="operator">&gt;</span> <span class="number">100</span> <span class="operator">/</span> <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--在查询条件的左侧使用函数时，也不能用到索引。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> SomeTable</span><br><span class="line"> <span class="keyword">WHERE</span> SUBSTR(col_1, <span class="number">1</span>, <span class="number">1</span>) <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>使用 IS NULL 谓词</strong><br>
通常，索引字段是不存在 NULL 的，所以指定 IS NULL 和 IS NOTNULL 的话会使得索引无法使用，进而导致查询性能低下。关于索引字段不存在 NULL 的原因，简单来说是 NULL 并不是值。非值不会被包含在值的集合中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> SomeTable</span><br><span class="line"> <span class="keyword">WHERE</span> col_1 <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>然而，如果需要使用类似 IS NOT NULL 的功能，又想用到索引，那么可以使用下面的方法，假设 “col_1” 列的最小值是 1。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--IS NOT NULL 的代替方案</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> SomeTable</span><br><span class="line"> <span class="keyword">WHERE</span> col_1 <span class="operator">&gt;</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>原理很简单，只要使用不等号并指定一个比最小值还小的数，就可以选出 col_1 中所有的值。因为 col_1 &gt; NULL 的执行结果是 unknown，所以当 “col_1” 列的值为 NULL 的行不会被选择。不过，如果要选择 “非 NULL 的行”，正确的做法还是使用 IS NOT NULL。上面这种写法意思有些容易混淆，所以也不太推荐，请只在应急的情况下使用。</p>
<p>** 使用否定形式 **</p>
<p>下面这几种否定形式不能用到索引。</p>
<ul>
<li>&lt;&gt;</li>
<li>!=</li>
<li>NOT IN</li>
</ul>
<p>因此，下面的 SQL 语句也会进行全表扫描。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> SomeTable</span><br><span class="line"> <span class="keyword">WHERE</span> col_1 <span class="operator">&lt;&gt;</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>
<p><strong>使用 OR</strong><br>
 在 col_1 和 col_2 上分别建立了不同的索引，或者建立了（col_1,col_2）这样的联合索引时，如果使用 OR 连接条件，那么要么用不到索引，要么用到了但是效率比 AND 要差很多。如果无论如何都要使用 OR，那么有一种办法是位图索引。但是这种索引的话更新数据时的性能开销会增大，所以使用之前需要权衡一下利弊。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> SomeTable</span><br><span class="line"> <span class="keyword">WHERE</span> col_1 <span class="operator">&gt;</span> <span class="number">100</span></span><br><span class="line">    <span class="keyword">OR</span> col_2 <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>使用联合索引时，列的顺序错误</strong></p>
<p>假设存在这样顺序的一个联合索引 “col_1, col_2, col_3”。这时，指定条件的顺序就很重要。联合索引中的第一列（col_1）必须写在查询条件的开头，而且索引中列的顺序不能颠倒。有些数据库里顺序颠倒后也能使用索引，但是性能还是比顺序正确时差一些。如果无法保证查询条件里列的顺序与索引一致，可以考虑将联合索引拆分为多个索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">○ <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SomeTable <span class="keyword">WHERE</span> col_1 <span class="operator">=</span> <span class="number">10</span> <span class="keyword">AND</span> col_2 <span class="operator">=</span> <span class="number">100</span> <span class="keyword">AND</span> col_3 <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">○ <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SomeTable <span class="keyword">WHERE</span> col_1 <span class="operator">=</span> <span class="number">10</span> <span class="keyword">AND</span> col_2 <span class="operator">=</span> <span class="number">100</span> ;</span><br><span class="line">× <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SomeTable <span class="keyword">WHERE</span> col_1 <span class="operator">=</span> <span class="number">10</span> <span class="keyword">AND</span> col_3 <span class="operator">=</span> <span class="number">500</span> ;</span><br><span class="line">× <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SomeTable <span class="keyword">WHERE</span> col_2 <span class="operator">=</span> <span class="number">100</span> <span class="keyword">AND</span> col_3 <span class="operator">=</span> <span class="number">500</span> ;</span><br><span class="line">× <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SomeTable <span class="keyword">WHERE</span> col_2 <span class="operator">=</span> <span class="number">100</span> <span class="keyword">AND</span> col_1 <span class="operator">=</span> <span class="number">10</span> ;</span><br></pre></td></tr></table></figure>
<p><strong>使用 LIKE 谓词进行后方一致或中间一致的匹配</strong></p>
<p>使用 LIKE 谓词时，只有前方一致的匹配才能用到索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">× <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SomeTable <span class="keyword">WHERE</span> col_1 <span class="keyword">LIKE</span> <span class="string">&#x27;%a&#x27;</span>;</span><br><span class="line">× <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SomeTable <span class="keyword">WHERE</span> col_1 <span class="keyword">LIKE</span> <span class="string">&#x27;%a%&#x27;</span>;</span><br><span class="line">○ <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SomeTable <span class="keyword">WHERE</span> col_1 <span class="keyword">LIKE</span> <span class="string">&#x27;a%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>进行默认的类型转换</strong></p>
<p>对 char 类型的 “col_1” 列指定条件的示例，默认的类型转换不仅会增加额外的性能开销，还会导致索引不可用，可以说是有百害而无一利。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">× <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SomeTable <span class="keyword">WHERE</span> col_1 <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">○ <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SomeTable <span class="keyword">WHERE</span> col_1 <span class="operator">=</span> <span class="string">&#x27;10&#x27;</span>;</span><br><span class="line">○ <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SomeTable <span class="keyword">WHERE</span> col_1 <span class="operator">=</span> <span class="built_in">CAST</span>(<span class="number">10</span>, <span class="keyword">AS</span> <span class="type">CHAR</span>(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<h3 id="减少中间表"><a class="markdownIt-Anchor" href="#减少中间表">#</a> 减少中间表</h3>
<p>** 灵活使用 HAVING 子句 **</p>
<p>对聚合结果指定筛选条件时，使用 HAVING 子句是基本原则。不习惯使用 HAVING 子句的数据库工程师可能会倾向于像下面这样先生成一张中间表，然后在 WHERE 子句中指定筛选条件。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> sale_date, <span class="built_in">MAX</span>(quantity) <span class="keyword">AS</span> max_qty</span><br><span class="line">	      <span class="keyword">FROM</span> SalesHistory</span><br><span class="line">         <span class="keyword">GROUP</span> <span class="keyword">BY</span> sale_date) TMP 没用的中间表</span><br><span class="line"> <span class="keyword">WHERE</span> max_qty <span class="operator">&gt;=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">sale_date    tot_qty</span><br><span class="line"><span class="comment">------------ ---------</span></span><br><span class="line"><span class="number">07</span><span class="number">-10</span><span class="number">-01</span>     <span class="number">10</span></span><br><span class="line"><span class="number">07</span><span class="number">-10</span><span class="number">-03</span>     <span class="number">32</span></span><br><span class="line"><span class="number">07</span><span class="number">-10</span><span class="number">-04</span>     <span class="number">22</span></span><br></pre></td></tr></table></figure>
<p>然而，对聚合结果指定筛选条件时不需要专门生成中间表，像下面这样使用 HAVING 子句就可以。HAVING 子句和聚合操作是同时执行的，所以比起生成中间表后再执行的 WHERE 子句，效率会更高一些，而且代码看起来也更简洁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sale_date, <span class="built_in">MAX</span>(quantity)</span><br><span class="line">  <span class="keyword">FROM</span> SalesHistory</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> sale_date</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">MAX</span>(quantity) <span class="operator">&gt;=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>** 需要对多个字段使用 IN 谓词时，将它们汇总到一处 **</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, state, city</span><br><span class="line">  <span class="keyword">FROM</span> Addresses1 A1</span><br><span class="line"> <span class="keyword">WHERE</span> state <span class="keyword">IN</span> (<span class="keyword">SELECT</span> state</span><br><span class="line">                   <span class="keyword">FROM</span> Addresses2 A2</span><br><span class="line">                  <span class="keyword">WHERE</span> A1.id <span class="operator">=</span> A2.id)</span><br><span class="line">  <span class="keyword">AND</span> city <span class="keyword">IN</span> (<span class="keyword">SELECT</span> city</span><br><span class="line">                 <span class="keyword">FROM</span> Addresses2 A2</span><br><span class="line">                <span class="keyword">WHERE</span> A1.id <span class="operator">=</span> A2.id);</span><br></pre></td></tr></table></figure>
<p>这段代码中用到了两个子查询。但是，如果像下面这样把字段连接在一起，那么就能把逻辑写在一处了。这样一来，子查询不用考虑关联性，而且只执行一次就可以。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Addresses1 A1</span><br><span class="line"> <span class="keyword">WHERE</span> id <span class="operator">||</span> state <span class="operator">||</span> city</span><br><span class="line">   <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id <span class="operator">||</span> state<span class="operator">||</span> city</span><br><span class="line">         <span class="keyword">FROM</span> Addresses2 A2);</span><br></pre></td></tr></table></figure>
<p>此外，如果所用的数据库实现了行与行的比较，那么我们也可以像下面这样，在 IN 中写多个字段的组合。这种方法与前面的连接字段的方法相比有两个优点。一是不用担心连接字段时出现的类型转换问题，二是这种方法不会对字段进行工，因此可以使用索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> Addresses1 A1</span><br><span class="line"> <span class="keyword">WHERE</span> (id, state, city)</span><br><span class="line">    <span class="keyword">IN</span> (<span class="keyword">SELECT</span> id, state, city</span><br><span class="line">          <span class="keyword">FROM</span> Addresses2 A2);</span><br></pre></td></tr></table></figure>
<p><strong>先进行连接再进行聚合</strong></p>
<p>连接和聚合同时使用时，先进行连接操作可以避免产生中间表。原因是，从集合运算的角度来看，连接做的是 “乘法运算”。连接表双方是一对一、一对多的关系时，连接运算后数据的行数不会增加。而且，因为在很多设计中多对多的关系都可以分解成两个一对多的关系，因此这个技巧在大部分情况下都可以使用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 通过在连接前聚合来创建一对一的关系</span></span><br><span class="line"><span class="keyword">SELECT</span> I.item_no, SH.total_qty</span><br><span class="line">  <span class="keyword">FROM</span> Items I <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span></span><br><span class="line">      (<span class="keyword">SELECT</span> item_no, <span class="built_in">SUM</span>(quantity) <span class="keyword">AS</span> total_qty</span><br><span class="line">       <span class="keyword">FROM</span> SalesHistory</span><br><span class="line">       <span class="keyword">GROUP</span> <span class="keyword">BY</span> item_no) SH</span><br><span class="line">   <span class="keyword">ON</span> I.item_no <span class="operator">=</span> SH.item_no;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 先进行一对多的连接再聚合</span></span><br><span class="line"><span class="keyword">SELECT</span> I.item_no, <span class="built_in">SUM</span>(SH.quantity) <span class="keyword">AS</span> total_qty</span><br><span class="line">  <span class="keyword">FROM</span> Items I <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> SalesHistory SH</span><br><span class="line">    <span class="keyword">ON</span> I.item_no <span class="operator">=</span> SH.item_no 一对多的连接</span><br><span class="line"> <span class="keyword">GROUP</span> <span class="keyword">BY</span> I.item_no;</span><br></pre></td></tr></table></figure>
<p><strong>合理地使用视图</strong></p>
<p>视图是非常方便的工具，相信日常工作中很多人都在频繁地使用。但是，如果没有经过深入思考就定义复杂的视图，可能会带来巨大的性能问题。特别是视图的定义语句中包含以下运算的时候， SQL 会非常低效，执行速度也会变得非常慢。</p>
<ul>
<li>聚合函数（AVG、 COUNT、 SUM、 MIN、 MAX）</li>
<li>集合运算符（UNION、 INTERSECT、 EXCEPT 等）</li>
</ul>
<p>一般来说， 要格外注意避免在视图中进行聚合操作后需要特别注意。最近越来越多的数据库为了解决视图的这个缺点，实现了物化视图（materialized view）等技术。当视图的定义变得复杂时，可以考虑使用一下。</p>

      <div class="tags">
          <a href="/tags/db/" rel="tag"><i class="ic i-tag"></i> db</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2021-05-28 09:11:07" itemprop="dateModified" datetime="2021-05-28T09:11:07+08:00">2021-05-28</time>
  </span>
</div>

      

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2020/08/17/python-setattr-dict/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giciub8ja1j20zk0m81ky.jpg" title="python setattr and dict update">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>python setattr and dict update</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2020/09/04/english-question/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipey84bjtj20zk0m8hdt.jpg" title="英语疑问句：5 种句型构建指南">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>英语疑问句：5 种句型构建指南</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#case-%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text"> CASE 表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#case-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%86%99%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text"> CASE 表达式写法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#case-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.2.</span> <span class="toc-text"> CASE 表达式注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E5%B7%B2%E6%9C%89%E7%BC%96%E5%8F%B7%E6%96%B9%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%96%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E5%B9%B6%E7%BB%9F%E8%AE%A1"><span class="toc-number">1.3.</span> <span class="toc-text"> 将已有编号方式转换为新的方式并统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%B8%80%E6%9D%A1-sql-%E8%AF%AD%E5%8F%A5%E8%BF%9B%E8%A1%8C%E4%B8%8D%E5%90%8C%E6%9D%A1%E4%BB%B6%E7%9A%84%E7%BB%9F%E8%AE%A1"><span class="toc-number">1.4.</span> <span class="toc-text"> 用一条 SQL 语句进行不同条件的统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8-check-%E7%BA%A6%E6%9D%9F%E5%AE%9A%E4%B9%89%E5%A4%9A%E4%B8%AA%E5%88%97%E7%9A%84%E6%9D%A1%E4%BB%B6%E5%85%B3%E7%B3%BB"><span class="toc-number">1.5.</span> <span class="toc-text"> 用 CHECK 约束定义多个列的条件关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-update-%E8%AF%AD%E5%8F%A5%E9%87%8C%E8%BF%9B%E8%A1%8C%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF"><span class="toc-number">1.6.</span> <span class="toc-text"> 在 UPDATE 语句里进行条件分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%8C%B9%E9%85%8D"><span class="toc-number">1.7.</span> <span class="toc-text"> 表之间的数据匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-case-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="toc-number">1.8.</span> <span class="toc-text"> 在 CASE 表达式中使用聚合函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text"> 自连接的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E6%8E%92%E5%88%97-%E6%8E%92%E5%88%97-%E7%BB%84%E5%90%88"><span class="toc-number">2.1.</span> <span class="toc-text"> 可重排列、排列、组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E8%A1%8C"><span class="toc-number">2.2.</span> <span class="toc-text"> 删除重复行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%B1%80%E9%83%A8%E4%B8%8D%E4%B8%80%E8%87%B4%E7%9A%84%E5%88%97"><span class="toc-number">2.3.</span> <span class="toc-text"> 查找局部不一致的列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">2.4.</span> <span class="toc-text"> 排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%80%BC%E9%80%BB%E8%BE%91%E5%92%8C-null"><span class="toc-number">3.</span> <span class="toc-text"> 三值逻辑和 NULL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D-null-%E4%B8%89%E5%80%BC%E9%80%BB%E8%BE%91%E8%BF%98%E6%98%AF%E5%9B%9B%E5%80%BC%E9%80%BB%E8%BE%91"><span class="toc-number">3.1.</span> <span class="toc-text"> 两种 NULL、三值逻辑还是四值逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E5%86%99%E6%88%90is-null%E8%80%8C%E4%B8%8D%E6%98%AF-null"><span class="toc-number">3.2.</span> <span class="toc-text"> 为什么必须写成 “IS NULL”，而不是 “＝ NULL”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unknown-%E7%AC%AC%E4%B8%89%E4%B8%AA%E7%9C%9F%E5%80%BC"><span class="toc-number">3.3.</span> <span class="toc-text"> unknown、第三个真值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%B0%93%E8%AF%8D%E5%92%8C-null1-%E6%8E%92%E4%B8%AD%E5%BE%8B%E4%B8%8D%E6%88%90%E7%AB%8B"><span class="toc-number">3.4.</span> <span class="toc-text"> 比较谓词和 NULL (1) ：排中律不成立</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%B0%93%E8%AF%8D%E5%92%8C-null2-case-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C-null"><span class="toc-number">3.5.</span> <span class="toc-text"> 比较谓词和 NULL (2) ：CASE 表达式和 NULL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#not-in-%E5%92%8C-not-exists-%E4%B8%8D%E6%98%AF%E7%AD%89%E4%BB%B7%E7%9A%84"><span class="toc-number">3.6.</span> <span class="toc-text"> NOT IN 和 NOT EXISTS 不是等价的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%AE%9A%E8%B0%93%E8%AF%8D%E5%92%8C-null"><span class="toc-number">3.7.</span> <span class="toc-text"> 限定谓词和 NULL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%AE%9A%E8%B0%93%E8%AF%8D%E5%92%8C%E6%9E%81%E5%80%BC%E5%87%BD%E6%95%B0%E4%B8%8D%E6%98%AF%E7%AD%89%E4%BB%B7%E7%9A%84"><span class="toc-number">3.8.</span> <span class="toc-text"> 限定谓词和极值函数不是等价的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E5%92%8C-null"><span class="toc-number">3.9.</span> <span class="toc-text"> 聚合函数和 NULL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#having-%E5%AD%90%E5%8F%A5%E7%9A%84%E5%8A%9B%E9%87%8F"><span class="toc-number">4.</span> <span class="toc-text"> HAVING 子句的力量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%BC%96%E5%8F%B7"><span class="toc-number">4.1.</span> <span class="toc-text"> 寻找缺失的编号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8-having-%E5%AD%90%E5%8F%A5%E8%BF%9B%E8%A1%8C%E5%AD%90%E6%9F%A5%E8%AF%A2-%E6%B1%82%E4%BC%97%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text"> 用 HAVING 子句进行子查询 ：求众数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8-having-%E5%AD%90%E5%8F%A5%E8%BF%9B%E8%A1%8C%E8%87%AA%E8%BF%9E%E6%8E%A5-%E6%B1%82%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text"> 用 HAVING 子句进行自连接 ：求中位数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%B8%8D%E5%8C%85%E5%90%AB-null-%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">4.4.</span> <span class="toc-text"> 查询不包含 NULL 的集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E5%85%B3%E7%B3%BB%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97%E8%BF%9B%E8%A1%8C%E8%B4%AD%E7%89%A9%E7%AF%AE%E5%88%86%E6%9E%90"><span class="toc-number">4.5.</span> <span class="toc-text"> 用关系除法运算进行购物篮分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">4.6.</span> <span class="toc-text"> 关系除法运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E9%98%9F%E5%85%A8%E4%BD%93%E7%82%B9%E5%90%8D"><span class="toc-number">4.7.</span> <span class="toc-text"> 各队，全体点名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%87%8D%E9%9B%86%E5%90%88%E4%B8%8E%E5%A4%9A%E9%87%8D%E9%9B%86%E5%90%88"><span class="toc-number">4.8.</span> <span class="toc-text"> 单重集合与多重集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%BC%96%E5%8F%B7-%E5%8D%87%E7%BA%A7%E7%89%88"><span class="toc-number">4.9.</span> <span class="toc-text"> 寻找缺失的编号 ： 升级版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E9%9B%86%E5%90%88%E8%AE%BE%E7%BD%AE%E8%AF%A6%E7%BB%86%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.10.</span> <span class="toc-text"> 为集合设置详细的条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E6%9F%A5%E9%9B%86%E5%90%88%E6%80%A7%E8%B4%A8%E6%97%B6%E7%BB%8F%E5%B8%B8%E7%94%A8%E5%88%B0%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.11.</span> <span class="toc-text"> 调查集合性质时经常用到的条件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%96%E8%BF%9E%E6%8E%A5%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text"> 外连接的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E5%A4%96%E8%BF%9E%E6%8E%A5%E8%BF%9B%E8%A1%8C%E8%A1%8C%E5%88%97%E8%BD%AC%E6%8D%A2-1%E8%A1%8C-%E5%88%97%E5%88%B6%E4%BD%9C%E4%BA%A4%E5%8F%89%E8%A1%A8"><span class="toc-number">5.1.</span> <span class="toc-text"> 用外连接进行行列转换 (1)（行 → 列）：制作交叉表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E5%A4%96%E8%BF%9E%E6%8E%A5%E8%BF%9B%E8%A1%8C%E8%A1%8C%E5%88%97%E8%BD%AC%E6%8D%A2-2%E5%88%97-%E8%A1%8C%E6%B1%87%E6%80%BB%E9%87%8D%E5%A4%8D%E9%A1%B9%E4%BA%8E%E4%B8%80%E5%88%97"><span class="toc-number">5.2.</span> <span class="toc-text"> 用外连接进行行列转换 (2)（列 → 行）：汇总重复项于一列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E4%BA%A4%E5%8F%89%E8%A1%A8%E9%87%8C%E5%88%B6%E4%BD%9C%E5%B5%8C%E5%A5%97%E5%BC%8F%E8%A1%A8%E4%BE%A7%E6%A0%8F"><span class="toc-number">5.3.</span> <span class="toc-text"> 在交叉表里制作嵌套式表侧栏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E4%B8%BA%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.4.</span> <span class="toc-text"> 作为乘法运算的连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-number">5.5.</span> <span class="toc-text"> 全外连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E5%A4%96%E8%BF%9E%E6%8E%A5%E8%BF%9B%E8%A1%8C%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97"><span class="toc-number">5.6.</span> <span class="toc-text"> 用外连接进行集合运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E5%85%B3%E8%81%94%E5%AD%90%E6%9F%A5%E8%AF%A2%E6%AF%94%E8%BE%83%E8%A1%8C%E4%B8%8E%E8%A1%8C"><span class="toc-number">6.</span> <span class="toc-text"> 用关联子查询比较行与行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%95%BF-%E5%87%8F%E5%B0%91-%E7%BB%B4%E6%8C%81%E7%8E%B0%E7%8A%B6"><span class="toc-number">6.1.</span> <span class="toc-text"> 增长、减少、维持现状</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E8%BD%B4%E6%9C%89%E9%97%B4%E6%96%AD%E6%97%B6-%E5%92%8C%E8%BF%87%E5%8E%BB%E6%9C%80%E4%B8%B4%E8%BF%91%E7%9A%84%E6%97%B6%E9%97%B4%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83"><span class="toc-number">6.2.</span> <span class="toc-text"> 时间轴有间断时 ： 和过去最临近的时间进行比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%B4%AF%E8%AE%A1%E5%80%BC%E5%92%8C%E7%A7%BB%E5%8A%A8%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="toc-number">6.3.</span> <span class="toc-text"> 移动累计值和移动平均值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E9%87%8D%E5%8F%A0%E7%9A%84%E6%97%B6%E9%97%B4%E5%8C%BA%E9%97%B4"><span class="toc-number">6.4.</span> <span class="toc-text"> 查询重叠的时间区间</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8-sql-%E8%BF%9B%E8%A1%8C%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97"><span class="toc-number">7.</span> <span class="toc-text"> 用 SQL 进行集合运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%E7%9A%84%E5%87%A0%E4%B8%AA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">7.1.</span> <span class="toc-text"> 集合运算的几个注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%A1%A8%E5%92%8C%E8%A1%A8-%E6%A3%80%E6%9F%A5%E9%9B%86%E5%90%88%E7%9B%B8%E7%AD%89%E6%80%A7"><span class="toc-number">7.2.</span> <span class="toc-text"> 比较表和表 ： 检查集合相等性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E5%B7%AE%E9%9B%86%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97"><span class="toc-number">7.3.</span> <span class="toc-text"> 用差集实现关系除法运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86"><span class="toc-number">7.4.</span> <span class="toc-text"> 寻找相等的子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E8%A1%8C%E7%9A%84%E9%AB%98%E6%95%88-sql"><span class="toc-number">7.5.</span> <span class="toc-text"> 用于删除重复行的高效 SQL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exists-%E8%B0%93%E8%AF%8D%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">8.</span> <span class="toc-text"> EXISTS 谓词的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%B0%93%E8%AF%8D"><span class="toc-number">8.1.</span> <span class="toc-text"> 什么是谓词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E7%9A%84%E9%98%B6%E5%B1%82"><span class="toc-number">8.2.</span> <span class="toc-text"> 实体的阶层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E7%A7%B0%E9%87%8F%E5%8C%96%E5%92%8C%E5%AD%98%E5%9C%A8%E9%87%8F%E5%8C%96"><span class="toc-number">8.3.</span> <span class="toc-text"> 全称量化和存在量化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%A1%A8%E4%B8%AD%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">8.4.</span> <span class="toc-text"> 查询表中 “不” 存在的数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E7%A7%B0%E9%87%8F%E5%8C%96-1-%E4%B9%A0%E6%83%AF%E8%82%AF%E5%AE%9A-%E5%8F%8C%E9%87%8D%E5%90%A6%E5%AE%9A%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.5.</span> <span class="toc-text"> 全称量化 (1) ：习惯 “肯定 ⇔ 双重否定” 之间的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E7%A7%B0%E9%87%8F%E5%8C%96-2%E9%9B%86%E5%90%88-vs-%E8%B0%93%E8%AF%8D%E5%93%AA%E4%B8%AA%E6%9B%B4%E5%BC%BA%E5%A4%A7"><span class="toc-number">8.6.</span> <span class="toc-text"> 全称量化 (2)：集合 VS 谓词 —— 哪个更强大？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%88%97%E8%BF%9B%E8%A1%8C%E9%87%8F%E5%8C%96%E6%9F%A5%E8%AF%A2%E5%85%A8%E6%98%AF-1-%E7%9A%84%E8%A1%8C"><span class="toc-number">8.7.</span> <span class="toc-text"> 对列进行量化：查询全是 1 的行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8-sql-%E5%A4%84%E7%90%86%E6%95%B0%E5%88%97"><span class="toc-number">9.</span> <span class="toc-text"> 用 SQL 处理数列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E8%BF%9E%E7%BB%AD%E7%BC%96%E5%8F%B7"><span class="toc-number">9.1.</span> <span class="toc-text"> 生成连续编号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%82%E5%85%A8%E9%83%A8%E7%9A%84%E7%BC%BA%E5%A4%B1%E7%BC%96%E5%8F%B7"><span class="toc-number">9.2.</span> <span class="toc-text"> 求全部的缺失编号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E4%BA%BA%E8%83%BD%E5%9D%90%E5%BE%97%E4%B8%8B%E5%90%97"><span class="toc-number">9.3.</span> <span class="toc-text"> 三个人能坐得下吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%9A%E8%83%BD%E5%9D%90%E4%B8%8B%E5%A4%9A%E5%B0%91%E4%BA%BA"><span class="toc-number">9.4.</span> <span class="toc-text"> 最多能坐下多少人</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E5%92%8C%E5%8D%95%E8%B0%83%E9%80%92%E5%87%8F"><span class="toc-number">9.5.</span> <span class="toc-text"> 单调递增和单调递减</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A9-sql-%E9%A3%9E%E8%B5%B7%E6%9D%A5"><span class="toc-number">10.</span> <span class="toc-text"> 让 SQL 飞起来</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%AB%98%E6%95%88%E6%9F%A5%E8%AF%A2"><span class="toc-number">10.1.</span> <span class="toc-text"> 使用高效查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%8E%92%E5%BA%8F"><span class="toc-number">10.2.</span> <span class="toc-text"> 避免排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%9F%E7%9A%84%E7%94%A8%E5%88%B0%E7%B4%A2%E5%BC%95%E4%BA%86%E5%90%97"><span class="toc-number">10.3.</span> <span class="toc-text"> 真的用到索引了吗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E4%B8%AD%E9%97%B4%E8%A1%A8"><span class="toc-number">10.4.</span> <span class="toc-text"> 减少中间表</span></a></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
        <ul>
          <li><a href="/2019/06/06/bat/" rel="bookmark" title="Window Bat">Window Bat</a></li><li><a href="/2019/06/06/oracle/" rel="bookmark" title="oracle">oracle</a></li><li><a href="/2019/06/06/python/" rel="bookmark" title="python">python</a></li><li><a href="/2019/10/12/linux-vim/" rel="bookmark" title="Vim Basic">Vim Basic</a></li><li class="active"><a href="/2020/09/01/sql/" rel="bookmark" title="sql">sql</a></li><li><a href="/2021/04/06/japanese/" rel="bookmark" title="japanese">japanese</a></li><li><a href="/2021/04/25/excel/" rel="bookmark" title="Excel Basic">Excel Basic</a></li><li><a href="/2021/05/13/r-tutorial/" rel="bookmark" title="R tutorial">R tutorial</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="江边鸟"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">江边鸟</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">256</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">1</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">41</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xoY2hlbjc0" title="https:&#x2F;&#x2F;github.com&#x2F;lhchen74"><i class="ic i-github"></i></span>
      <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLw==" title="https:&#x2F;&#x2F;music.163.com&#x2F;"><i class="ic i-cloud-music"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>About</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>friends</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2020/08/17/python-setattr-dict/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2020/09/04/english-question/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2021</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">江边鸟 @ 露の世</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2020/09/01/sql/',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
