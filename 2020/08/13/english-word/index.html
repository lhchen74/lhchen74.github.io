



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="露の世" href="https://lhchen74.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="露の世" href="https://lhchen74.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="露の世" href="https://lhchen74.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CFira%20Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="english" />


<link rel="canonical" href="https://lhchen74.github.io/2020/08/13/english-word/">



  <title>
English Word |
D E W = 露の世</title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">English Word
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2020-08-13 00:00:00">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2020-08-13T00:00:00+08:00">2020-08-13</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">D E W</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclgrvbd6j20zk0m8qv5.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicitf0kl1j20zk0m87fe.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicm0n457cj20zk0m8e81.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclj61ylzj20zk0m8b29.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1giclhfehz7j20zk0m8u0x.jpg"></li>
          <li class="item" data-background-image="https://tva4.sinaimg.cn/large/6833939bly1gicliwyw55j20zk0m8hdt.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="https://lhchen74.github.io/2020/08/13/english-word/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="江边鸟">
    <meta itemprop="description" content=", ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="露の世">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h3 id="business"><a class="markdownIt-Anchor" href="#business">#</a> Business</h3>
<blockquote>
<p>Can I move this call for tomorrow? I am stuck in another call. 我可以把这个电话挪到明天吗？我被其他电话困住了。</p>
</blockquote>
<blockquote>
<p>We had an issue with the invoice. Can you please resubmit the invoice with the correct Tax type? Please confirm once corrected invoice is submitted. 我们的发票出了问题。能否重新提交正确税种的发票？提交正确的发票后，请确认。</p>
</blockquote>
<blockquote>
<p>Kindly find the attached file of invoice and packing list for review , thanks. 请查收附件中的发票和装箱单，谢谢。</p>
</blockquote>
<blockquote>
<p>I just send 856 and 810 to you so please check do you have receive it successfully ? 我刚刚发送了 856 和 810 给你，请问你是否成功收到？</p>
</blockquote>
<blockquote>
<p>Could you please advise/confirm if you are the right person to work with? If not, could you please help forward this email to right persons?<br>
If you have any questions, please feel free to contact us, thank you.</p>
<p>你能告诉我 / 确认一下你是不是合适的合作伙伴吗？如果不是，请帮忙将此邮件转发给合适的人。<br>
如果您有任何问题，请随时与我们联系，谢谢。</p>
</blockquote>
<h3 id="cet-6"><a class="markdownIt-Anchor" href="#cet-6">#</a> CET 6</h3>
<blockquote>
<p>He was abrupt to the point of rudeness. 他唐突到了无礼的地步。</p>
<p>abrupt: 突然的；唐突的</p>
<p>rudeness: n. 无礼；粗蛮</p>
</blockquote>
<blockquote>
<p>They specified a spacious entrance hall. 他们指定要一个宽敞的门厅。</p>
<p>specify： vt. 指定；详细说明；列举；把… 列入说明书</p>
<p>spacious: adj. 宽敞的，广阔的；无边无际的</p>
</blockquote>
<blockquote>
<p>He pursed her lips in disapproval. 他撅起嘴唇表示反对。</p>
<p>purse: n. (女士) 手提袋；(国家、家庭、团体等的) 财力 vt. （嘴巴）皱起，使缩拢；撅嘴</p>
<p>lip: n. 嘴唇；边缘</p>
<p>disapproval: n. 不赞成；不喜欢</p>
</blockquote>
<blockquote>
<p>I had another spontaneous miscarriage at around the 16th to 18th week.</p>
<p>spontaneous: adj. 自发的；自然的；无意识的</p>
<p>miscarriage: n. [妇产] 流产；失败；误送</p>
</blockquote>
<blockquote>
<p>Italy has been afflicted by political corruption for decades. 几十年来，意大利一直受到政治腐败的困扰。</p>
<p>afflict： vt. 折磨；使痛苦；使苦恼</p>
<p>corruption: n. 贪污，腐败；堕落</p>
</blockquote>
<blockquote>
<p>Officers armed with a search warrant entered the apartment. 携带搜查证的警察进入了公寓。</p>
<p>officer: n. 军官，警官；公务员，政府官员；船长 vt. 指挥</p>
<p>arm: n. 手臂；武器；袖子；装备；部门 vi. 武装起来 vt. 武装；备战</p>
<p>warrant: n. 根据；证明；正当理由；委任状 vt. 保证；担保；批准；辩解</p>
</blockquote>
<h3 id="rust"><a class="markdownIt-Anchor" href="#rust">#</a> Rust</h3>
<blockquote>
<p>The main aim of lifetimes is to prevent dangling references, which cause a program to reference data <strong>other than (除了，不同于)</strong> the data it’s intended to reference. 生存期的主要目的是防止悬空引用，悬空引用导致程序引用的数据不是它打算引用的数据。</p>
</blockquote>
<blockquote>
<p>Now that you know where the lifetimes of references are and how Rust analyzes lifetimes to ensure references will always be valid. 现在您已经知道了引用的生存期在哪里，以及 Rust 如何分析生存期以确保引用始终有效。</p>
</blockquote>
<blockquote>
<p>These situations were predictable and followed a few deterministic patterns. 这些情况是可预测的，并遵循一些确定的模式。</p>
</blockquote>
<blockquote>
<p>If Rust <strong>deterministically（确切地）</strong> applies the rules but there is still <strong>ambiguity（含糊；不明确；暧昧；模棱两可的话）</strong> <strong>as to（至于，关于；就…… 而论）</strong> what lifetimes the references have, the compiler won’t guess what the lifetime of the remaining references should be. 如果 Rust 确定地应用了规则，但是对于引用的生存期仍然不明确，那么编译器不会猜测其余引用的生存期。</p>
</blockquote>
<blockquote>
<p>Where we declare and use the lifetime parameters depends on whether they’re related to the struct fields or the method parameters and return values. 我们在哪里声明和使用生存期参数取决于它们是与 struct 字段相关还是与方法参数和返回值相关。</p>
</blockquote>
<blockquote>
<p>In addition, the lifetime elision rules often make it so that lifetime annotations aren’t necessary in method signatures. 此外，生存期省略规则常常使得在方法签名中不需要生存期注释。</p>
</blockquote>
<blockquote>
<p>The Option type is a way to use Rust’s type system to express the possibility of absence. Option 类型是使用 Rust 的类型系统来表示缺失可能性的一种方式。</p>
</blockquote>
<blockquote>
<p>You might consider whether you want it to live that long, even if it could. 你可能会考虑你是否想让它活那么久，即使它可以。</p>
</blockquote>
<blockquote>
<p>Iterators handle all that logic for you, cutting down on <strong>repetitive (重复的)</strong> code you could <strong>potentially (可能地，潜在地)</strong> mess up. 迭代器为您处理所有这些逻辑，减少可能导致混乱的重复代码。</p>
</blockquote>
<blockquote>
<p>The Iterator trait only requires implementors to define one method: the next method, which returns one item of the iterator at a time wrapped in Some and, when iteration is over, returns None. 迭代器特性只要求实现者定义一个方法: next 方法，它每次返回一个包在 Some 中的迭代器项，当迭代结束时，返回 None。</p>
</blockquote>
<blockquote>
<p>It’s a bit <strong>tougher (较艰苦的 tough 的比较级)</strong> to <strong>get the hang (熟悉，掌握）</strong> of at first, but once you get a feel for the various iterator adaptors and what they do, iterators can be easier to understand. 一开始有点难掌握，但是一旦您对各种迭代器适配器及其功能有了一定的了解，迭代器就会更容易理解。</p>
</blockquote>
<blockquote>
<p>This abstracts away some of the <strong>commonplace (n. 司空见惯的事，普通的东西；老生常谈 adj. 平凡的，普通的；平庸的，陈腐的)</strong> code so it’s easier to see the concepts that are unique to this code, such as the filtering condition each element in the iterator must pass. 这样就抽象出了一些常见的代码，从而更容易看到这段代码中唯一的概念，比如迭代器中每个元素必须通过的过滤条件。</p>
</blockquote>
<blockquote>
<p>When the panic! macro executes, your program will print a failure message, unwind and clean up the stack, and then quit. This most commonly occurs when a bug of some kind has been detected and it’s not clear to the programmer how to handle the error. 当恐 panic! 宏执行后，程序将打印一条失败消息，展开并清理堆栈，然后退出。这种情况通常发生在检测到某种错误并且程序员不清楚如何处理错误的时候。</p>
</blockquote>
<blockquote>
<p>This is called a buffer overread and can lead to security <strong>vulnerabilitiesn 缺陷（vulnerability 的复数形式）；脆弱点</strong> if an attacker is able to manipulate the index in such a way as to read data they shouldn’t be allowed to that is stored after the data structure. 这被称为缓冲区超读，如果攻击者能够以某种方式操作索引，从而读取存储在数据结构之后的不允许的数据，就会导致安全漏洞。</p>
</blockquote>
<blockquote>
<p>where we <strong>deliberately 故意地；谨慎地；慎重地</strong> wrote code that would panic in order to demonstrate how to use backtraces, the way to fix the panic is to not request an element at index 99 from a vector that only contains 3 items. 为了演示如何使用 backtrace，我们特意编写了一些会产生 panic 的代码，而解决 panic 的方法是不要向只包含 3 项的向量请求索引 99 处的元素。</p>
</blockquote>
<blockquote>
<p>Because Result has these generic type parameters, we can use the Result type and the functions that the standard library has defined on it in many different situations where the successful value and error value we want to return may differ. 由于 Result 具有这些泛型类型参数，所以我们可以在许多不同的情况下使用 Result 类型和标准库在其上定义的函数，其中我们希望返回的成功值和错误值可能不同。</p>
</blockquote>
<blockquote>
<p>The File::open function needs to have a way to tell us whether it succeeded or failed and at the same time give us either the file handle or error information. This information is exactly what the Result enum conveys. File::open 函数需要有一种方法来告诉我们它是成功还是失败，同时给我们文件句柄或错误信息。这个信息正是 enum Result 所传达的。 <strong>convey vt. 传达；运输；让与</strong></p>
</blockquote>
<blockquote>
<p>When you’re writing an example to illustrate some concept, having <strong>robust 强健的；健康的；粗野的；粗鲁的</strong> error-handling code in the example can make the example less clear.</p>
</blockquote>
<blockquote>
<p>But it would be a useful enhancement to guide the user toward valid guesses and have different behavior when a user guesses a number that’s out of range <strong>versus prep. 对，对抗；与…… 相对，与…… 相比</strong> when a user types, for example, letters instead. 但是这将是一个有用的增强，可以引导用户进行有效的猜测，并且在用户猜测超出范围的数字与用户键入 (例如字母) 时具有不同的行为。</p>
</blockquote>
<blockquote>
<p>This saves compile time when you only want to build the library and saves space in the resulting compiled artifact because the tests are not included.<br>
 当您只希望构建库时，这将节省编译时间，并在结果编译工件中节省空间，因为没有包含测试。</p>
</blockquote>
<blockquote>
<p>There’s <strong>debate n. 辩论；（正式的）讨论 v. （尤指正式）讨论，辩论；仔细考虑</strong> within the testing community about whether or not private functions should be tested directly. 在测试社区中，对于是否应该直接测试私有功能存在争议。</p>
</blockquote>
<blockquote>
<p>Even though this file doesn’t contain any test functions nor did we call the setup function from anywhere. 尽管这个文件不包含任何测试函数，我们也没有从任何地方调用 setup 函数。</p>
</blockquote>
<blockquote>
<p>They use the library’s public API to test the code in the same way external code will use it. 它们使用库的公共 API 以与外部代码使用相同的方式测试代码。</p>
</blockquote>
<blockquote>
<p>References are indicated by the &amp; symbol and borrow the value they point to. They don’t have any special capabilities other than referring to data. Also, they don’t have any <strong>overhead</strong> and are the kind of pointer we use most often. 引用由 &amp; 符号表示，并借用它们指向的值。除了引用数据之外，它们没有任何特殊功能。而且，它们没有任何开销，是我们最常用的指针类型。</p>
</blockquote>
<blockquote>
<p>overhead adv. 在头顶上方，在空中；在高处 adj. 在头上方的，在空中的；地面以上的，高架的；（费用、开支等）经常的，日常的；（驱动装置）顶置式的 n. 经常性支出，运营费用（常用复数 overheads）；（用于高射投影仪的）透明胶片；（飞机的）顶舱</p>
</blockquote>
<blockquote>
<p>In Rust, which uses the concept of ownership and borrowing, an additional difference between references and smart pointers is that references are pointers that only borrow data; in contrast, in many cases, smart pointers own the data they point to. 在 Rust 中，使用了所有权和借用的概念，引用和智能指针的另一个区别是，引用是只借用数据的指针；相反，在许多情况下，智能指针拥有它们所指向的数据。</p>
</blockquote>
<blockquote>
<p>Given that the smart pointer pattern is a general design pattern used frequently in Rust, this chapter won’t cover every existing smart pointer. 鉴于智能指针模式是 Rust 中经常使用的一种通用设计模式，本章不会涵盖所有现有的智能指针。</p>
</blockquote>
<blockquote>
<p>let’s dive in. 就让我们一探究竟吧。</p>
</blockquote>
<blockquote>
<p>Having values like a single i32 on the stack, where they’re stored by default, is more appropriate in the majority of situations. 在堆栈上默认存储 i32 这样的值，在大多数情况下更合适。</p>
</blockquote>
<blockquote>
<p>in this case, we can access the data in the box similar to (the way) <strong>how we would (access the data) if</strong> this data were on the stack. 在本例中，我们可以访问盒子中的数据，就像访问堆栈中的数据一样。</p>
</blockquote>
<blockquote>
<p>Deref coercion converts such a type into a reference to another type. For example, deref coercion can convert &amp;String to &amp;str because String implements the Deref trait such that it returns str. Deref coercion 转换将此类类型转换为对另一类型的引用。例如，deref coercion 可以将 &amp; String 转换为 &amp; str，因为 String 实现了 Deref trait，并且返回 str。</p>
</blockquote>
<blockquote>
<p>When the Deref trait is defined for the types <strong>involved 有关的；卷入的；复杂的</strong>，Rust will analyze the types and use Deref::deref as many times as necessary to get a reference to match the parameter’s type. 当为所涉及的类型定义了 Deref 特征时，Rust 将分析这些类型，并根据需要多次使用 Deref::deref 来获得匹配参数类型的引用。</p>
</blockquote>
<blockquote>
<p>The number of times that Deref::deref needs to be inserted is resolved at compile time, so there is no runtime <strong>penalty n. 罚款，罚金；处罚</strong> for <strong>taking advantage of 利用</strong> deref <strong>coercion n. 强制；强迫；高压政治；威压</strong>！Deref::deref 需要插入的次数是在编译时解析的，所以没有使用 deref coercion 的运行时惩罚！</p>
</blockquote>
<blockquote>
<p>The third case is <strong>trickier 狡猾的；机警的 (网络释义 trickery = 欺骗 trickier = 更加棘手 trickiest = 最棘手)</strong>: Rust will also coerce a mutable reference to an immutable one. But the reverse is not possible: immutable references will never coerce to mutable references. Because of the borrowing rules, if you have a mutable reference, that mutable reference must be the only reference to that data. 第三种情况更棘手：Rust 还会将可变引用强制到不可变引用。但反过来是不可能的：不可变引用永远不会强制为可变引用。由于借用规则，如果您有一个可变引用，该可变引用必须是对该数据的唯一引用。</p>
</blockquote>
<blockquote>
<p>Unfortunately, it’s not <strong>straightforward adj. 简单的；坦率的；明确的；径直的 adv. 直截了当地；坦率地</strong> to disable the automatic drop functionality. Disabling drop isn’t usually necessary; the whole point of the Drop trait is that it’s taken care of automatically. 不幸的是，禁用自动删除功能并不简单。禁用 drop 通常是不必要的；Drop trait 的全部意义在于它是自动被处理的。</p>
</blockquote>
<blockquote>
<p><strong>Occasionally, however(emphasis)</strong>, you might want to clean up a value early. 然而，偶尔您可能希望尽早清除某个值。</p>
</blockquote>
<blockquote>
<p>If someone turns off the TV while others are still watching it, there would be <strong>uproar n. 骚动；喧嚣</strong> from the remaining TV watchers! 如果有人在别人还在看电视的时候关掉电视，剩下的电视观众一定会大吵一架！</p>
</blockquote>
<blockquote>
<p>The unsafe code <strong>involved 有关的；卷入的；复杂的</strong> is wrapped in a safe API, and the outer type is still immutable. 然后将不安全的代码包装在一个安全的 API 中，外部类型仍然是不可变的。</p>
</blockquote>
<blockquote>
<p>Integers are <strong>uniformly adv. 一致地</strong> <strong>distributed over 分布，分散在</strong> the range of the type, and floating point numbers are uniformly <strong>distributed adj. 分布式的，分散式的</strong> from 0 up to but not including 1. 整数均匀分布在该类型的范围内，浮点数均匀分布在 0 到但不包括 1 之间。</p>
</blockquote>
<blockquote>
<p>We can’t use chrono to tell the time for the **Solar 太阳的；日光的 **System to complete more than one full orbit around the **galactic 银河的；乳汁的 **center. 我们不能用 chrono 来判断太阳系绕银河系中心运行一周以上的时间。</p>
</blockquote>
<blockquote>
<p>Generally speaking, error handling is divided into two broad categories: exceptions and return values. Rust opts for return values. 一般来说，错误处理分为两大类：异常和返回值。Rust 选择返回值。 (broad adj. 宽的，辽阔的；显著的；大概的 n. 宽阔部分 adv. 宽阔地)</p>
</blockquote>
<blockquote>
<p>When done <strong>naively adv. 无邪地；天真烂漫地</strong>，error handling in Rust can be verbose and annoying. This article will explore those <strong>stumbling blocks 绊脚石；障</strong> and demonstrate how to use the standard library to make error handling concise and <strong>ergonomic adj. 人类环境改造学的；人类工程学的</strong>。如果在 Rust 中天真地进行错误处理，则可能是冗长和恼人的。本文将探讨这些障碍，并演示如何使用标准库使错误处理变得简洁和符合人体工程学。</p>
</blockquote>
<blockquote>
<p>As we will see, the key to ergonomic error handling is reducing the amount of <strong>explicit adj. 明确的；清楚的；直率的；详述的</strong> case analysis the programmer has to do while keeping code <strong>composable adj. 组成的</strong>。正如我们将看到的，人机工程学错误处理的关键是在保持代码可组合的同时减少程序员必须进行的显式案例分析。</p>
</blockquote>
<blockquote>
<p>I like to think of this style of error handling as similar to a <strong>bull n. 公牛</strong> running through a china shop. The bull will get to where it wants to go, but it will <strong>trample v 践踏；蔑视，伤害</strong> everything in the process. 我喜欢把这种错误处理方式看作是公牛跑过瓷器店。公牛会去它想去的地方，但在这个过程中它会践踏一切。</p>
</blockquote>
<blockquote>
<p>The first downside is that the error messages tend to clutter your code. It’s possible to define the error messages elsewhere, but unless you’re unusually disciplined, it is very tempting to embed the error message into your code. 第一个缺点是错误消息容易使代码混乱。可以在其他地方定义错误消息，但是除非您非常严格，否则很容易将错误消息嵌入到代码中。<br>
downside n. 负面，缺点；下降趋势；底侧 adj. 底侧的<br>
 clutter n. 杂乱，混乱 vt. 使凌乱；胡乱地填满<br>
 elsewhere adv. 在别处；到别处<br>
 discipline n. 学科；纪律；训练；惩罚 vt. 训练，训导；惩戒<br>
 tempt vt. 诱惑；引起；冒… 的风险；使感兴趣</p>
</blockquote>
<blockquote>
<p>Since Rust compiles to wasm, is it possible to build SPAs (Single Page Applications) purely in Rust and without writing a single line of JavaScript? The short answer is YES! Read on to learn more or visit the demo site if you can’t contain your excitement! 既然 Rust 可以编译成 wasm，那么是否有可能完全用 Rust 构建 spa (单页应用程序)，而不需要编写一行 JavaScript 代码呢？简短的回答是肯定的！请继续阅读以了解更多信息，如果您无法抑制自己的兴奋，请访问演示站点！</p>
</blockquote>
<blockquote>
<p>I’m using this example as it tests the minimal set of capabilities required to build modern SPAs. 我使用这个示例是因为它测试了构建现代 spa 所需的最小功能集。</p>
</blockquote>
<blockquote>
<p>Building UIs by composing components and passing data in a unidirectional way is a paradigm shift in the frontend world. 通过组合组件和单向传递数据来构建 ui 是前端世界的一种范式转变。</p>
<p>unidirectional: adj. 单向的；单向性的</p>
</blockquote>
<blockquote>
<p>The return keyword can be skipped and it’s very common to see code without an explicit return. If you’re returning implicitly, make sure to remove the semicolon from that line. 可以跳过 return 关键字，并且经常会看到没有显式返回的代码。如果是隐式返回，请确保删除该行中的分号。</p>
<p>explicit: adj. 明确的；清楚的；直率的；详述的</p>
<p>implicitly: adv. 含蓄地；暗中地</p>
<p>implicity: n. 不怀疑；隐晦，含蓄</p>
<p>semicolon: n. 分号</p>
</blockquote>
<blockquote>
<p>Arrow functions are a popular feature in modern JavaScript - they allow us to write functional code in a concise way. 箭头函数是现代 JavaScript 中的一个流行特性 —— 它们允许我们以简洁的方式编写函数代码。</p>
<p>concise: adj. 简明的，简洁的</p>
</blockquote>
<blockquote>
<p>Closures don’t need the type annotations most of the time, but I’ve added them here for clarity. 闭包大多数时候不需要类型注释，但是为了清晰起见，我在这里添加了它们。</p>
<p>most of the time: 绝大部分时间，在很多时候</p>
</blockquote>
<blockquote>
<p>Regarding Vec<i32>, so far we haven’t added type annotations to variables as Rust can infer the types automatically, but for collect, we need to be explicitly tell Rust that we expect a Vec<i32> output. 关于 Vec<i32>，到目前为止，我们还没有向变量添加类型注释，因为 Rust 可以自动推断类型，但是对于 collect，我们需要显式地告诉 Rust 我们希望得到 Vec<i32>输出。</p>
<p>regard: n. 注意；尊重；问候；凝视 vt. 注重，考虑；看待；尊敬；把… 看作；与… 有关 vi. 注意，注重；注视</p>
<p>regarding: prep. 关于，至于；就…… 而论 v. 看待；（以特定方式）注视；注意；听从；涉及（regard 的现在分词）</p>
</blockquote>
<blockquote>
<p>Aside from map and filter, there are ton of other useful adapters that we can use in iterators. 除了映射和过滤器，还有很多其他有用的适配器可以在迭代器中使用。</p>
<p>aside: adv. 离开，撇开；在旁边 n. 旁白；私语，悄悄话；离题的话 prep. 在… 旁边</p>
<p>aside from: 除… 以外</p>
<p>ton: n. 吨；很多，大量</p>
</blockquote>
<blockquote>
<p>The fat arrow =&gt; syntax might trip us up because of the similarities with JavaScript arrow functions but they’re unrelated. fat arrow =&gt; 语法可能会让我们出错，因为它与 JavaScript 箭头函数很相似，但它们是无关的。</p>
<p>trip: n. （尤指短程往返的）旅行；（赛跑等）赛程；（吸毒时经历的）幻觉；绊倒；错误；令人兴奋的经历；自我放纵的态度（或行动）；（机器、电路的）开关；（安全装置的）脱扣；轻捷的脚步；让人开心的奇人，奇妙有趣的经历 vi. 绊倒，跌倒；轻快地走（或跑、跳舞）；（非正式）（服用毒品后）产生幻觉；（部分电路）自动断开；作短途旅行 vt. 绊倒；（使）跌倒；触发（开关）；起（锚）；竖起（帆桁）</p>
<p>trip sb up: 把某人绊倒</p>
<p>similarity: n. 类似；相似点</p>
</blockquote>
<blockquote>
<p>Let’s take this following example in JavaScript. It’s contrived but you have probably written something like this sometime in your career. 让我们以 JavaScript 为例。这是人为的，但你可能在你的职业生涯中写过这样的东西.</p>
<p>contrive: vt. 设计；发明；图谋 vi. 谋划；设法做到</p>
<p>contrived: adj. 人为的；做作的；不自然的</p>
</blockquote>
<blockquote>
<p>We begin to see why it’s named as “pattern matching” - we take an input and see which pattern in the match arms “fits” better - It’s like the shape sorter toys that kids play with. 我们开始明白为什么它被称为 “模式匹配”—— 我们接受一个输入，然后看看 match arms 中的哪个模式更 “适合”—— 这就像孩子们玩的形状分类玩具一样。</p>
<p>sort: n. 种类；方式；品质；[计]（资料、数据的）分类，排序 vi. 分类；协调；交往 vt. 将… 分类；将… 排序；挑选出某物</p>
<p>sorter: n. 从事分类的人；分类机</p>
</blockquote>
<blockquote>
<p>We pass variables x or y or both to their respective expressions. 我们将变量 x 或 y 或两者都传递给它们各自的表达式。</p>
<p>respective: adj. 分别的，各自的</p>
<p>respectively: adv. 分别地；各自地，独自地</p>
</blockquote>
<blockquote>
<p>Pattern matching is also exhaustive - that is, it forces you to handle all the possible cases. Try removing the last match arm and Rust won’t let you compile the code. 模式匹配也是穷尽的 — 也就是说，它迫使您处理所有可能的情况。尝试删除最后一个 match arm，rust 不会让您编译代码。</p>
<p>exhaustive: adj. 详尽的；彻底的；消耗的</p>
</blockquote>
<blockquote>
<p>It is self-documenting as we can quickly see all the valid directions available in the codebase. 它是自我文档化的，因为我们可以快速地在代码库中看到所有可用的有效方向。</p>
<p>self-documenting: 自文档化</p>
<p>codebase: n. 代码库</p>
</blockquote>
<blockquote>
<p>What if we decide to support UP and DOWN in future or rename LEFT/RIGHT to PORT/STARBOARD? 如果我们决定在将来支持 UP 和 DOWN 或者将 LEFT/RIGHT 重命名为 PORT/STARBOARD 会怎样？</p>
<p>what if: 假使… 将会怎么样</p>
<p>port: n. 港口，口岸；（计算机的）端口；左舷；舱门 vi. 转向左舷 vt. 持（枪）；左转舵</p>
<p>starboard: n. （船舶或飞机的）右舷，右侧 v. 把（船或其舵）转向右 adj. （船、飞机）右舷的</p>
</blockquote>
<blockquote>
<p>Rust’s module system is surprisingly confusing and causes a lot of frustration for beginners. Rust 的模块系统令人惊讶地令人困惑，给初学者带来了很多挫折。</p>
<p>surprisingly: adv. 惊人地；出人意料地</p>
<p>confuse: vt. 使混乱；使困惑</p>
<p>confused: adj. 困惑的；混乱的；糊涂的 v. 困惑（confuse 的过去式）</p>
<p>confusing: adj. 混乱的；混淆的；令人困惑的 v. 使迷惑；使混乱不清；使困窘（confuse 的 ing 形式）</p>
<p>frustration: n. 挫折</p>
</blockquote>
<blockquote>
<p>Since Rust’s module system is quite unique, I request the reader to read this post with an open mind and resist comparing it with how modules work in other languages. 由于 Rust 的模块系统相当独特，我请求读者以开放的心态阅读这篇文章，不要将其与其他语言中的模块工作方式进行比较。</p>
<p>resist: vi. 抵抗，抗拒；忍耐 vt. 抵抗；忍耐，忍住 n. [助剂] 抗蚀剂；防染剂</p>
<p>insist: vt. 坚持，强调 vi. 坚持，强调</p>
</blockquote>
<blockquote>
<p>The first mistake that everyone makes is just because we have files like <span class="exturl" data-url="aHR0cDovL2NvbmZpZy5ycw==">config.rs</span>, health_route.rs etc, we think that these files are modules and we can import them from other files. 每个人都会犯的第一个错误只是因为我们有 <span class="exturl" data-url="aHR0cDovL2NvbmZpZy5ycw==">config.rs</span> , health_route.rs 等这样的文件，我们认为这些文件是模块，我们可以导入他们从其他文件。</p>
</blockquote>
<blockquote>
<p>We need to explicitly build the module tree in Rust, there’s no implicit mapping to file system. 我们需要在 Rust 中显式地构建模块树，没有到文件系统的隐式映射</p>
</blockquote>
<blockquote>
<p>To add a file to the module tree, we need to declare that file as a submodule using the mod keyword. The next thing that confuses people is that you would assume we declare a file as module in the same file. But we need to declare this in a different file! Since we only have <span class="exturl" data-url="aHR0cDovL21haW4ucnM=">main.rs</span> in the module tree, let’s declare <span class="exturl" data-url="aHR0cDovL2NvbmZpZy5ycw==">config.rs</span> as a submodule in <span class="exturl" data-url="aHR0cDovL21haW4ucnM=">main.rs</span>. 要向模块树中添加一个文件，需要使用 mod 关键字将该文件声明为子模块。另一件让人困惑的事情是，您可能会假设我们在同一个文件中将一个文件声明为模块。但是我们需要在一个不同的文件中声明它！因为我们只有 <span class="exturl" data-url="aHR0cDovL21haW4ucnM=">main.rs</span> 在模块树中，我们在 <span class="exturl" data-url="aHR0cDovL21haW4ucnM=">main.rs</span> 中声明 <span class="exturl" data-url="aHR0cDovL2NvbmZpZy5ycw==">config.rs</span> 作为子模块。</p>
</blockquote>
<blockquote>
<p>So in order to use a module in files that are not  <code>main.rs</code> , we should think in terms of the path necessary to reach that module in the module tree. 所以为了在非 <span class="exturl" data-url="aHR0cDovL21haW4ucnM=">main.rs</span> 中使用模块，我们应该考虑到达模块树中那个模块所需的路径。</p>
<p>in terms of: 依据；按照；在… 方面；以… 措词</p>
</blockquote>
<blockquote>
<p>The fully qualified name gets too lengthy if our file organization is multiple directories deep. 如果文件组织的深度是多个目录，那么完全限定名就会变得太长。</p>
<p>lengthy: adj. 漫长的，冗长的；啰唆的</p>
</blockquote>
<blockquote>
<p>Dependencies added to Cargo.toml are available globally to all modules inside the project. We don’t need to explicitly import or declare anything to use a dependency. 添加到 Cargo.toml 的依赖对项目中的所有模块都是全局可用的。我们不需要显式地导入或声明任何东西来使用依赖项。</p>
</blockquote>
<blockquote>
<p>For example, let’s say we added the rand crate to our project. We can use it in our code directly as: 例如，假设我们向项目中添加了 rand crate。我们可以在代码中直接使用它:</p>
<p>let’s say: 比如说（用作插入语）</p>
</blockquote>
<blockquote>
<p>If you’re new to Rust, there will be some friction initially as it requires you to reason about errors in a different way. 如果您是新手，最初会有一些摩擦，因为它要求您以不同的方式来判断错误。</p>
<p>friction: n. 摩擦，[力] 摩擦力</p>
</blockquote>
<blockquote>
<p>Let’s start with the simplest scenario where we just ignore the error. This sounds careless but has a couple of legitimate use cases: 让我们从最简单的情况开始，忽略错误。这听起来很粗心，但有几个合法的用例:</p>
<p>scenario: n. 方案；情节；剧本；设想</p>
<p>legitimate: adj. 合法的；正当的；合理的；正统的 vt. 使合法；认为正当（等于 legitimize）</p>
</blockquote>
<blockquote>
<p>We’re prototyping our code and don’t want to spend time on error handling. 我们正在构建代码原型，不想在错误处理上花费时间。</p>
<p>prototype: n. 原型；样本；标准，模范；全真模型；[电] 原型滤波网络 vt. 制作原型</p>
<p>prototyping: n. [计] 样机研究；原型设计</p>
</blockquote>
<blockquote>
<p>Note that unwrap is used in quite a lot of Rust examples to skip error handling. This is mostly done for convenience and shouldn’t be used in real code as it is. 注意，很多 Rust 示例中都使用了 unwrap 来跳过错误处理。这样做主要是为了方便，不应该在实际代码中使用。</p>
</blockquote>
<blockquote>
<p>Let’s imagine that, for this program, that file is absolutely important without which it won’t work properly. 让我们想象一下，对于这个程序，这个文件是绝对重要的，没有它它就不能正常工作。</p>
</blockquote>
<blockquote>
<p>When you don’t have enough context to handle the error, you can bubble up (propagate) the error to the caller function.</p>
<p>当您没有足够的上下文来处理错误时，您可以将错误冒泡 (传播) 给调用者函数。</p>
<p>propogate: vt. 传播；传送；繁殖；宣传 vi. 繁殖；增殖</p>
</blockquote>
<blockquote>
<p>But things got verbose as a result - our function is littered with these map_err calls. We can implement the From trait to automatically coerce the error types when we use the ? operator. 但是结果导致事情变得冗长 — 我们的函数被这些 map_err 调用弄得乱七八糟。我们可以实现 From 特征来自动强制错误类型当我们使用？操作符。</p>
<p>verbose: adj. 冗长的；啰嗦的</p>
<p>litter: n. 垃圾；轿，担架；一窝（动物的幼崽）；凌乱 vt. 乱丢；给… 垫褥草；把… 弄得乱七八糟 vi. 产仔；乱扔废弃物</p>
<p>coerce: vt. 强制，迫使</p>
</blockquote>
<blockquote>
<p>However, From trait is not magic and there are times when we need to use map_err. 然而，From trait 不是魔法，有时我们需要使用 map_err。</p>
<p>there are times: 有些时候</p>
</blockquote>
<blockquote>
<p>This works well when the information needed to convert from one error to MyCustomError can be obtained from the original error object. If not, we need to use map_err inside. 当将一个错误转换为 MyCustomError 所需的信息可以从原始错误对象获得时，这种方法可以很好地工作。如果没有，我们需要在里面使用 map_err。</p>
</blockquote>
<blockquote>
<p>We’ll be building the HomePage as a monolithic component and later decompose it into smaller reusable components. 我们将把主页构建为一个独立的组件，然后将其分解为更小的可重用组件。<br>
monolithic: adj. 整体的；巨石的，庞大的；完全统一的 n. 单块集成电路，单片电路</p>
</blockquote>
<blockquote>
<p>Quite a number of changes, but you should be able to understand most of them. 有相当多的变化，但是您应该能够理解其中的大部分。<br>
quite: adv. 很；相当；完全</p>
</blockquote>
<blockquote>
<p>The UI looks barebones as we haven’t added any styles. UI 看起来很粗糙，因为我们没有添加任何样式。<br>
adj. 贫乏的 n. 极瘦的人</p>
</blockquote>
<blockquote>
<p>For the time being, it only has one route. We’ll add more later. 目前，它只有一个路由。我们稍后会添加更多。<br>
for the time being: 暂时；暂且；目前</p>
</blockquote>
<blockquote>
<p>I found an ad-hoc solution. 我找到了一个特别的解决办法。<br>
ad-hoc: 专门</p>
</blockquote>
<blockquote>
<p>Notice how there’s a direct link between the components that need this state and the global state 请注意，需要此状态的组件与全局状态之间是如何存在直接链接的。</p>
</blockquote>
<blockquote>
<p>It definitely has some rough edges like FetchTask, lack of predictable state management and the documentation is sparse, but has potential to become a good alternative to React, Vue etc once these issues are fixed. 它确实有一些不足之处，比如 FetchTask，缺乏可预测的状态管理，文档也很稀疏，但一旦这些问题得到解决，它就有潜力成为 React、Vue 等的一个很好的替代方案。<br>
definite: adj. 一定的；确切的 definitely: adv. 清楚地，当然；明确地，肯定地<br>
 rough: adj. 粗糙的；粗略的；粗野的；艰苦的；未经加工的 vt. 使粗糙；粗暴对待；草拟 n. 艰苦；高低不平的地面；未经加工的材料；粗糙的部分 vi. 举止粗野 adv. 粗糙地；粗略地；粗暴地<br>
 sparse: adj. 稀疏的；稀少的</p>
</blockquote>
<h3 id="haskell"><a class="markdownIt-Anchor" href="#haskell">#</a> Haskell</h3>
<blockquote>
<p>This is pretty self-explanatory. We can also use several operators on one line and all the usual precedence rules are obeyed. We can use parentheses to make the precedence explicit or to change it. 这是不言自明的。我们还可以在一行中使用多个操作符，这样就会遵守通常的优先规则。我们可以使用括号使优先级显式或更改它。<br>
self-explanatory: adj. 自明的；不需加以说明的<br>
 usual: adj. 通常的，惯例的；平常的<br>
 precedence: n. 优先；居先<br>
 obey: vt. 服从，听从；按照…… 行动 vi. 服从，顺从；听话<br>
 parenthesis: /pəˈrenθəsɪs/n. 插入语，插入成分 n. 圆括号 n. 间歇，插曲<br>
 parentheses: n. parenthesis 的复数形式</p>
</blockquote>
<blockquote>
<p>Pretty cool, huh? Yeah, I know it’s not but bear with me. A little pitfall to watch out for here is negating numbers. If we want to have a negative number, it’s always best to surround it with parentheses. Doing  <code>5 * -3</code>  will make GHCI yell at you but doing  <code>5 * (-3)</code>  will work just fine. 很酷，不是吗？是的，我知道不是，但请耐心听我说。这里需要注意的一个小陷阱是数字的否定。如果我们想要一个负数，最好是用括号括起来。做  <code>5 * -3</code>  会让 GHCI 对你大喊大叫，但是  <code>5 * (-3)</code>  会正常工作。<br>
huh: int. 嗯（用于问题、建议之后）；嗯（表示没有听清楚）；啊，哈（表示轻蔑、疑问或惊异等）<br>
bear: v. 忍受，承受；不适于某事；承担责任；经得起；心怀（感情，尤指坏心情）；支撑；显示；携带；（车，船）运输； 生（孩子）；结果实，开花（正式）；拐弯；（以姓名，头衔）相称；表现；带有（标记、特征）；吹动；具有（名字或头衔）；写有；具有（相似之处或关系）；产生（利息） n. 熊；泰迪熊；（股票）卖空者；（非正式）没教养的人；体格笨重的男人；（非正式）“北极熊”（俄国的外号）；（非正式）警察；棘手的事情；脾气暴躁<br>
 pitfall: n. 陷阱，圈套；缺陷；诱惑<br>
 yell: vi. 大叫，叫喊 n. 喊声，叫声 vt. 喊叫着说</p>
</blockquote>
<blockquote>
<p>If we tried to do True == 5, GHCI would tell us that the types don’t match. Whereas + works only on things that are considered numbers, == works on any two things that can be compared. 如果我们尝试让 True == 5, GHCI 会告诉我们类型不匹配。而 + 只对被认为是数字的东西有效，== 对任何两个可以比较的东西有效。<br>
whereas: conj. 然而；鉴于 n. 序言，开场白；条件语句</p>
</blockquote>
<blockquote>
<p>You may not have known it but we’ve been using functions now all along. For instance, * is a function that takes two numbers and multiplies them. As you’ve seen, we call it by sandwiching it between them. This is what we call an infix function. Most functions that aren’t used with numbers are prefix functions. Let’s take a look at them. 你们可能不知道，但我们一直在用函数。例如，* 是一个函数，它接受两个数字并将它们相乘。正如你看到的，我们把它夹在它们中间。这就是我们所说的中缀函数。大多数不与数字一起使用的函数是前缀函数。让我们来看看它们。 ??<br>
You may not have known it: 你可能还不知道<br>
 infix: v. 把…… 植入；插入（中缀）；用力插入 adj. 中缀的 n. 中缀<br>
 sandwich: . 三明治（状物）；夹心面包片；（奶油）夹心蛋糕；教学与实习交替培训课程 v. 夹入（或挤进）…… 中间；粘合；把……… 做成三明治</p>
</blockquote>
<blockquote>
<p>Functions are usually prefix so from now on we won’t explicitly state that a function is of the prefix form, we’ll just assume it. 函数通常是前缀，所以从现在开始，我们不会明确地声明函数是前缀形式，我们只是假设它。</p>
</blockquote>
<blockquote>
<p>if a function takes two parameters, we can also call it as an infix function by surrounding it with backticks. 如果一个函数接受两个参数，我们也可以通过使用反引号将其作为中缀函数调用。<br>
backtick: 反引号</p>
</blockquote>
<blockquote>
<p>Lots of people who come from imperative languages tend to stick to the notion that parentheses should denote function application. 许多来自命令式语言的人倾向于坚持圆括号应该表示函数应用程序的概念。<br>
imperative: adj. 必要的，不可避免的；紧急的；命令的，专横的；势在必行的；[语] 祈使的 n. 必要的事；命令；需要；规则；[语] 祈使语气<br>
 notion: n. 概念；见解；打算<br>
 denote: vt. 表示，指示</p>
</blockquote>
<blockquote>
<p>This is a very simple example of a common pattern you will see throughout Haskell. Making basic functions that are obviously correct and then combining them into more complex functions. This way you also avoid repetition. What if some mathematicians figured out that 2 is actually 3 and you had to change your program? You could just redefine doubleMe to be x + x + x and since doubleUs calls doubleMe, it would automatically work in this strange new world where 2 is 3. 这是 Haskell 中常见模式的一个非常简单的例子。生成明显正确的基本函数，然后将它们组合成更复杂的函数。这样你也可以避免重复。如果一些数学家发现 2 实际上是 3 而你不得不改变你的程序呢？你可以重新定义 doubleMe 为 x + x + x 由于 doubleUs 称它为 doubleMe，它会自动在这个 2 = 3 的奇怪新世界中工作。<br>
throughout: adv. 自始至终；遍及 prep. 自始至终；遍及<br>
 repetition: n. 重复；背诵；副本<br>
 mathematician: n. 数学家</p>
</blockquote>
<blockquote>
<p>Now we’re going to make a function that multiplies a number by 2 but only if that number is smaller than or equal to 100 because numbers bigger than 100 are big enough as it is! 现在我们要做一个函数它将一个数乘以 2 但前提是这个数小于或等于 100 因为大于 100 的数已经足够大了！</p>
</blockquote>
<blockquote>
<p>However, putting something at the beginning of a list using the : operator (also called the cons operator) is instantaneous. 但是，使用：操作符 (也称为 cons 操作符) 将一些内容放在列表的开头是即时的。<br>
instantaneous: adj. 瞬间的；即时的；猝发的</p>
</blockquote>
<blockquote>
<p>To make a list containing all the natural numbers from 1 to 20, you just write [1…20]. That is the equivalent of writing [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20] and there’s no difference between writing one or the other except that writing out long enumeration sequences manually is stupid. 要制作一个包含从 1 到 20 所有自然数的列表，只需编写 [1…20]。这和写 [1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20] 是等价的，写一个或另一个没有区别除了手动写长枚举序列是愚蠢的。</p>
</blockquote>
<blockquote>
<p>Although it’s simpler to just use the replicate function if you want some number of the same element in a list. 不过，如果您想要列表中有一定数量的相同元素，那么只使用复制函数会更简单。<br>
although: conj. 尽管，虽然；但是，然而<br>
 replicate: vt. 复制；折叠 vi. 重复；折转 adj. 复制的；折叠的 n. 复制品；八音阶间隔的反覆音</p>
</blockquote>
<blockquote>
<p>Everything in Haskell has a type, so the compiler can reason quite a lot about your program before compiling it. Haskell 中的所有东西都有一个类型，所以编译器在编译程序之前可以对它进行很多推断。<br>
reason: n. 理由；理性；动机 vi. 推论；劝说 vt. 说服；推论；辩论</p>
</blockquote>
<blockquote>
<p>We’ll do that by using the :t command which, followed by any valid expression, tells us its type. Let’s give it a whirl. 我们将使用:t 命令，后面跟着任何有效表达式，告诉我们它的类型。让我们试一试。<br>
whirl: v. （使）旋转，回旋；（使）急转，飞跑；（头脑、思想）混乱，恍惚；（思绪）接连不断 n. 旋转，回旋；一连串的事或活动；短暂的旅行；螺旋状的糖果（或饼干）<br>
give it a whirl: 试一下</p>
</blockquote>
<blockquote>
<p>Tuples are types but they are dependent on their length as well as the types of their components, so there is theoretically an infinite number of tuple types, which is too many to cover in this tutorial. Note that the empty tuple () is also a type which can only have a single value: (). 元组是类型，但它们依赖于它们的长度以及它们的组件的类型，因此理论上有无限多的元组类型，这太多了，本教程无法介绍。注意，空 tuple () 也是一种类型，它只能有一个值：()。</p>
</blockquote>
<blockquote>
<p>the equality operator, == is a function. So are +, *, -, /and pretty much all operators. If a function is comprised only of special characters, it’s considered an infix function by default. If we want to examine its type, pass it to another function or call it as a prefix function, we have to surround it in parentheses. 相等运算符 == 是一个函数。+、*、-、/ 以及几乎所有的操作符也是如此。如果一个函数只由特殊字符组成，默认情况下它被认为是中缀函数。如果我们想检查它的类型、将它传递给另一个函数或将它作为前缀函数调用，我们必须将它括在括号中。<br>
comprise: vt. 包含；由… 组成</p>
</blockquote>
<blockquote>
<p>Any type where it makes sense to test for equality between two values of that type should be a member of the Eq class. 有必要测试该类型的两个值是否相等的任何类型都应该是 Eq 类的成员。??</p>
</blockquote>
<blockquote>
<p>So far so good. 到目前为止一切顺利。</p>
</blockquote>
<blockquote>
<p>Most expressions are such that the compiler can infer what their type is by itself. 大多数表达式都是这样的，编译器可以自己推断出它们的类型。</p>
</blockquote>
<blockquote>
<p>Without pattern matching, we’d have to make a pretty convoluted if then else tree. 没有模式匹配，我们就必须做出一个非常复杂的 if then else 树。<br>
convolute: v. 回旋；盘旋；卷绕 adj. 回旋状的；旋绕的 n. 盘旋面<br>
 convoluted: adj. 复杂的；费解的；旋绕的 v. 盘绕；缠绕（convolute 的过去分词）</p>
</blockquote>
<blockquote>
<p>But in a nutshell, this is what happens if we try to get the factorial of, say, 3. It tries to compute 3 * factorial 2.<br>
nutshell: n. 坚果的外壳；小的东西，小容器 vt. 概括</p>
</blockquote>
<blockquote>
<p>This is very reminiscent of a big if else tree in imperative languages, only this is far better and more readable. While big if else trees are usually frowned upon, sometimes a problem is defined in such a discrete way that you can’t get around them. 这很容易让人联想到命令式语言中的大型 if else 树，只是这样更好，可读性更好。虽然大型 if else 树通常不受欢迎，但有时一个问题的定义是如此离散的，以至于你无法绕过它们。<br>
reminiscent: adj. 怀旧的，回忆往事的；耽于回想的 n. 回忆录作者；回忆者<br>
 frown: vi. 皱眉；不同意 vt. 皱眉，蹙额 n. 皱眉，蹙额<br>
 frown upon: 不悦；皱眉；不赞成<br>
 discrete: adj. 离散的，不连续的 n. 分立元件；独立部件</p>
</blockquote>
<blockquote>
<p>Note that there’s no = right after the function name and its parameters, before the first guard. Many newbies get syntax errors because they sometimes put it there. 注意，在函数名及其参数之后，在第一个 guard 之前没有 =。许多新手会出现语法错误，因为他们有时会把它放在那里。<br>
newbie /[ˈnuːbi]/n. 网络新手；新兵；新手</p>
</blockquote>
<blockquote>
<p>Repeating yourself (three times) while programming is about as desirable as getting kicked inna head. 在编程时重复 (三次) 自己的想法和被踢到脑袋里一样令人向往。??<br>
desirable: adj. 可取的，值得拥有的，令人向往的；引起性欲的，性感的 n. 称心如意的东西，合意的人，好的品质</p>
</blockquote>
<blockquote>
<p>Let’s make another fairly trivial function where we get a first and a last name and give someone back their initials. 让我们做另一个很简单的函数在这个函数中我们得到一个人的姓和名然后返回他们的首字母。<br>
fairly: adv. 相当地；公平地；简直<br>
 trivial: adj. 不重要的，琐碎的；琐细的</p>
</blockquote>
<blockquote>
<p>Remember when we did the if statement and it was explained that an if else statement is an expression and you can cram it in almost anywhere? 还记得我们做 if 语句的时候吗有人解释过 if else 语句是一个表达式你可以把它塞进几乎任何地方？</p>
</blockquote>
<blockquote>
<p>They’re very useful for quickly dismantling a tuple into components and binding them to names and such. 它们对于快速将元组分解为组件并将其绑定到名称等非常有用。<br>
dismantling: . 拆卸（机器或结构）；（逐渐）废除；为（某人）脱去（dismantle 的过去分词） n. 解散；（机器或机构等的）分解</p>
</blockquote>
<blockquote>
<p>Haskell takes that concept and one-ups it. Haskell 采用了这个概念，并使之更胜一筹。<br>
one up: 胜过</p>
</blockquote>
<blockquote>
<p>Like the name implies, case expressions are, well, expressions, much like if else expressions and let bindings. 顾名思义，case 表达式是表达式，很像 if else 表达式和 let 绑定。<br>
imply: vt. 意味；暗示；隐含</p>
</blockquote>
<blockquote>
<p>Recursion is important to Haskell because unlike imperative languages, you do computations in Haskell by declaring what something is instead of declaring how you get it. That’s why there are no while loops or for loops in Haskell and instead we many times have to use recursion to declare what something is. 递归对 Haskell 很重要，因为与命令式语言不同，在 Haskell 中，计算是通过声明某个东西是什么而不是声明如何得到它来完成的。这就是为什么 Haskell 中没有 while 循环或 for 循环，而我们很多时候不得不使用递归来声明一些东西是什么。</p>
</blockquote>
<blockquote>
<p>So the first edge condition says that if the list is empty, crash! Makes sense because what’s the maximum of an empty list? I don’t know. 第一个边条件是如果列表是空的，crash! 说得通，因为空列表的最大值是多少？我不知道。<br>
make sense: 有意义；讲得通；言之有理</p>
</blockquote>
<blockquote>
<p>How’s that for elegant! In essence, the maximum of a list is the max of the first element and the maximum of the tail. 这是多么优雅啊！本质上，列表的最大值是第一个元素的最大值和尾元素的最大值。</p>
</blockquote>
<blockquote>
<p>Num is not a subclass of Ord. That means that what constitutes for a number doesn’t really have to adhere to an ordering. So that’s why we have to specify both the Num and Ord class constraints when doing addition or subtraction and also comparison. Num 不是 Ord 的子类，这意味着构成一个数字的内容实际上不必遵循顺序。这就是为什么我们在做加法或减法以及比较时必须同时指定 Num 和 Ord 类约束的原因。<br>
constitute: vt. 组成，构成；建立；任命<br>
 adhere: vi. 坚持；依附；粘着；追随 vt. 使粘附</p>
</blockquote>
<blockquote>
<p>Let’s implement one more standard library function — elem. It takes an element and a list and sees if that element is in the list. The edge condition, as is most of the times with lists, is the empty list. We know that an empty list contains no elements, so it certainly doesn’t have the droids we’re looking for. 让我们实现另一个标准库函数 ——elem。它接受一个元素和一个列表，并查看该元素是否在列表中。边缘条件，就像列表的大多数情况一样，是空列表。我们知道一个空列表不包含元素，所以它肯定没有我们正在寻找的机器人。<br>
droid: n. 机器人</p>
</blockquote>
<blockquote>
<p>Quicksort has become a sort of poster child for Haskell. Therefore, let’s implement it here, even though implementing quicksort in Haskell is considered really cheesy because everyone does it to showcase how elegant Haskell is. 快速排序已经成为 Haskell 的一个典型代表。因此，让我们在这里实现它，尽管在 Haskell 中实现快速排序被认为是很俗气的，因为每个人都用它来展示 Haskell 是多么优雅。<br>
poster: n. 海报，广告；招贴<br>
 poster child: n. （公益广告中的）海报儿童；（幽默用法）榜样，典型人物<br>
 consider: vt. 考虑；认为；考虑到；细想 vi. 考虑；认为；细想<br>
 cheesy: adj. 干酪质的；下等的；虚伪的<br>
 showcase: n. 展示（本领、才华或优良品质）的场合；（商店或博物馆等的）玻璃柜台，玻璃陈列柜 v. 展现，表现</p>
</blockquote>
<blockquote>
<p>Eventually, we’ll break it up so much that we reach empty lists and an empty list is already sorted in a way, by virtue of being empty. 最终，我们会把它分解到空链表，而空链表在某种程度上已经排好序了，因为它是空的。<br>
break up: 打碎，破碎；结束；解散；衰落<br>
 virtue: n. 美德；优点；贞操；功效<br>
 by virtue of: 由于，凭借</p>
</blockquote>
<blockquote>
<p>Of course, these also have edge cases. Usually the edge case is some scenario where a recursive application doesn’t make sense. 当然，这些也有边界情况。通常情况下，边缘情况是指递归应用程序没有意义的情况。</p>
</blockquote>
<blockquote>
<p>Often the edge case value turns out to be an identity. The identity for multiplication is 1 because if you multiply something by 1, you get that something back. 通常情况下，边界值是一个恒等式。乘法的恒等式是 1 因为如果你把一个数乘以 1，你会得到那个数。</p>
</blockquote>
<blockquote>
<p>It turns out that if you want to define computations by defining what stuff is instead of defining steps that change some state and maybe looping them, higher order functions are indispensable. They’re a really powerful way of solving problems and thinking about programs. 如果你想通过定义东西来定义计算而不是定义改变状态的步骤或者循环它们，高阶函数是必不可少的。它们是解决问题和思考程序的一种非常强大的方式。<br>
indispensable: adj. 不可缺少的；绝对必要的；责无旁贷的 n. 不可缺少之物；必不可少的人</p>
</blockquote>
<blockquote>
<p>That sounds like a mouthful but it’s actually a really cool concept. 这听起来有点拗口，但实际上是个很酷的概念。<br>
mouthful: n. 一口，满口</p>
</blockquote>
<blockquote>
<p>The space is sort of like an operator and it has the highest precedence. 空格有点像一个运算符，它有最高的优先级<br>
 sort of: 有几分地；到某种程度；稍稍<br>
 precedence: n. 优先；居先</p>
</blockquote>
<blockquote>
<p>Using partial application (calling functions with too few parameters, if you will) is a neat way to create functions on the fly so we can pass them to another function or to seed them with some data. 使用部分应用程序 (调用最少参数的函数) 是动态创建函数的一种简洁方法，这样我们就可以将它们传递给另一个函数或在它们的基础上添加一些数据。<br>
neat: adj. 灵巧的；整洁的；优雅的；齐整的；未搀水的；平滑的<br>
 create function on the fly: 动态创建函数</p>
</blockquote>
<blockquote>
<p>Take a look at this offensively simple function. 看看这个简单得令人不快的功能。看一下这个非常简单的函数.<br>
offensively: adv. 冒犯地；讨厌地</p>
</blockquote>
<blockquote>
<p>From now on, we’ll say that functions take several parameters despite each function actually taking only one parameter and returning partially applied functions until we reach a function that returns a solid value. So for simplicity’s sake, we’ll say that a -&gt; a -&gt; a takes two parameters, even though we know what’s really going on under the hood. 从现在开始，我们会说函数有几个参数，尽管每个函数实际上只有一个参数，并且返回部分应用的函数，直到我们到达一个返回固定值的函数。为了简单起见，我们设 a - &gt;a - b&gt; a 有两个参数，尽管我们知道它到底是怎么回事。<br>
despite: prep. 即使，尽管 n. （诗 / 文）侮辱，伤害；轻视，鄙视；憎恨<br>
 simplicity: n. 朴素；简易；天真；愚蠢<br>
 sake: n. 目的；利益；理由；日本米酒</p>
</blockquote>
<blockquote>
<p>Mapping and filtering is the bread and butter of every functional programmer’s toolbox. 映射和过滤是每个函数式程序员的工具箱中的面包和黄油。<br>
butter: n. 黄油，奶油；像黄油的食品；奉承话 v. 涂黄油于；讨好</p>
</blockquote>
<blockquote>
<p>We usually surround them by parentheses, because otherwise they extend all the way to the right. 我们通常用括号把它们括起来，否则它们会一直向右延伸。</p>
</blockquote>
<blockquote>
<p>People who are not well acquainted with how currying and partial application works often use lambdas where they don’t need to. 不太了解 currying and partial application 如何工作的人经常在他们不需要的地方使用 lambdas。<br>
acquaint: vt. 使熟悉；使认识<br>
 acquainted: adj. 熟识的；知晓的；有知识的 vt. 使了解（acquaint 的过去分词）</p>
</blockquote>
<blockquote>
<p>In an imperative language, you have no guarantee that a simple function that should just crunch some numbers won’t burn down your house, kidnap your dog and scratch your car with a potato while crunching those numbers. 在命令式语言中，您无法保证一个仅处理一些数字的简单函数不会在处理这些数字时烧毁您的房子、绑架您的狗和用土豆刮伤您的汽车。<br>
crunch: n. 咬碎，咬碎声；扎扎地踏；（突发的）不足，短缺；财政困难 vt. 压碎；嘎扎嘎扎的咬嚼；扎扎地踏过 vi. 嘎吱作响地咀嚼；嘎吱嘎吱地踏过<br>
 kidnap: vt. 绑架；诱拐；拐骗</p>
</blockquote>
<blockquote>
<p>If a function can’t change anything in the world, how is it supposed to tell us what it calculated? In order to tell us what it calculated, it has to change the state of an output device (usually the state of the screen), which then emits photons that travel to our brain and change the state of our mind, man. 如果一个函数不能改变世界上的任何东西，它怎么能告诉我们它计算了什么？为了告诉我们它计算了什么，它必须改变输出设备的状态 (通常是屏幕的状态)，然后它发射光子进入我们的大脑，改变我们的思想状态，伙计。<br>
suppose: vt. 假设；认为；让（虚拟语气）；推想 vi. 猜想；料想 conj. 假使…… 结果会怎样<br>
 photon: n. [物] 光子；辐射量子；见光度（等于 light quantum）</p>
</blockquote>
<blockquote>
<p>Do not despair, all is not lost. It turns out that Haskell actually has a really clever system for dealing with functions that have side-effects that neatly separates the part of our program that is pure and the part of our program that is impure, which does all the dirty work like talking to the keyboard and the screen. 不要绝望，我们还没有失去一切。原来 Haskell 实际上有一个非常聪明的系统来处理函数副作用，巧妙地把我们的程序分为纯和不纯的部分，它做了所有的脏活像和键盘，屏幕交流。<br>
despair: n. 绝望；令人绝望的人或事 vi. 绝望，丧失信心<br>
 it turns out that: 原来是…<br>
neat: adj. 灵巧的；整洁的；优雅的；齐整的；未搀水的；平滑的<br>
 neatly: adv. 整洁地；熟练地；灵巧地</p>
</blockquote>
<blockquote>
<p>And sure enough, we’re going to do the good old “hello, world” schtick. 果不其然，我们又要玩 “你好，世界” 的老把戏了。<br>
schtick: n. 滑稽动作</p>
</blockquote>
<blockquote>
<p>I’d suggest you download Cygwin, which is a Linux-like environment for Windows, A.K.A. just what you need.<br>
A.K.A.: abbr. 又名；亦称（also known as)；就是</p>
</blockquote>
<blockquote>
<p>Looks pretty much run of the mill, but it isn’t, as we’ll see in just a few moments. 看起来很正常，但它不是，我们一会儿就会看到。<br>
mill: n. 磨坊，磨粉厂；工厂，制造厂；磨粉机；碾磨机；机器，铣床；（非正式）引擎；（非正式，旧）拳击比赛；密尔（北美货币单位，等于 0.001 美元）；（口语）一百万 v. 碾磨，磨细；切割（金属），铣；轧出（硬币的）边纹；（人或动物）乱转；（使羊毛等）缩绒<br>
 run of the mill: 一般化的；质量一般的；平平的；不突出的</p>
</blockquote>
<blockquote>
<p>And there we go, our first compiled program that printed out something to the terminal. How extraordinarily boring! 好了，我们的第一个编译程序在终端上打印了一些东西。多么地无聊啊！<br>
extraordinary: adj. 非凡的；特别的；离奇的；特派的<br>
 extraordinarily: adv. 极其，极端地；奇怪地</p>
</blockquote>
<h3 id="node"><a class="markdownIt-Anchor" href="#node">#</a> Node</h3>
<blockquote>
<p>npx is an useful tool to run one-off commands like create-react-app, http-server etc. npx 是运行诸如 create- response -app、http-server 等一次性命令的有用工具。<br>
one-off: adj. 一次性的 n. 一次性事物；与他人完全不同者</p>
</blockquote>
<blockquote>
<p>In computing, a shebang is the character sequence consisting of the characters number sign and exclamation mark (#!) at the beginning of a script. It is also called sha-bang, hashbang,pound-bang, or hash-pling.<br>
 在计算中，shebang 是由字符数字符号和感叹号 (#!) 组成的字符序列。它也被称为 sha-bang, hashbang,pound-bang，或 hash-pling。<br>
#!/usr/bin/env node</p>
</blockquote>
<blockquote>
<p>The light-weight runtime is built on Node.js, taking full advantage of its event-driven, non-blocking model. 轻量级运行时构建在 Node.js 上，充分利用其事件驱动、非阻塞模型。</p>
</blockquote>
<h3 id="c"><a class="markdownIt-Anchor" href="#c">#</a> C#</h3>
<blockquote>
<p>The retry logic is designed to gracefully process temporary errors or transient faults which tend to go away if the program waits several seconds and retries. 重试逻辑被设计为优雅地处理临时错误或瞬态错误，如果程序等待几秒钟并重试，这些错误往往会消失。<br>
transient: adj. 短暂的；路过的 n. 瞬变现象；过往旅客；候鸟</p>
</blockquote>
<blockquote>
<p>A brief failure of the networking that supports the Internet. 支持 Internet 的网络的短暂故障。</p>
</blockquote>
<blockquote>
<p>Your client program can encounter transient faults from which it should silently and gracefully recover and continue on its own. 您的客户机程序可能会遇到瞬态错误，它应该安静地、优雅地自行恢复并继续运行。</p>
</blockquote>
<blockquote>
<p>NOTE: The connection string for server name is geared toward Azure SQL Database, because it includes the four character prefix of tcp:. 注意：服务器名称的连接字符串是面向 Azure SQL 数据库的，因为它包含 tcp: 的四个字符前缀。<br>
gear: n. 齿轮；装置，工具；传动装置；排挡 vi. 适合；搭上齿轮；开始工作 vt. 开动；搭上齿轮；使…… 适合；使…… 准备好 adj. 好极了<br>
 be geared toward: 使与…… 相适应，使适合于</p>
</blockquote>
<blockquote>
<p>A small second class named TestSqlException, with a property named Number. 第二个小类 TestSqlException，带有一个名为 Number 的属性。</p>
</blockquote>
<blockquote>
<p>For a desktop, unplug the network cable. 对于台式电脑，拔掉网线。<br>
cable: n. 缆绳；电缆；海底电报 vt. 打电报 vi. 打海底电报</p>
</blockquote>
<blockquote>
<p>For a laptop, press the function combination of keys to turn off the network adapter. 对于笔记本电脑，按功能组合键关闭网络适配器。</p>
</blockquote>
<blockquote>
<p>In addition, there are often legal requirements that must be adhered to, such as the correct storage of confidential information. Storing some kinds of personal data is proscribed entirely, depending on the laws that apply in a particular jurisdiction. 此外，通常还必须遵守一些法律要求，例如机密信息的正确存储。根据某一特定司法管辖区所适用的法律，某些类型的个人资料被完全禁止储存。<br>
adhere: vi. 坚持；依附；粘着；追随 vt. 使粘附<br>
 confidential: adj. 机密的；表示信任的；获信任的<br>
 proscribe: vt. 剥夺…… 的公权；禁止<br>
 jurisdiction: n. 司法权，审判权，管辖权；权限，权力</p>
</blockquote>
<blockquote>
<p>Some applications that are local in scope may need only minimal security whereas other local applications or applications deployed over the Internet may require stringent security measures and ongoing monitoring and evaluation. 一些本地应用程序可能只需要很少的安全性，而其他本地应用程序或部署在 Internet 上的应用程序可能需要严格的安全性措施和持续的监视和评估。<br>
stringent: adj. 严格的；严厉的；紧缩的；短缺的<br>
 measure: n. 测量；措施；程度；尺寸 vt. 测量；估量；权衡 vi. 测量；估量<br>
 ongoing: adj. 仍在进行的；不断前进的；持续存在的<br>
 evaluation: n. 评价； 评估；估价；求值</p>
</blockquote>
<blockquote>
<p>The security requirements of a SQL Server database application should be considered at design time, not as an afterthought. Evaluating threats early in the development cycle gives you the opportunity to mitigate potential damage wherever a vulnerability is detected. SQL Server 数据库应用程序的安全性要求应该在设计时考虑，而不是事后再考虑。在开发周期的早期评估威胁，使您有机会在检测到漏洞的地方减轻潜在的损害。<br>
afterthought: n. 事后的想法，马后炮；后来添加的东西<br>
 mitigate: vt. 使缓和，使减轻 vi. 减轻，缓和下来<br>
 vulnerability: /ˌvʌlnərəˈbɪləti/n. 易损性；弱点</p>
</blockquote>
<blockquote>
<p>SQL Server 2008 introduces new data types that are designed to meet business needs to work with date and time, structured, semi-structured, and unstructured data. SQL Server 2008 引入了新的数据类型，旨在满足处理日期和时间、结构化、半结构化和非结构化数据的业务需求。<br>
semi: n. 半挂车；半独立式的住宅</p>
</blockquote>
<h3 id="oracle"><a class="markdownIt-Anchor" href="#oracle">#</a> Oracle</h3>
<blockquote>
<p>Java is the object-oriented programming language of choice that provides platform independence and automated storage management techniques. Java 是提供平台独立性和自动化存储管理技术的首选面向对象编程语言。<br>
of choice: 首选的</p>
</blockquote>
<blockquote>
<p>Vertical ellipsis points in an example mean that information not directly related to the example has been omitted. 示例中的垂直省略点表示省略了与示例不直接相关的信息。</p>
</blockquote>
<blockquote>
<p>Boldface type in text indicates a term defined in the text, the glossary, or in both locations. 文本中的黑体类型表示在文本、术语表或这两个位置中定义的术语。</p>
<p>glossary: n. 术语（特殊用语）表；词汇表；专业词典</p>
</blockquote>
<blockquote>
<p>Angle brackets enclose user-supplied names. 尖括号括起用户提供的名称。&lt;&gt;</p>
</blockquote>
<blockquote>
<p>Brackets enclose optional clauses from which you can choose one or none. 方括号包含可选的子句，您可以从中选择一个或没有。[]</p>
</blockquote>
<blockquote>
<p>Java has emerged as the object-oriented programming language of choice. Java 已成为首选的面向对象编程语言</p>
<p>emerge: vi. 浮现；摆脱；暴露</p>
<p>emerged as: 如…… 涌现；以…… 形式出现</p>
</blockquote>
<blockquote>
<p>As with other high-level computer languages, the Java source compiles to low-level machine instructions. 与其他高级计算机语言一样，Java 源代码编译为低级机器指令。</p>
</blockquote>
<blockquote>
<p>Java has been developed to prevent anyone from tampering with the operating system where the Java code resides in. 开发 Java 是为了防止任何人篡改 Java 代码所在的操作系统。</p>
</blockquote>
<h3 id="other"><a class="markdownIt-Anchor" href="#other">#</a> Other</h3>
<blockquote>
<p>By now you should have a good idea about how this is different from normal LIKE or pattern matching. 到目前为止，您应该已经很清楚这与一般的 LIKE 或模式匹配有何不同。</p>
</blockquote>
<blockquote>
<p>Faster time to market - can see how your users are using search and decide if you need to use ElasticSearch for more sophisticated search features 更快的上市时间 - 可以看你的用户如何使用搜索，并决定你是否需要使用 ElasticSearch 更复杂的搜索功能<br>
 sophisticate: v. 弄复杂；使变得世故；曲解；（老练地）讲话 adj. 老于世故的 n. 久经世故的人；精通时尚和文化的人<br>
 sophisticated: adj. 复杂的；精致的；久经世故的；富有经验的 v. 使变得世故；使迷惑；篡改（sophisticate 的过去分词形式）</p>
</blockquote>
<blockquote>
<p>There’s a single source of truth for the data - no need to keep multiple datastores in sync. 数据只有一个真实来源 —— 不需要保持多个数据存储同步。</p>
</blockquote>
<blockquote>
<p>I’ve been meaning to write this post for a very long time - not only for others but also for what I wish I was told when I first started working as a developer. 我想写这篇文章已经有很长一段时间了 —— 不仅是为了别人，也是为了我刚开始作为一名开发人员时希望别人告诉我什么。<br>
have been meaning to: 一直想</p>
</blockquote>
<blockquote>
<p>You might be healthy now but unfortunately, as you age, your vision gets blurry, your wrists or back start hurting etc. 你现在可能很健康，但不幸的是，随着年龄的增长，你的视力变得模糊，手腕或背部开始疼痛等等。<br>
vision: n. 视力；美景；眼力；幻象；想象力；幻视（漫威漫画旗下超级英雄） vt. 想象；显现；梦见<br>
 blurry: adj. 模糊的；污脏的；不清楚的<br>
 wrist: n. 手腕；腕关节 vt. 用腕力移动</p>
</blockquote>
<blockquote>
<p>This might not happen to everyone - There are plenty of developers who are in their 40s, 50s and above without these issues, but why take chances? 这可能不会发生在每个人身上 —— 有很多四五十岁以上的开发人员没有这些问题，但为什么要冒险呢？</p>
</blockquote>
<blockquote>
<p>Take a break from work now and then. Earth will still be spinning after you return from break. 时不时地从工作中休息一下。你从休息回来后地球将仍然在旋转后。<br>
now and then: 偶尔；有时；不时<br>
 spin: vi. 旋转；纺纱；吐丝；晕眩 vt. 使旋转；纺纱；编造；结网 n. 旋转；疾驰</p>
</blockquote>
<blockquote>
<p>Each software project is different in terms of scope, business value, people involved, their skills, how long the project is going to be maintained etc. 每个软件项目在范围、业务价值、所涉及的人员、他们的技能、项目将被维护的时间等方面都是不同的。</p>
</blockquote>
<blockquote>
<p>Engineering is all about tradeoffs. Ask yourself: in which context a particular advice makes sense. 工程就是要权衡利弊。问问自己：在什么情况下，一个特别的建议是有意义的。<br>
make sense: 有意义；讲得通；言之有理</p>
</blockquote>
<blockquote>
<p>if business urgently wants a throwaway website that will be only used for 2 weeks, don’t try to build it using TDD etc. 如果企业迫切需要一个只使用 2 周的一次性网站，不要尝试使用 TDD 等来构建它<br>
 throwaway: n. 废品；广告传单；脱口而出的话 adj. 抛弃型的；脱口而出的；漫不经心的</p>
</blockquote>
<blockquote>
<p>Your peers, leads, managers are all in the same boat. 你的同事、领导、经理都在同一条船上。<br>
peer: n. 同等地位的人，同龄人；贵族 v. 凝视，盯着看；隐现；看见；匹配</p>
</blockquote>
<blockquote>
<p>Most of the time, we end up doing something that we did 2-3 years back (vertically centre something in CSS, implement login flow, upload a file to S3 etc). 大多数时候，我们会做一些 2-3 年前做过的事情 (CSS 垂直居中，实现登录流程，向 S3 上传文件等等)。</p>
</blockquote>
<blockquote>
<p>Make time to learn about these foundational concepts as you go about your job. 在你从事工作的时候，花点时间来学习这些基本概念。<br>
go about: v. 着手做；四处走动；传开；从事</p>
</blockquote>
<blockquote>
<p>Ask as many questions as needed for you to understand. 问尽可能多的问题来让你理解。</p>
</blockquote>
<blockquote>
<p>Once you know what you’re solving, there are good chances that you can come up with better solutions or solutions that can be implemented faster. 一旦你知道你要解决的是什么，你就很有可能想出更好的解决方案，或者更快地实现解决方案。<br>
come up: 走近；发生；开始；上升；发芽；被提出</p>
</blockquote>
<blockquote>
<p>Technology advances super fast. While it’s impossible to learn everything new that’s coming up, it’s better to be aware of the new things that are slowly becoming the industry standard and learn about it when you have free time. 技术进步非常快。虽然不可能学习所有即将出现的新事物，但最好了解那些正在慢慢成为行业标准的新事物，并在你有空闲的时候学习它们。<br>
advance: n. 发展；前进；增长；预付款 vt. 提出；预付；使…… 前进；将…… 提前 vi. 前进；进展；上涨 adj. 预先的；先行的</p>
</blockquote>
<blockquote>
<p>Especially if I’m playing around with things like database clustering solutions, when I need multiple databases running together. So the other day, I thought about using Docker containers. 特别是当我使用数据库集群解决方案时，当我需要多个数据库一起运行时。所以前几天，我考虑使用 Docker 容器。</p>
</blockquote>
<blockquote>
<p>Docker is named after the containers that you see on ships. Docker 是以你在船上看到的集装箱命名的。<br>
after: prep. 在…… 之后；在…… 身后；反复；跟随；追求；以…… 命名 conj. 在…… 之后 adv. 后来，以后 adj. 后来的，以后的；后部的</p>
</blockquote>
<blockquote>
<p>This makes installing an application on a server as easy as installing a mobile app on your tablet or smartphone. 这使得在服务器上安装应用程序就像在平板电脑或智能手机上安装移动应用程序一样简单。<br>
tablet: n. 碑；药片；写字板；小块；平板电脑 vt. 用碑牌纪念；将 (备忘录等) 写在板上；将… 制成小片或小块</p>
</blockquote>
<blockquote>
<p>By using containers, resources can be isolated, access to services restricted and processes assigned, so that you can indicate exactly how much of, for example, CPU, memory or I / O load can be used by a container. 通过使用容器，可以隔离资源、限制对服务的访问和分配进程，以便您可以精确地指示有多少 (例如) CPU、内存或 I / O 负载可以被容器使用。</p>
</blockquote>
<blockquote>
<p>There are dozens of databases available on Docker’s Hub. Docker 的 Hub 上有几十个可用的数据库<br>
 dozen: n. 十二个，一打 adj. 一打的</p>
</blockquote>
<blockquote>
<p>Plus, containers are part of the whole Microservices Architecture that DevOps keep going on about, and inevitably lead to talking about Kubernetes. 另外，容器是 DevOps 一直在讨论的整个微服务体系结构的一部分，这不可避免地导致了对 Kubernetes 的讨论。<br>
inevitable: adj. 必然的，不可避免的<br>
 inevitably: adv. 不可避免地；必然地</p>
</blockquote>

      <div class="tags">
          <a href="/tags/english/" rel="tag"><i class="ic i-tag"></i> english</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2022-07-15 19:54:50" itemprop="dateModified" datetime="2022-07-15T19:54:50+08:00">2022-07-15</time>
  </span>
</div>

      

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2020/08/04/rust-raw-string/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipexoj0moj20zk0m8kgu.jpg" title="Rust raw string literals">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>Rust raw string literals</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2020/08/13/oracel-dynamic-sql/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva4.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giclwuom7cj20zk0m8dvn.jpg" title="Oracle Dynamic SQL">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>Oracle Dynamic SQL</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#business"><span class="toc-number">1.</span> <span class="toc-text"> Business</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cet-6"><span class="toc-number">2.</span> <span class="toc-text"> CET 6</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rust"><span class="toc-number">3.</span> <span class="toc-text"> Rust</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#haskell"><span class="toc-number">4.</span> <span class="toc-text"> Haskell</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node"><span class="toc-number">5.</span> <span class="toc-text"> Node</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c"><span class="toc-number">6.</span> <span class="toc-text"> C#</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#oracle"><span class="toc-number">7.</span> <span class="toc-text"> Oracle</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#other"><span class="toc-number">8.</span> <span class="toc-text"> Other</span></a></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="江边鸟"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">江边鸟</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">306</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">2</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">43</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xoY2hlbjc0" title="https:&#x2F;&#x2F;github.com&#x2F;lhchen74"><i class="ic i-github"></i></span>
      <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLw==" title="https:&#x2F;&#x2F;music.163.com&#x2F;"><i class="ic i-cloud-music"></i></span>
      <span class="exturl item codepen" data-url="aHR0cHM6Ly9jb2RlcGVuLmlvL2xoY2hlbjc0" title="https:&#x2F;&#x2F;codepen.io&#x2F;lhchen74"><i class="ic i-address-card"></i></span>
      <span class="exturl item anki" data-url="aHR0cHM6Ly9hbmtpd2ViLm5ldC9kZWNrcy8=" title="https:&#x2F;&#x2F;ankiweb.net&#x2F;decks&#x2F;"><i class="ic i-address-card"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>About</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>Friends</a>
  </li>

    
  <li class="item">
    <a href="/anime/" rel="section"><i class="ic i-magic"></i>Anime</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2020/08/04/rust-raw-string/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2020/08/13/oracel-dynamic-sql/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2022</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">江边鸟 @ D E W</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2020/08/13/english-word/',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
