



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="露の世" href="https://lhchen74.github.io/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="露の世" href="https://lhchen74.github.io/atom.xml" />
<link rel="alternate" type="application/json" title="露の世" href="https://lhchen74.github.io/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CFira%20Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="rust" />


<link rel="canonical" href="https://lhchen74.github.io/2020/08/01/rust-error/">



  <title>
Beginner's guide to Error Handling in Rust |
D E W = 露の世</title>
<meta name="generator" content="Hexo 5.4.0"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">Beginner's guide to Error Handling in Rust
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2020-08-01 00:00:00">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2020-08-01T00:00:00+08:00">2020-08-01</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">D E W</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="/anime/index/只有我不存在的城市.jpg"></li>
          <li class="item" data-background-image="/anime/index/弹丸论破.jpg"></li>
          <li class="item" data-background-image="/anime/index/交响情人梦-2.jpg"></li>
          <li class="item" data-background-image="/anime/index/钢之炼金术师.jpg"></li>
          <li class="item" data-background-image="/anime/index/天真与闪电-1.jpg"></li>
          <li class="item" data-background-image="/anime/index/电锯人-1.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="https://lhchen74.github.io/2020/08/01/rust-error/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="江边鸟">
    <meta itemprop="description" content=", ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="露の世">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <blockquote>
<p>转载: <span class="exturl" data-url="aHR0cDovL3d3dy5zaGVzaGJhYnUuY29tL3Bvc3RzL3J1c3QtZXJyb3ItaGFuZGxpbmcv">Beginner’s guide to Error Handling in Rust</span></p>
</blockquote>
<p>Error handling in Rust is very different if you’re coming from other languages. In languages like Java, JS, Python etc, you usually  <code>throw</code>  exceptions and  <code>return</code>  successful values. In Rust, you return something called a  <code>Result</code> .</p>
<p>The  <code>Result&lt;T, E&gt;</code>  type is an <span class="exturl" data-url="aHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy9ib29rL2NoMDYtMDEtZGVmaW5pbmctYW4tZW51bS5odG1s">enum</span> that has two variants -  <code>Ok(T)</code>  for successful value or  <code>Err(E)</code>  for error value:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span></span>&lt;T, E&gt; &#123;</span><br><span class="line">   <span class="literal">Ok</span>(T),</span><br><span class="line">   <span class="literal">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Returning errors instead of throwing them is a paradigm shift in error handling. If you’re new to Rust, there will be some friction initially as it requires you to reason about errors in a different way.</p>
<p>In this post, I’ll go through some common error handling patterns so you gradually become familiar with how things are done in Rust:</p>
<ul>
<li>Ignore the error</li>
<li>Terminate the program</li>
<li>Use a fallback value</li>
<li>Bubble up the error</li>
<li>Bubble up multiple errors</li>
<li>Match boxed errors</li>
<li>Libraries vs Applications</li>
<li>Create custom errors</li>
<li>Bubble up custom errors</li>
<li>Match custom errors</li>
</ul>
<h2 id="ignore-the-error"><a class="markdownIt-Anchor" href="#ignore-the-error">#</a> Ignore the error</h2>
<p>Let’s start with the simplest scenario where we just ignore the error. This sounds careless but has a couple of legitimate use cases:</p>
<ul>
<li>We’re prototyping our code and don’t want to spend time on error handling.</li>
<li>We’re confident that the error won’t occur.</li>
</ul>
<p>Let’s say that we’re reading a file which we’re pretty sure would be present:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> content = fs::read_to_string(<span class="string">&quot;./Cargo.toml&quot;</span>).unwrap();</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Even though we know that the file would be present, the compiler has no way of knowing that. So we use  <code>unwrap</code>  to tell the compiler to trust us and return the value inside. If the  <code>read_to_string</code>  function returns an  <code>Ok()</code>  value,  <code>unwrap</code>  will get the contents of  <code>Ok</code>  and assign it to the  <code>content</code>  variable. If it returns an error, it will “panic”. Panic either terminates the program or exits the current thread.</p>
<p>Note that  <code>unwrap</code>  is used in quite a lot of Rust examples to skip error handling. This is mostly done for convenience and shouldn’t be used in real code as it is.</p>
<h2 id="terminate-the-program"><a class="markdownIt-Anchor" href="#terminate-the-program">#</a> Terminate the program</h2>
<p>Some errors cannot be handled or recovered from. In these cases, it’s better to <em>fail fast</em> by terminating the program.</p>
<p>Let’s use the same example as above - we’re reading a file which we’re sure to be present. Let’s imagine that, for this program, that file is absolutely important without which it won’t work properly. If for some reason, this file is absent, it’s better to terminate the program.</p>
<p>We can use  <code>unwrap</code>  as before or use  <code>expect</code>  - it’s same as  <code>unwrap</code>  but lets us add extra error message.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> content = fs::read_to_string(<span class="string">&quot;./Cargo.toml&quot;</span>).expect(<span class="string">&quot;Can&#x27;t read Cargo.toml&quot;</span>);</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, content)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>See also: <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/macro.panic.html"> <code>panic!</code> </a></p>
<h2 id="use-a-fallback-value"><a class="markdownIt-Anchor" href="#use-a-fallback-value">#</a> Use a fallback value</h2>
<p>In some cases, you can handle the error by falling back to a default value.</p>
<p>For example, let’s say we’re writing a server and the port it listens to can be configured using an environment variable. If the environment variable is not set, accessing that value would result in an error. But we can easily handle that by falling back to a default value.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::env;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> port = env::var(<span class="string">&quot;PORT&quot;</span>).unwrap_or(<span class="string">&quot;3000&quot;</span>.to_string());</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, port);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here, we’ve used a variation of  <code>unwrap</code>  called  <code>unwrap_or</code>  which lets us supply default values.</p>
<p>See also: <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or_else"> <code>unwrap_or_else</code> </a>, <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or_default"> <code>unwrap_or_default</code> </a></p>
<h2 id="bubble-up-the-error"><a class="markdownIt-Anchor" href="#bubble-up-the-error">#</a> Bubble up the error</h2>
<p>When you don’t have enough context to handle the error, you can bubble up (propagate) the error to the caller function.</p>
<p>Here’s a contrived example which uses a webservice to get the current year:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">match</span> get_current_date() &#123;</span><br><span class="line">    <span class="literal">Ok</span>(date) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;We&#x27;ve time travelled to &#123;&#125;!!&quot;</span>, date),</span><br><span class="line">    <span class="literal">Err</span>(e) =&gt; eprintln!(<span class="string">&quot;Oh noes, we don&#x27;t know which era we&#x27;re in! :( \n  &#123;&#125;&quot;</span>, e),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_current_date</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, reqwest::Error&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="string">&quot;https://postman-echo.com/time/object&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> result = reqwest::blocking::get(url);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">match</span> result &#123;</span><br><span class="line">    <span class="literal">Ok</span>(res) =&gt; res,</span><br><span class="line">    <span class="literal">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(err),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> body = response.json::&lt;HashMap&lt;<span class="built_in">String</span>, <span class="built_in">i32</span>&gt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> json = <span class="keyword">match</span> body &#123;</span><br><span class="line">    <span class="literal">Ok</span>(json) =&gt; json,</span><br><span class="line">    <span class="literal">Err</span>(err) =&gt; <span class="keyword">return</span> <span class="literal">Err</span>(err),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> date = json[<span class="string">&quot;years&quot;</span>].to_string();</span><br><span class="line"></span><br><span class="line">  <span class="literal">Ok</span>(date)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>There are two function calls inside the  <code>get_current_date</code>  function ( <code>get</code>  and  <code>json</code> ) that return  <code>Result</code>  values. Since  <code>get_current_date</code>  doesn’t have context of what to do when they return errors, it uses pattern matching to propagate the errors to  <code>main</code> .</p>
<p>Using pattern matching to handle multiple or nested errors can make your code “noisy”. Instead, we can rewrite the above code using the <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator"> <code>?</code>  operator</a>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">  <span class="keyword">match</span> get_current_date() &#123;</span><br><span class="line">    <span class="literal">Ok</span>(date) =&gt; <span class="built_in">println!</span>(<span class="string">&quot;We&#x27;ve time travelled to &#123;&#125;!!&quot;</span>, date),</span><br><span class="line">    <span class="literal">Err</span>(e) =&gt; eprintln!(<span class="string">&quot;Oh noes, we don&#x27;t know which era we&#x27;re in! :( \n  &#123;&#125;&quot;</span>, e),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">get_current_date</span></span>() -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">String</span>, reqwest::Error&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="string">&quot;https://postman-echo.com/time/object&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> res = reqwest::blocking::get(url)?.json::&lt;HashMap&lt;<span class="built_in">String</span>, <span class="built_in">i32</span>&gt;&gt;()?;</span><br><span class="line">  <span class="keyword">let</span> date = res[<span class="string">&quot;years&quot;</span>].to_string();</span><br><span class="line"></span><br><span class="line">  <span class="literal">Ok</span>(date)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This looks much cleaner!</p>
<p>The  <code>?</code>  operator is similar to  <code>unwrap</code>  but instead of panicking, it propagates the error to the calling function. One thing to keep in mind is that we can use the  <code>?</code>  operator only for functions that return a  <code>Result</code>  or  <code>Option</code>  type.</p>
<h2 id="bubble-up-multiple-errors"><a class="markdownIt-Anchor" href="#bubble-up-multiple-errors">#</a> Bubble up multiple errors</h2>
<p>In the previous example, the  <code>get</code>  and  <code>json</code>  functions return a  <code>reqwest::Error</code>  error which we’ve propagated using the  <code>?</code>  operator. But what if we’ve another function call that returned a different error value?</p>
<p>Let’s extend the previous example by returning a formatted date instead of the year:</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ use chrono::NaiveDate;</span></span><br><span class="line">  use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">  fn main() &#123;</span><br><span class="line">    match get_current_date() &#123;</span><br><span class="line">      Ok(date) =&gt; println!(&quot;We&#x27;ve time travelled to &#123;&#125;!!&quot;, date),</span><br><span class="line">      Err(e) =&gt; eprintln!(&quot;Oh noes, we don&#x27;t know which era we&#x27;re in! :( \n  &#123;&#125;&quot;, e),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn get_current_date() -&gt; Result&lt;String, reqwest::Error&gt; &#123;</span><br><span class="line">    let url = &quot;https://postman-echo.com/time/object&quot;;</span><br><span class="line">    let res = reqwest::blocking::get(url)?.json::&lt;HashMap&lt;String, i32&gt;&gt;()?;</span><br><span class="line"><span class="deletion">-   let date = res[&quot;years&quot;].to_string();</span></span><br><span class="line"><span class="addition">+   let formatted_date = format!(&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;, res[&quot;years&quot;], res[&quot;months&quot;] + 1, res[&quot;date&quot;]);</span></span><br><span class="line"><span class="addition">+   let parsed_date = NaiveDate::parse_from_str(formatted_date.as_str(), &quot;%Y-%m-%d&quot;)?;</span></span><br><span class="line"><span class="addition">+   let date = parsed_date.format(&quot;%Y %B %d&quot;).to_string();</span></span><br><span class="line"></span><br><span class="line">    Ok(date)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>The above code won’t compile as  <code>parse_from_str</code>  returns a  <code>chrono::format::ParseError</code>  error and not  <code>reqwest::Error</code> .</p>
<p>We can fix this by  <code>Box</code> ing the errors:</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  use chrono::NaiveDate;</span><br><span class="line">  use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">  fn main() &#123;</span><br><span class="line">    match get_current_date() &#123;</span><br><span class="line">      Ok(date) =&gt; println!(&quot;We&#x27;ve time travelled to &#123;&#125;!!&quot;, date),</span><br><span class="line">      Err(e) =&gt; eprintln!(&quot;Oh noes, we don&#x27;t know which era we&#x27;re in! :( \n  &#123;&#125;&quot;, e),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="deletion">- fn get_current_date() -&gt; Result&lt;String, reqwest::Error&gt; &#123;</span></span><br><span class="line"><span class="addition">+ fn get_current_date() -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; &#123;</span></span><br><span class="line">    let url = &quot;https://postman-echo.com/time/object&quot;;</span><br><span class="line">    let res = reqwest::blocking::get(url)?.json::&lt;HashMap&lt;String, i32&gt;&gt;()?;</span><br><span class="line"></span><br><span class="line">    let formatted_date = format!(&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;, res[&quot;years&quot;], res[&quot;months&quot;] + 1, res[&quot;date&quot;]);</span><br><span class="line">    let parsed_date = NaiveDate::parse_from_str(formatted_date.as_str(), &quot;%Y-%m-%d&quot;)?;</span><br><span class="line">    let date = parsed_date.format(&quot;%Y %B %d&quot;).to_string();</span><br><span class="line"></span><br><span class="line">    Ok(date)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Returning a trait object  <code>Box&lt;dyn std::error::Error&gt;</code>  is very convenient when we want to return multiple errors!</p>
<p>See also: <a target="_blank" rel="noopener" href="https://github.com/dtolnay/anyhow"> <code>anyhow</code> </a>, <a target="_blank" rel="noopener" href="https://github.com/yaahc/eyre"> <code>eyre</code> </a></p>
<h2 id="match-boxed-errors"><a class="markdownIt-Anchor" href="#match-boxed-errors">#</a> Match boxed errors</h2>
<p>So far, we’ve only printed the errors in the  <code>main</code>  function but not handled them. If we want to handle and recover from boxed errors, we need to “downcast” them:</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  use chrono::NaiveDate;</span><br><span class="line">  use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">  fn main() &#123;</span><br><span class="line">    match get_current_date() &#123;</span><br><span class="line">      Ok(date) =&gt; println!(&quot;We&#x27;ve time travelled to &#123;&#125;!!&quot;, date),</span><br><span class="line"><span class="deletion">-     Err(e) =&gt; eprintln!(&quot;Oh noes, we don&#x27;t know which era we&#x27;re in! :( \n  &#123;&#125;&quot;, e),</span></span><br><span class="line"><span class="addition">+     Err(e) =&gt; &#123;</span></span><br><span class="line"><span class="addition">+       eprintln!(&quot;Oh noes, we don&#x27;t know which era we&#x27;re in! :(&quot;);</span></span><br><span class="line"><span class="addition">+       if let Some(err) = e.downcast_ref::&lt;reqwest::Error&gt;() &#123;</span></span><br><span class="line"><span class="addition">+         eprintln!(&quot;Request Error: &#123;&#125;&quot;, err)</span></span><br><span class="line"><span class="addition">+       &#125; else if let Some(err) = e.downcast_ref::&lt;chrono::format::ParseError&gt;() &#123;</span></span><br><span class="line"><span class="addition">+         eprintln!(&quot;Parse Error: &#123;&#125;&quot;, err)</span></span><br><span class="line"><span class="addition">+       &#125;</span></span><br><span class="line"><span class="addition">+     &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn get_current_date() -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; &#123;</span><br><span class="line">    let url = &quot;https://postman-echo.com/time/object&quot;;</span><br><span class="line">    let res = reqwest::blocking::get(url)?.json::&lt;HashMap&lt;String, i32&gt;&gt;()?;</span><br><span class="line"></span><br><span class="line">    let formatted_date = format!(&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;, res[&quot;years&quot;], res[&quot;months&quot;] + 1, res[&quot;date&quot;]);</span><br><span class="line">    let parsed_date = NaiveDate::parse_from_str(formatted_date.as_str(), &quot;%Y-%m-%d&quot;)?;</span><br><span class="line">    let date = parsed_date.format(&quot;%Y %B %d&quot;).to_string();</span><br><span class="line"></span><br><span class="line">    Ok(date)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Notice how we need to be aware of the implementation details (different errors inside) of  <code>get_current_date</code>  to be able to downcast them inside  <code>main</code> .</p>
<p>See also: <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/error/trait.Error.html#method.downcast"> <code>downcast</code> </a>, <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/error/trait.Error.html#method.downcast_mut"> <code>downcast_mut</code> </a></p>
<h2 id="applications-vs-libraries"><a class="markdownIt-Anchor" href="#applications-vs-libraries">#</a> Applications vs Libraries</h2>
<p>As mentioned previously, the downside to boxed errors is that if we want to handle the underlying errors, we need to be aware of the implementation details. When we return something as  <code>Box&lt;dyn std::error::Error&gt;</code> , the concrete type information is erased. To handle the different errors in different ways, we need to downcast them to concrete types and this casting can fail at runtime.</p>
<p>However, saying something is a “downside” is not very useful without context. A good rule of thumb is to question whether the code you’re writing is an “application” or a “library”:</p>
<h3 id="application"><a class="markdownIt-Anchor" href="#application">#</a> Application</h3>
<ul>
<li>The code you’re writing would be used by end users.</li>
<li>Most errors generated by application code won’t be handled but instead logged or reported to the user.</li>
<li>It’s okay to use boxed errors.</li>
</ul>
<h3 id="library"><a class="markdownIt-Anchor" href="#library">#</a> Library</h3>
<ul>
<li>The code you’re writing would be consumed by other code. A “library” can be open source crates, internal libraries etc</li>
<li>Errors are part of your library’s API, so your consumers know what errors to expect and recover from.</li>
<li>Errors from your library are often handled by your consumers so they need to be structured and easy to perform <span class="exturl" data-url="aHR0cHM6Ly9kb2MucnVzdC1sYW5nLm9yZy8xLjMwLjAvYm9vay8yMDE4LWVkaXRpb24vY2gwNi0wMi1tYXRjaC5odG1sI21hdGNoZXMtYXJlLWV4aGF1c3RpdmU=">exhaustive match</span> on.</li>
<li>If you return boxed errors, then your consumers need to be aware of the errors created by your code, your dependencies, and so on!</li>
<li>Instead of boxed errors, we can return custom errors.</li>
</ul>
<h2 id="create-custom-errors"><a class="markdownIt-Anchor" href="#create-custom-errors">#</a> Create custom errors</h2>
<p>For library code, we can convert all the errors to our own custom error and propagate them instead of boxed errors. In our example, we currently have two errors -  <code>reqwest::Error</code>  and  <code>chrono::format::ParseError</code> . We can convert them to  <code>MyCustomError::HttpError</code>  and  <code>MyCustomError::ParseError</code>  respectively.</p>
<p>Let’s start by creating an enum to hold our two error variants:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">MyCustomError</span></span> &#123;</span><br><span class="line">  HttpError,</span><br><span class="line">  ParseError,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/error/trait.Error.html"> <code>Error</code> </a> trait requires us to implement the <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"> <code>Debug</code> </a> and <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/fmt/trait.Display.html"> <code>Display</code> </a> traits:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">enum</span> <span class="title">MyCustomError</span></span> &#123;</span><br><span class="line">  HttpError,</span><br><span class="line">  ParseError,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> std::error::Error <span class="keyword">for</span> MyCustomError &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> fmt::Display <span class="keyword">for</span> MyCustomError &#123;</span><br><span class="line">  <span class="function"><span class="keyword">fn</span> <span class="title">fmt</span></span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) -&gt; fmt::<span class="built_in">Result</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">      MyCustomError::HttpError =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;HTTP Error&quot;</span>),</span><br><span class="line">      MyCustomError::ParseError =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;Parse Error&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We’ve created our own custom error!</p>
<p>This is obviously a simple example as the error variants don’t contain much information about the error. But this should be sufficient as a starting point for creating more complex and realistic custom errors. Here are some real life examples: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0J1cm50U3VzaGkvcmlwZ3JlcC9ibG9iLzEyLjEuMS9jcmF0ZXMvcmVnZXgvc3JjL2Vycm9yLnJz">ripgrep</span>, <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NlYW5tb25zdGFyL3JlcXdlc3QvYmxvYi92MC4xMC43L3NyYy9lcnJvci5ycw==">reqwest</span>, <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0J1cm50U3VzaGkvcnVzdC1jc3YvYmxvYi9tYXN0ZXIvc3JjL2Vycm9yLnJz">csv</span> and <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NlcmRlLXJzL2pzb24vYmxvYi9tYXN0ZXIvc3JjL2Vycm9yLnJz">serde_json</span></p>
<p>See also: <a target="_blank" rel="noopener" href="https://github.com/dtolnay/thiserror"> <code>thiserror</code> </a>, <a target="_blank" rel="noopener" href="https://github.com/shepmaster/snafu"> <code>snafu</code> </a></p>
<h2 id="bubble-up-custom-errors"><a class="markdownIt-Anchor" href="#bubble-up-custom-errors">#</a> Bubble up custom errors</h2>
<p>Let’s update our code to return the custom errors we just created:</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  // main.rs</span><br><span class="line"></span><br><span class="line"><span class="addition">+ mod error;</span></span><br><span class="line"></span><br><span class="line">  use chrono::NaiveDate;</span><br><span class="line"><span class="addition">+ use error::MyCustomError;</span></span><br><span class="line">  use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">  fn main() &#123;</span><br><span class="line">    // skipped, will get back later</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="deletion">- fn get_current_date() -&gt; Result&lt;String, Box&lt;dyn std::error::Error&gt;&gt; &#123;</span></span><br><span class="line"><span class="addition">+ fn get_current_date() -&gt; Result&lt;String, MyCustomError&gt; &#123;</span></span><br><span class="line">    let url = &quot;https://postman-echo.com/time/object&quot;;</span><br><span class="line"><span class="deletion">-   let res = reqwest::blocking::get(url)?.json::&lt;HashMap&lt;String, i32&gt;&gt;()?;</span></span><br><span class="line"><span class="addition">+   let res = reqwest::blocking::get(url)</span></span><br><span class="line"><span class="addition">+     .map_err(|_| MyCustomError::HttpError)?</span></span><br><span class="line"><span class="addition">+     .json::&lt;HashMap&lt;String, i32&gt;&gt;()</span></span><br><span class="line"><span class="addition">+     .map_err(|_| MyCustomError::HttpError)?;</span></span><br><span class="line"></span><br><span class="line">    let formatted_date = format!(&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;, res[&quot;years&quot;], res[&quot;months&quot;] + 1, res[&quot;date&quot;]);</span><br><span class="line"><span class="deletion">-   let parsed_date = NaiveDate::parse_from_str(formatted_date.as_str(), &quot;%Y-%m-%d&quot;)?;</span></span><br><span class="line"><span class="addition">+   let parsed_date = NaiveDate::parse_from_str(formatted_date.as_str(), &quot;%Y-%m-%d&quot;)</span></span><br><span class="line"><span class="addition">+     .map_err(|_| MyCustomError::ParseError)?;</span></span><br><span class="line">    let date = parsed_date.format(&quot;%Y %B %d&quot;).to_string();</span><br><span class="line"></span><br><span class="line">    Ok(date)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Notice how we’re using  <code>map_err</code>  to convert the error from one type to another type.</p>
<p>But things got verbose as a result - our function is littered with these  <code>map_err</code>  calls. We can implement the <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/std/convert/trait.From.html"> <code>From</code> </a> trait to automatically coerce the error types when we use the  <code>?</code>  operator:</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">  // error.rs</span><br><span class="line"></span><br><span class="line">  use std::fmt;</span><br><span class="line"></span><br><span class="line">  #[derive(Debug)]</span><br><span class="line">  pub enum MyCustomError &#123;</span><br><span class="line">    HttpError,</span><br><span class="line">    ParseError,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  impl std::error::Error for MyCustomError &#123;&#125;</span><br><span class="line"></span><br><span class="line">  impl fmt::Display for MyCustomError &#123;</span><br><span class="line">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result &#123;</span><br><span class="line">      match self &#123;</span><br><span class="line">        MyCustomError::HttpError =&gt; write!(f, &quot;HTTP Error&quot;),</span><br><span class="line">        MyCustomError::ParseError =&gt; write!(f, &quot;Parse Error&quot;),</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+ impl From&lt;reqwest::Error&gt; for MyCustomError &#123;</span></span><br><span class="line"><span class="addition">+   fn from(_: reqwest::Error) -&gt; Self &#123;</span></span><br><span class="line"><span class="addition">+     MyCustomError::HttpError</span></span><br><span class="line"><span class="addition">+   &#125;</span></span><br><span class="line"><span class="addition">+ &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ impl From&lt;chrono::format::ParseError&gt; for MyCustomError &#123;</span></span><br><span class="line"><span class="addition">+   fn from(_: chrono::format::ParseError) -&gt; Self &#123;</span></span><br><span class="line"><span class="addition">+     MyCustomError::ParseError</span></span><br><span class="line"><span class="addition">+   &#125;</span></span><br><span class="line"><span class="addition">+ &#125;</span></span><br><span class="line">  // main.rs</span><br><span class="line"></span><br><span class="line">  mod error;</span><br><span class="line"></span><br><span class="line">  use chrono::NaiveDate;</span><br><span class="line">  use error::MyCustomError;</span><br><span class="line">  use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">  fn main() &#123;</span><br><span class="line">    // skipped, will get back later</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn get_current_date() -&gt; Result&lt;String, MyCustomError&gt; &#123;</span><br><span class="line">    let url = &quot;https://postman-echo.com/time/object&quot;;</span><br><span class="line"><span class="deletion">-   let res = reqwest::blocking::get(url)</span></span><br><span class="line"><span class="deletion">-     .map_err(|_| MyCustomError::HttpError)?</span></span><br><span class="line"><span class="deletion">-     .json::&lt;HashMap&lt;String, i32&gt;&gt;()</span></span><br><span class="line"><span class="deletion">-     .map_err(|_| MyCustomError::HttpError)?;</span></span><br><span class="line"><span class="addition">+   let res = reqwest::blocking::get(url)?.json::&lt;HashMap&lt;String, i32&gt;&gt;()?;</span></span><br><span class="line"></span><br><span class="line">    let formatted_date = format!(&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;, res[&quot;years&quot;], res[&quot;months&quot;] + 1, res[&quot;date&quot;]);</span><br><span class="line"><span class="deletion">-   let parsed_date = NaiveDate::parse_from_str(formatted_date.as_str(), &quot;%Y-%m-%d&quot;)</span></span><br><span class="line"><span class="deletion">-     .map_err(|_| MyCustomError::ParseError)?;</span></span><br><span class="line"><span class="addition">+   let parsed_date = NaiveDate::parse_from_str(formatted_date.as_str(), &quot;%Y-%m-%d&quot;)?;</span></span><br><span class="line">    let date = parsed_date.format(&quot;%Y %B %d&quot;).to_string();</span><br><span class="line"></span><br><span class="line">    Ok(date)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>We’ve removed  <code>map_err</code>  and the code looks much cleaner!</p>
<p>However,  <code>From</code>  trait is not magic and there are times when we need to use  <code>map_err</code> . In the above example, we’ve moved the type conversion from inside the  <code>get_current_date</code>  function to the  <code>From&lt;X&gt; for MyCustomError</code>  implementation. This works well when the information needed to convert from one error to  <code>MyCustomError</code>  can be obtained from the original error object. If not, we need to use  <code>map_err</code>  inside  <code>get_current_date</code> .</p>
<h2 id="match-custom-errors"><a class="markdownIt-Anchor" href="#match-custom-errors">#</a> Match custom errors</h2>
<p>We’ve ignored the changes in  <code>main</code>  until now, here’s how we can handle the custom errors:</p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  // main.rs</span><br><span class="line"></span><br><span class="line">  mod error;</span><br><span class="line"></span><br><span class="line">  use chrono::NaiveDate;</span><br><span class="line">  use error::MyCustomError;</span><br><span class="line">  use std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">  fn main() &#123;</span><br><span class="line">    match get_current_date() &#123;</span><br><span class="line">      Ok(date) =&gt; println!(&quot;We&#x27;ve time travelled to &#123;&#125;!!&quot;, date),</span><br><span class="line">      Err(e) =&gt; &#123;</span><br><span class="line">        eprintln!(&quot;Oh noes, we don&#x27;t know which era we&#x27;re in! :(&quot;);</span><br><span class="line"><span class="deletion">-       if let Some(err) = e.downcast_ref::&lt;reqwest::Error&gt;() &#123;</span></span><br><span class="line"><span class="deletion">-         eprintln!(&quot;Request Error: &#123;&#125;&quot;, err)</span></span><br><span class="line"><span class="deletion">-       &#125; else if let Some(err) = e.downcast_ref::&lt;chrono::format::ParseError&gt;() &#123;</span></span><br><span class="line"><span class="deletion">-         eprintln!(&quot;Parse Error: &#123;&#125;&quot;, err)</span></span><br><span class="line"><span class="deletion">-       &#125;</span></span><br><span class="line"><span class="addition">+       match e &#123;</span></span><br><span class="line"><span class="addition">+         MyCustomError::HttpError =&gt; eprintln!(&quot;Request Error: &#123;&#125;&quot;, e),</span></span><br><span class="line"><span class="addition">+         MyCustomError::ParseError =&gt; eprintln!(&quot;Parse Error: &#123;&#125;&quot;, e),</span></span><br><span class="line"><span class="addition">+       &#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn get_current_date() -&gt; Result&lt;String, MyCustomError&gt; &#123;</span><br><span class="line">    let url = &quot;https://postman-echo.com/time/object&quot;;</span><br><span class="line">    let res = reqwest::blocking::get(url)?.json::&lt;HashMap&lt;String, i32&gt;&gt;()?;</span><br><span class="line"></span><br><span class="line">    let formatted_date = format!(&quot;&#123;&#125;-&#123;&#125;-&#123;&#125;&quot;, res[&quot;years&quot;], res[&quot;months&quot;] + 1, res[&quot;date&quot;]);</span><br><span class="line">    let parsed_date = NaiveDate::parse_from_str(formatted_date.as_str(), &quot;%Y-%m-%d&quot;)?;</span><br><span class="line">    let date = parsed_date.format(&quot;%Y %B %d&quot;).to_string();</span><br><span class="line"></span><br><span class="line">    Ok(date)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Notice how unlike boxed errors, we can actually match on the variants inside  <code>MyCustomError</code>  enum.</p>

      <div class="tags">
          <a href="/tags/rust/" rel="tag"><i class="ic i-tag"></i> rust</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2021-10-18 13:27:20" itemprop="dateModified" datetime="2021-10-18T13:27:20+08:00">2021-10-18</time>
  </span>
</div>

      

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2020/07/24/oracel-merge/" itemprop="url" rel="prev" data-background-image="&#x2F;anime&#x2F;index&#x2F;编舟记.jpg" title="Oracle Merge">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>Oracle Merge</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2020/08/04/rust-raw-string/" itemprop="url" rel="next" data-background-image="&#x2F;anime&#x2F;index&#x2F;死神.jpg" title="Rust raw string literals">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>Rust raw string literals</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ignore-the-error"><span class="toc-number">1.</span> <span class="toc-text"> Ignore the error</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#terminate-the-program"><span class="toc-number">2.</span> <span class="toc-text"> Terminate the program</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#use-a-fallback-value"><span class="toc-number">3.</span> <span class="toc-text"> Use a fallback value</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bubble-up-the-error"><span class="toc-number">4.</span> <span class="toc-text"> Bubble up the error</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bubble-up-multiple-errors"><span class="toc-number">5.</span> <span class="toc-text"> Bubble up multiple errors</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#match-boxed-errors"><span class="toc-number">6.</span> <span class="toc-text"> Match boxed errors</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#applications-vs-libraries"><span class="toc-number">7.</span> <span class="toc-text"> Applications vs Libraries</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#application"><span class="toc-number">7.1.</span> <span class="toc-text"> Application</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#library"><span class="toc-number">7.2.</span> <span class="toc-text"> Library</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#create-custom-errors"><span class="toc-number">8.</span> <span class="toc-text"> Create custom errors</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bubble-up-custom-errors"><span class="toc-number">9.</span> <span class="toc-text"> Bubble up custom errors</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#match-custom-errors"><span class="toc-number">10.</span> <span class="toc-text"> Match custom errors</span></a></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="江边鸟"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">江边鸟</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">347</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">2</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">50</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
      <span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xoY2hlbjc0" title="https:&#x2F;&#x2F;github.com&#x2F;lhchen74"><i class="ic i-github"></i></span>
      <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLw==" title="https:&#x2F;&#x2F;music.163.com&#x2F;"><i class="ic i-cloud-music"></i></span>
      <span class="exturl item codepen" data-url="aHR0cHM6Ly9jb2RlcGVuLmlvL2xoY2hlbjc0" title="https:&#x2F;&#x2F;codepen.io&#x2F;lhchen74"><i class="ic i-address-card"></i></span>
      <span class="exturl item anki" data-url="aHR0cHM6Ly9hbmtpd2ViLm5ldC9kZWNrcy8=" title="https:&#x2F;&#x2F;ankiweb.net&#x2F;decks&#x2F;"><i class="ic i-address-card"></i></span>
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>

    
  <li class="item">
    <a href="/about/" rel="section"><i class="ic i-user"></i>About</a>
  </li>

        
  <li class="item dropdown">
      <a href="javascript:void(0);"><i class="ic i-feather"></i>Posts</a>
    <ul class="submenu">

        
  <li class="item">
    <a href="/archives/" rel="section"><i class="ic i-list-alt"></i>Archives</a>
  </li>

        
  <li class="item">
    <a href="/categories/" rel="section"><i class="ic i-th"></i>Categories</a>
  </li>

        
  <li class="item">
    <a href="/tags/" rel="section"><i class="ic i-tags"></i>Tags</a>
  </li>

  </ul>
    
  <li class="item">
    <a href="/friends/" rel="section"><i class="ic i-heart"></i>Friends</a>
  </li>

    
  <li class="item">
    <a href="/anime/" rel="section"><i class="ic i-magic"></i>Anime</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2020/07/24/oracel-merge/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2020/08/04/rust-raw-string/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">江边鸟 @ D E W</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2020/08/01/rust-error/',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
